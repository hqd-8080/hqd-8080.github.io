{"meta":{"title":"Hexo","subtitle":"","description":"","author":"hqd8080","url":"https://hqd8080.github.io","root":"/"},"pages":[{"title":"关于","date":"2024-05-28T15:18:09.506Z","updated":"2024-05-28T15:18:09.506Z","comments":false,"path":"about/index.html","permalink":"https://hqd8080.github.io/about/index.html","excerpt":"","text":"123456789&#123; &quot;address&quot;: &quot;Shanghai, China&quot;, &quot;description&quot;: &quot;计算机软件工程专业&quot;, &quot;experience&quot;: &quot;12年多互联网服务端研发经验；7年多 Golang 使用经验&quot;, &quot;skills&quot;: [ [&quot;对分布式架构、微服务架构有深入研究&quot;, &quot;有区块链相关开发经验&quot;], ]&#125;"},{"title":"标签","date":"2022-09-26T14:03:28.861Z","updated":"2021-08-24T04:39:40.000Z","comments":false,"path":"tags/index.html","permalink":"https://hqd8080.github.io/tags/index.html","excerpt":"","text":""},{"title":"分类","date":"2022-09-26T14:03:28.861Z","updated":"2021-08-21T14:55:23.000Z","comments":false,"path":"categories/index.html","permalink":"https://hqd8080.github.io/categories/index.html","excerpt":"","text":""}],"posts":[{"title":"Go语言控制并发数的两种常用方式","slug":"golang/go-goroutine-limit","date":"2024-04-25T13:09:10.000Z","updated":"2024-04-25T15:09:01.005Z","comments":true,"path":"2024/04/25/golang/go-goroutine-limit/","link":"","permalink":"https://hqd8080.github.io/2024/04/25/golang/go-goroutine-limit/","excerpt":"","text":"Go语言控制并发数的两种常用方式Go语言的协程，体积轻量，高效的GPM调度；但是无限的开辟Goroutine数量而不主动去控制，会造成系统资源紧缺遭到panic错误退出；协程的资源其实是所有用户态共享的资源，所以大批的开辟Goroutine最终引发的灾难不仅是自身，还会关联到其他的程序；因此在编写业务代码的时候，限制Goroutine是必须重视的问题； Go语言控制并发数的两种常用方式有： ① 使用有缓冲通道+等待组的方式② 使用无缓冲通道+等待组任务发送和执行任务分离的方式 ① 使用有缓冲通道+等待组的方式123456789101112131415161718192021222324252627282930313233343536373839// @package : main// @file : main.go// @author : hqd8080// @contact : hanquanding@163.com// @time : 2024/4/25// @description: 使用有缓冲通道+等待组控制Goroutine数量package mainimport ( &quot;fmt&quot; &quot;math&quot; &quot;runtime&quot; &quot;sync&quot;)func worker(ch chan bool, wg *sync.WaitGroup, i int) &#123; defer wg.Done() fmt.Printf(&quot;currentTask:%d, goroutineCount:%d\\n&quot;, i, runtime.NumGoroutine()) &lt;-ch return&#125;func main() &#123; var wg sync.WaitGroup busiTaskCount := math.MaxInt64 // 模拟用户需求的业务并发数量 ch := make(chan bool, 3) // 有缓冲通道，可以达到限制goroutine并发数量的目的，缓存区满阻塞等待 for i := 0; i &lt; busiTaskCount; i++ &#123; wg.Add(1) ch &lt;- true go worker(ch, &amp;wg, i) &#125; wg.Wait()&#125; 1234567currentTask:285043, goroutineCount:4currentTask:285028, goroutineCount:4currentTask:285045, goroutineCount:4currentTask:285047, goroutineCount:4... ② 使用无缓冲通道+等待组任务发送和执行任务分离的方式实现12345678910111213141516171819202122232425262728293031323334353637383940414243444546// @package : main// @file : main.go// @author : hqd8080// @contact : hanquanding@163.com// @time : 2024/4/25// @description: 使用无缓冲通道和等待组控制并发数的例子package mainimport ( &quot;fmt&quot; &quot;math&quot; &quot;runtime&quot; &quot;sync&quot;)func Worker(ch chan int, wg *sync.WaitGroup) &#123; for c := range ch &#123; fmt.Printf(&quot;currentTask:%d, goroutineCount:%d\\n&quot;, c, runtime.NumGoroutine()) wg.Done() &#125;&#125;func sendTask(ch chan int, task int, wg *sync.WaitGroup) &#123; wg.Add(1) ch &lt;- task&#125;func main() &#123; var wg sync.WaitGroup ch := make(chan int) // 无缓冲的整型通道 numGoroutine := 5 // 启动Goroutine的数量 for i := 0; i &lt; numGoroutine; i++ &#123; go Worker(ch, &amp;wg) &#125; busiTaskCount := math.MaxInt64 // 模拟用户需求的业务并发数量 for task := 0; task &lt; busiTaskCount; task++ &#123; sendTask(ch, task, &amp;wg) // 发送任务 &#125; wg.Wait()&#125; 1234567currentTask:23853, goroutineCount:6currentTask:23855, goroutineCount:6currentTask:23856, goroutineCount:6currentTask:23851, goroutineCount:6.程序顺利执行不会出现崩溃情况...","categories":[{"name":"Go语言","slug":"Go语言","permalink":"https://hqd8080.github.io/categories/Go%E8%AF%AD%E8%A8%80/"}],"tags":[{"name":"golang","slug":"golang","permalink":"https://hqd8080.github.io/tags/golang/"}]},{"title":"Go语言常用的 JWT 认证函数","slug":"golang/go-jwt-func","date":"2024-01-02T13:10:10.000Z","updated":"2024-04-26T08:48:01.139Z","comments":true,"path":"2024/01/02/golang/go-jwt-func/","link":"","permalink":"https://hqd8080.github.io/2024/01/02/golang/go-jwt-func/","excerpt":"","text":"安装包12go get -u github.com/golang-jwt/jwt/v4import &quot;github.com/golang-jwt/jwt/v4&quot; 创建 Jwt token 和解析 Jwt token 函数1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253// @package : jwt// @file : jwt.go// @author : hqd8080// @contact : hanquanding@163.com// @time : 2024/1/02// @description: jwtpackage jwtimport ( &quot;errors&quot; &quot;github.com/golang-jwt/jwt/v4&quot; &quot;time&quot;)type JwtPayload struct &#123; UserID uint `json:&quot;user_id&quot;` Username string `json:&quot;username&quot;`&#125;type MyCustomClaims struct &#123; JwtPayload jwt.RegisteredClaims&#125;// CreateJwtToken 创建Jwt tokenfunc CreateJwtToken(jwtPayload JwtPayload, accessSecret string, expires int64) (string, error) &#123; claims := MyCustomClaims&#123; JwtPayload: jwtPayload, RegisteredClaims: jwt.RegisteredClaims&#123; ExpiresAt: jwt.NewNumericDate(time.Now().Add(time.Hour * time.Duration(expires))), &#125;, &#125; token := jwt.NewWithClaims(jwt.SigningMethodHS256, claims) return token.SignedString([]byte(accessSecret))&#125;// ParseJwtToken 解析Jwt tokenfunc ParseJwtToken(tokenString string, accessSecret string) (*MyCustomClaims, error) &#123; token, err := jwt.ParseWithClaims(tokenString, &amp;MyCustomClaims&#123;&#125;, func(token *jwt.Token) (interface&#123;&#125;, error) &#123; return []byte(accessSecret), nil &#125;) if err != nil &#123; return nil, err &#125; if claims, ok := token.Claims.(*MyCustomClaims); ok &amp;&amp; token.Valid &#123; return claims, nil &#125; return nil, errors.New(&quot;invalid jwt token&quot;)&#125; 单元测试代码1234567891011121314151617181920212223242526272829303132333435// @package : jwt// @file : jwt_test.go// @author : hqd8080// @contact : hanquanding@163.com// @time : 2024/1/02// @description: jwt_testpackage jwtimport &quot;testing&quot;const accessSecret = &quot;nftmall&quot;const expiresHour = 2func TestCreateJwtToken(t *testing.T) &#123; jwtPayload := JwtPayload&#123; UserID: 8080, Username: &quot;hqd8080&quot;, &#125; token, err := CreateJwtToken(jwtPayload, accessSecret, expiresHour) if err != nil &#123; t.Fatal(err) &#125; t.Log(token)&#125;func TestParseJwtToken(t *testing.T) &#123; token := &quot;eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJ1c2VyX2lkIjo4MDgwLCJ1c2VybmFtZSI6ImhxZDgwODAiLCJleHAiOjE3MTQxMjQ2NTF9.Mt19-NiYo1Wz62uTtRhGZ9ew9WLVMObu_uy4hWo0ebU&quot; jwtToken, err := ParseJwtToken(token, accessSecret) if err != nil &#123; t.Fatal(err) &#125; t.Log(jwtToken)&#125; 123456789=== RUN TestCreateJwtToken jwt_test.go:25: eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJ1c2VyX2lkIjo4MDgwLCJ1c2VybmFtZSI6ImhxZDgwODAiLCJleHAiOjE3MTQxMjQ2NTF9.Mt19-NiYo1Wz62uTtRhGZ9ew9WLVMObu_uy4hWo0ebU--- PASS: TestCreateJwtToken (0.00s)PASS=== RUN TestParseJwtToken jwt_test.go:34: &amp;&#123;&#123;8080 hqd8080&#125; &#123; [] 2024-04-26 17:44:11 +0800 CST &lt;nil&gt; &lt;nil&gt; &#125;&#125;--- PASS: TestParseJwtToken (0.00s)PASS","categories":[{"name":"Go语言","slug":"Go语言","permalink":"https://hqd8080.github.io/categories/Go%E8%AF%AD%E8%A8%80/"}],"tags":[{"name":"golang","slug":"golang","permalink":"https://hqd8080.github.io/tags/golang/"}]},{"title":"Go语言常用的哈希加密函数","slug":"golang/go-bcrypt-hash","date":"2024-01-02T11:09:10.000Z","updated":"2024-04-26T08:34:51.991Z","comments":true,"path":"2024/01/02/golang/go-bcrypt-hash/","link":"","permalink":"https://hqd8080.github.io/2024/01/02/golang/go-bcrypt-hash/","excerpt":"","text":"安装包1go get -u -v golang.org/x/crypto/bcrypt 哈希加密和解密函数12345678910111213141516171819202122232425// @package : bcrypt// @file : pwd.go// @author : hqd8080// @contact : hanquanding@163.com// @time : 2024/1/02// @description: 哈希密码加密和密码校验package bcryptimport &quot;golang.org/x/crypto/bcrypt&quot;// HashPassword 密码哈希加密func HashPassword(password string) (string, error) &#123; hash, err := bcrypt.GenerateFromPassword([]byte(password), bcrypt.MinCost) return string(hash), err&#125;// CheckPasswordHash 密码校验 password:原始密码 hash:加密之后的密码func CheckPasswordHash(password, hash string) bool &#123; err := bcrypt.CompareHashAndPassword([]byte(hash), []byte(password)) if err != nil &#123; return false &#125; return true&#125; 单元测试1234567891011121314151617181920212223// @package : bcrypt// @file : pwd_test.go// @author : hqd8080// @contact : hanquanding@163.com// @time : 2024/1/02// @description: pwd_testpackage bcryptimport &quot;testing&quot;func TestHashPassword(t *testing.T) &#123; password, err := HashPassword(&quot;123456&quot;) if err != nil &#123; t.Fatal(err) &#125; t.Log(password)&#125;func TestCheckPasswordHash(t *testing.T) &#123; isOk := CheckPasswordHash(&quot;123456&quot;, &quot;$2a$04$7UBIkdPQq44m0v6FenQ2Ke8Yp6EBrJQJ4Fuox15IkRJ.eHGbOwcwC&quot;) t.Log(isOk)&#125; 1234567891011=== RUN TestHashPassword pwd_test.go:17: $2a$04$7UBIkdPQq44m0v6FenQ2Ke8Yp6EBrJQJ4Fuox15IkRJ.eHGbOwcwC--- PASS: TestHashPassword (0.00s)PASS=== RUN TestCheckPasswordHash pwd_test.go:22: true--- PASS: TestCheckPasswordHash (0.00s)PASS","categories":[{"name":"Go语言","slug":"Go语言","permalink":"https://hqd8080.github.io/categories/Go%E8%AF%AD%E8%A8%80/"}],"tags":[{"name":"golang","slug":"golang","permalink":"https://hqd8080.github.io/tags/golang/"}]},{"title":"Go语言使用 WebSocket 总结","slug":"golang/go-gorilla","date":"2023-08-17T09:00:00.000Z","updated":"2023-11-23T07:26:00.924Z","comments":true,"path":"2023/08/17/golang/go-gorilla/","link":"","permalink":"https://hqd8080.github.io/2023/08/17/golang/go-gorilla/","excerpt":"","text":"WebSocket是什么鬼?1.「WebSocket」是一种在TCP连接上进行全双工通信的协议。WebSocket 通信协议于2011年被IETF定为标准RFC 6455，并由RFC7936补充规范。WebSocket API也被W3C定为标准; 2.WebSocket使得客户端和服务器之间的数据交换变得更加简单，允许服务端主动向客户端推送数据。在WebSocket API中，浏览器和服务器只需要完成一次握手，两者之间就直接可以创建持久性的连接（长连接），并进行双向数据传输（全双工）; 3.WebSocket能更好的节省服务器资源和带宽，并且能够更实时的进行通信。一旦建立WebSocket连接，无论是服务器还是客户端，任意一方都可以直接向对方发送数据; 4.客户端为了和服务端建立一个WebSocket连接，首先要向服务器发起一个HTTP请求，这个请求和普通的请求不一样；会包含一些附加头信息，比如：Upgrade：WebSocket，服务器会解析这些附加头信息; 5.WebSocket协议为了兼容现有浏览器，所以在握手阶段使用了HTTP协议；WebSocket是类似TCP长连接的通信模式；WebSocket协议建立在TCP协议之上; 为什么需要 WebSocket？因为HTTP协议是短连接，客户端发起请求，服务端响应请求整个通信就结束了；HTTP协议有一个缺陷：通信只能由客户端发起；客户端要获取服务端的实时状态只能使用类似服务轮询请求的方式去实现；轮询的方式效率非常低、消耗服务器资源还要不停地连接和断开连接的过程； WebSocket的有点有： 1.建立在TCP协议之上，服务器端的实现比较容易； 2.与HTTP协议有着良好的兼容性；默认端口也是80和443，并且握手阶段采用HTTP协议； 3.数据格式比较轻量，性能开销小，通信高效； 4.可以发送文本，也可以发送二进制数据； 5.没有同源限制，客户端可以与任意服务器通信(双工通信)； 6.协议标识符是ws（如果加密，则为wss），服务器网址就是 URL; Go语言使用 WebSocket专门做了一下调研；目前Golang的生态中，使用WebSocket的开源包比较多的是https://github.com/gorilla/websocket 123go get -v github.com/gorilla/websocket或者go install github.com/gorilla/websocket@latest 下面使用Go语言分别实现一个「客户端」和一个websocket的「服务端」程序；服务端程序监听服务器端口；客户端通过HTTP协议连接到服务端； 服务端实现：websocket/server.go 123456789101112131415161718192021222324252627282930313233343536373839404142package mainimport ( &quot;github.com/gorilla/websocket&quot; &quot;log&quot; &quot;net/http&quot;)var ( addr = &quot;127.0.0.1:8888&quot; upgrader = websocket.Upgrader&#123; ReadBufferSize: 1024, WriteBufferSize: 1024, &#125;)func main() &#123; http.HandleFunc(&quot;/hello&quot;, serveWsHandler) log.Fatal(http.ListenAndServe(addr, nil))&#125;func serveWsHandler(w http.ResponseWriter, r *http.Request) &#123; ws, err := upgrader.Upgrade(w, r, nil) if err != nil &#123; log.Println(&quot;upgrade err:&quot;, err) return &#125; defer ws.Close() for &#123; mt, message, err := ws.ReadMessage() if err != nil &#123; log.Println(&quot;read message err:&quot;, err) break &#125; log.Println(&quot;received:&quot;, string(message)) if err := ws.WriteMessage(mt, message); err != nil &#123; log.Println(&quot;write message err:&quot;, err) break &#125; &#125;&#125; 客户端实现：websocket/client.go 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465package mainimport ( &quot;github.com/gorilla/websocket&quot; &quot;log&quot; &quot;net/url&quot; &quot;os&quot; &quot;os/signal&quot; &quot;time&quot;)var host = &quot;127.0.0.1:8888&quot;func main() &#123; done := make(chan struct&#123;&#125;) interrupt := make(chan os.Signal) signal.Notify(interrupt, os.Interrupt) socketURL := url.URL&#123;Scheme: &quot;ws&quot;, Host: host, Path: &quot;/hello&quot;&#125; log.Println(&quot;connecting to &quot;, socketURL.String()) conn, _, err := websocket.DefaultDialer.Dial(socketURL.String(), nil) if err != nil &#123; log.Println(&quot;conn to server err:&quot;, err) return &#125; defer conn.Close() go receiveHandler(conn, done) for &#123; select &#123; case &lt;-time.After(time.Duration(1) * time.Millisecond * 1000): err := conn.WriteMessage(websocket.TextMessage, []byte(&quot;Hello WebSocket!&quot;)) if err != nil &#123; return &#125; case &lt;-interrupt: // Ctrl + C SIGINT log.Println(&quot;received SIGINT interrupt signal&quot;) err := conn.WriteMessage(websocket.CloseMessage, websocket.FormatCloseMessage(websocket.CloseNormalClosure, &quot;&quot;)) if err != nil &#123; log.Println(&quot;closing websocket err:&quot;, err) return &#125; select &#123; case &lt;-done: log.Println(&quot;received channel closed! exiting....&quot;) case &lt;-time.After(time.Duration(1) * time.Second): log.Println(&quot;timeout in closing receiving channel. exiting....&quot;) &#125; return &#125; &#125;&#125;func receiveHandler(conn *websocket.Conn, done chan struct&#123;&#125;) &#123; defer close(done) for &#123; _, msg, err := conn.ReadMessage() if err != nil &#123; log.Println(&quot;read message err:&quot;, err) return &#125; log.Println(&quot;received:&quot;, string(msg)) &#125;&#125;","categories":[{"name":"Go语言","slug":"Go语言","permalink":"https://hqd8080.github.io/categories/Go%E8%AF%AD%E8%A8%80/"}],"tags":[{"name":"golang","slug":"golang","permalink":"https://hqd8080.github.io/tags/golang/"},{"name":"WebSocket","slug":"WebSocket","permalink":"https://hqd8080.github.io/tags/WebSocket/"}]},{"title":"Go语言两种（超时退出）程序的对比","slug":"golang/go-timeout","date":"2023-08-15T14:09:10.000Z","updated":"2023-11-22T05:29:38.919Z","comments":true,"path":"2023/08/15/golang/go-timeout/","link":"","permalink":"https://hqd8080.github.io/2023/08/15/golang/go-timeout/","excerpt":"","text":"Go语言两种（超时退出）程序的对比Go语言实现超时退出有好几种方式，比较常用的有两种：① 使用定时器 time.After、time.timer 和 select 配合使用② 使用 Context 包的 context.WithTimeout 方式实现 这两种方式还是有区别的，我比较喜欢使用 context.WithTimeout 的方式、一是比较优雅、二是 context 包是可重入的、比较适合复杂的业务场景 使用定时器 time.After、time.timer 和 select 配合实现超时退出1234567891011121314151617181920212223242526package mainimport ( &quot;fmt&quot; &quot;time&quot;)func main() &#123; done := make(chan bool) // 退出信号 timeout := time.Second * 5 // 设置超时时间 go func() &#123; // 模拟处理业务逻辑、并且任务超时 time.Sleep(time.Second * 10) done &lt;- true close(done) &#125;() // 监听多个通道的IO执行情况 select &#123; case &lt;-done: fmt.Println(&quot;Task finished...&quot;) case &lt;-time.After(timeout): fmt.Println(&quot;Task timeout...&quot;) &#125;&#125; 1Task timeout... 使用 Context 包的 context.WithTimeout 方式实现1234567891011121314151617181920212223242526272829package mainimport ( &quot;context&quot; &quot;fmt&quot; &quot;time&quot;)func main() &#123; timeout := time.Second * 5 ctx, cancel := context.WithTimeout(context.Background(), timeout) defer cancel() done := make(chan bool) // 任务完成信号 go func() &#123; // 模拟处理业务逻辑、并且任务超时 time.Sleep(time.Second * 2) done &lt;- true close(done) &#125;() select &#123; case &lt;-done: fmt.Println(&quot;Task finished...&quot;) case &lt;-ctx.Done(): fmt.Println(&quot;Task timeout...&quot;) &#125;&#125; 1Task timeout... 总结 1.如果是实现简单的超时程序直接使用 time.After、time.timer 和 select 配合使用就可以、但是实际应用场景大多会是多个协程交互的完成业务，这个时候使用 time.After 和 select 就比较难以实现复杂的业务场景. 2.Context包是go1.7提供的上下文，原生的并发控制原语；比较适合父协程和子协程和派出孙子协程的并发控制，尤其是超时控制直接就提供了context.WithTimeout 使用起来比较优雅，比较适合复杂的业务场景.","categories":[{"name":"Go语言","slug":"Go语言","permalink":"https://hqd8080.github.io/categories/Go%E8%AF%AD%E8%A8%80/"}],"tags":[{"name":"golang","slug":"golang","permalink":"https://hqd8080.github.io/tags/golang/"}]},{"title":"Go语言未知结构的json解析包go-simplejson","slug":"golang/go-gosimplejson","date":"2023-08-15T02:33:20.000Z","updated":"2023-10-07T11:34:34.121Z","comments":true,"path":"2023/08/15/golang/go-gosimplejson/","link":"","permalink":"https://hqd8080.github.io/2023/08/15/golang/go-gosimplejson/","excerpt":"","text":"Go语言笔记-未知结构的json解析包go-simplejson导入包12import github.com/bitly/go-simplejsongo get -v &quot;github.com/bitly/go-simplejson&quot; 使用例子12345678910111213// 定义未知格式的json格式var json = `&#123; &quot;test&quot;: &#123; &quot;array&quot;: [1, &quot;2&quot;, 3], &quot;arraywithsubs&quot;: [ &#123;&quot;subkeyone&quot;: 1&#125;, &#123;&quot;subkeytwo&quot;: 2, &quot;subkeythree&quot;: 3&#125; ], &quot;bignum&quot;: 9223372036854775807, &quot;uint64&quot;: 18446744073709551615 &#125;&#125;` 123456789101112131415161718192021222324252627282930313233buf := bytes.NewBuffer([]byte(jsonStr))// 通过从io.Reader取值,然后解码返回一个*Jsonjs, err := simplejson.NewFromReader(buf)if err != nil &#123; log.Printf(&quot;unknown format string, error:%v&quot;, err) return&#125;arr, _ := js.Get(&quot;test&quot;).Get(&quot;array&quot;).Array() // [1, &quot;2&quot;, 3] 注意数据类型for i, v := range arr &#123; var iv int switch v.(type) &#123; case json.Number: i64, err := v.(json.Number).Int64() if err != nil &#123; log.Printf(&quot;got err %#v\\n&quot;, err) &#125; iv = int(i64) case string: iv, _ = strconv.Atoi(v.(string)) &#125; if iv != i+1 &#123; log.Printf(&quot;got %#v expected %#v\\n&quot;, iv, i+1) &#125;&#125;// &#123;&quot;subkeyone&quot;: 1&#125;,mm := js.Get(&quot;test&quot;).Get(&quot;arraywithsubs&quot;).GetIndex(0).MustMap()if !reflect.DeepEqual(mm, map[string]interface&#123;&#125;&#123;&quot;subkeyone&quot;: json.Number(&quot;1&quot;)&#125;) &#123; log.Printf(&quot;got %#v\\n&quot;, mm)&#125; 包函数介绍12// NewFromReader 通过从io.Reader取值,然后解码返回一个*Jsonfunc NewFromReader(r io.Reader) (*Json, error) 12// Array 类型断言成 `array`func (j *Json) Array() ([]interface&#123;&#125;, error) 12// MustArray 保证返回一个&#x27; []interface&#123;&#125; &#x27;(默认为可选),当你想以一种简洁的方式对数组值进行交互时很有用func (j *Json) MustArray(args ...[]interface&#123;&#125;) []interface&#123;&#125; 12// Get返回一个指向一个新的Json对象的指针,该对象在其map表示法中的key表示形式对链接操作(用于遍历嵌套Json)很有用,即多个Get连用表示嵌套获取值func (j *Json) Get(key string) *Json 123// js.Get(&quot;top_level&quot;).Get(&quot;array&quot;).GetIndex(1).Get(&quot;key&quot;).Int()// GetIndex 根据index获取，Json对象的指针func (j *Json) GetIndex(index int) *Json 123456789101112// NewJson 在解封body后返回一个指向新`Json`对象的指针// NewJson returns a pointer to a new `Json` object// after unmarshaling `body` bytesfunc NewJson(body []byte) (*Json, error) &#123; j := new(Json) err := j.UnmarshalJSON(body) if err != nil &#123; return nil, err &#125; return j, nil&#125; 123456// CheckGet 返回一个指向新Json对象的指针和一个标识成功或失败的boolfunc (j *Json) CheckGet(key string) (*Json, bool)if data, ok := js.Get(&quot;top_level&quot;).CheckGet(&quot;inner&quot;); ok &#123; log.Println(data)&#125;","categories":[{"name":"Go语言","slug":"Go语言","permalink":"https://hqd8080.github.io/categories/Go%E8%AF%AD%E8%A8%80/"}],"tags":[{"name":"golang","slug":"golang","permalink":"https://hqd8080.github.io/tags/golang/"}]},{"title":"Kafka（四）容器化集群搭建","slug":"kafka/kafka4","date":"2023-06-21T14:12:08.000Z","updated":"2024-04-09T10:36:26.415Z","comments":true,"path":"2023/06/21/kafka/kafka4/","link":"","permalink":"https://hqd8080.github.io/2023/06/21/kafka/kafka4/","excerpt":"","text":"Kafka（四）容器化集群搭建docker-compose-cluster.yml文件123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100version: &#x27;2.1&#x27;services: zoo1: image: confluentinc/cp-zookeeper:7.3.2 hostname: zoo1 container_name: zoo1 ports: - &quot;2181:2181&quot; environment: ZOOKEEPER_CLIENT_PORT: 2181 ZOOKEEPER_SERVER_ID: 1 ZOOKEEPER_SERVERS: zoo1:2888:3888;zoo2:2888:3888;zoo3:2888:3888 zoo2: image: confluentinc/cp-zookeeper:7.3.2 hostname: zoo2 container_name: zoo2 ports: - &quot;2182:2182&quot; environment: ZOOKEEPER_CLIENT_PORT: 2182 ZOOKEEPER_SERVER_ID: 2 ZOOKEEPER_SERVERS: zoo1:2888:3888;zoo2:2888:3888;zoo3:2888:3888 zoo3: image: confluentinc/cp-zookeeper:7.3.2 hostname: zoo3 container_name: zoo3 ports: - &quot;2183:2183&quot; environment: ZOOKEEPER_CLIENT_PORT: 2183 ZOOKEEPER_SERVER_ID: 3 ZOOKEEPER_SERVERS: zoo1:2888:3888;zoo2:2888:3888;zoo3:2888:3888 kafka1: image: confluentinc/cp-kafka:7.3.2 hostname: kafka1 container_name: kafka1 ports: - &quot;9092:9092&quot; - &quot;29092:29092&quot; environment: KAFKA_ADVERTISED_LISTENERS: INTERNAL://kafka1:19092,EXTERNAL://$&#123;DOCKER_HOST_IP:-127.0.0.1&#125;:9092,DOCKER://host.docker.internal:29092 KAFKA_LISTENER_SECURITY_PROTOCOL_MAP: INTERNAL:PLAINTEXT,EXTERNAL:PLAINTEXT,DOCKER:PLAINTEXT KAFKA_INTER_BROKER_LISTENER_NAME: INTERNAL KAFKA_ZOOKEEPER_CONNECT: &quot;zoo1:2181,zoo2:2182,zoo3:2183&quot; KAFKA_BROKER_ID: 1 KAFKA_LOG4J_LOGGERS: &quot;kafka.controller=INFO,kafka.producer.async.DefaultEventHandler=INFO,state.change.logger=INFO&quot; KAFKA_AUTHORIZER_CLASS_NAME: kafka.security.authorizer.AclAuthorizer KAFKA_ALLOW_EVERYONE_IF_NO_ACL_FOUND: &quot;true&quot; depends_on: - zoo1 - zoo2 - zoo3 kafka2: image: confluentinc/cp-kafka:7.3.2 hostname: kafka2 container_name: kafka2 ports: - &quot;9093:9093&quot; - &quot;29093:29093&quot; environment: KAFKA_ADVERTISED_LISTENERS: INTERNAL://kafka2:19093,EXTERNAL://$&#123;DOCKER_HOST_IP:-127.0.0.1&#125;:9093,DOCKER://host.docker.internal:29093 KAFKA_LISTENER_SECURITY_PROTOCOL_MAP: INTERNAL:PLAINTEXT,EXTERNAL:PLAINTEXT,DOCKER:PLAINTEXT KAFKA_INTER_BROKER_LISTENER_NAME: INTERNAL KAFKA_ZOOKEEPER_CONNECT: &quot;zoo1:2181,zoo2:2182,zoo3:2183&quot; KAFKA_BROKER_ID: 2 KAFKA_LOG4J_LOGGERS: &quot;kafka.controller=INFO,kafka.producer.async.DefaultEventHandler=INFO,state.change.logger=INFO&quot; KAFKA_AUTHORIZER_CLASS_NAME: kafka.security.authorizer.AclAuthorizer KAFKA_ALLOW_EVERYONE_IF_NO_ACL_FOUND: &quot;true&quot; depends_on: - zoo1 - zoo2 - zoo3 kafka3: image: confluentinc/cp-kafka:7.3.2 hostname: kafka3 container_name: kafka3 ports: - &quot;9094:9094&quot; - &quot;29094:29094&quot; environment: KAFKA_ADVERTISED_LISTENERS: INTERNAL://kafka3:19094,EXTERNAL://$&#123;DOCKER_HOST_IP:-127.0.0.1&#125;:9094,DOCKER://host.docker.internal:29094 KAFKA_LISTENER_SECURITY_PROTOCOL_MAP: INTERNAL:PLAINTEXT,EXTERNAL:PLAINTEXT,DOCKER:PLAINTEXT KAFKA_INTER_BROKER_LISTENER_NAME: INTERNAL KAFKA_ZOOKEEPER_CONNECT: &quot;zoo1:2181,zoo2:2182,zoo3:2183&quot; KAFKA_BROKER_ID: 3 KAFKA_LOG4J_LOGGERS: &quot;kafka.controller=INFO,kafka.producer.async.DefaultEventHandler=INFO,state.change.logger=INFO&quot; KAFKA_AUTHORIZER_CLASS_NAME: kafka.security.authorizer.AclAuthorizer KAFKA_ALLOW_EVERYONE_IF_NO_ACL_FOUND: &quot;true&quot; depends_on: - zoo1 - zoo2 - zoo3 启动服务1docker-compose -f docker-compose-cluster.yml up -d 12345678✘ hqd@hqddeMBP  ~/develop/gowork/kafkamq/deployment  docker-compose -f docker-compose-cluster.yml psNAME COMMAND SERVICE STATUS PORTSkafka1 &quot;/etc/confluent/dock…&quot; kafka1 running 0.0.0.0:9092-&gt;9092/tcp, 0.0.0.0:29092-&gt;29092/tcpkafka2 &quot;/etc/confluent/dock…&quot; kafka2 running 0.0.0.0:9093-&gt;9093/tcp, 9092/tcp, 0.0.0.0:29093-&gt;29093/tcpkafka3 &quot;/etc/confluent/dock…&quot; kafka3 running 0.0.0.0:9094-&gt;9094/tcp, 9092/tcp, 0.0.0.0:29094-&gt;29094/tcpzoo1 &quot;/etc/confluent/dock…&quot; zoo1 running 2888/tcp, 0.0.0.0:2181-&gt;2181/tcp, 3888/tcpzoo2 &quot;/etc/confluent/dock…&quot; zoo2 running 2181/tcp, 2888/tcp, 3888/tcp, 0.0.0.0:2182-&gt;2182/tcpzoo3 &quot;/etc/confluent/dock…&quot; zoo3 running 2181/tcp, 2888/tcp, 3888/tcp, 0.0.0.0:2183-&gt;2183/tcp","categories":[{"name":"Kafka","slug":"Kafka","permalink":"https://hqd8080.github.io/categories/Kafka/"}],"tags":[{"name":"golang","slug":"golang","permalink":"https://hqd8080.github.io/tags/golang/"},{"name":"kafka","slug":"kafka","permalink":"https://hqd8080.github.io/tags/kafka/"}]},{"title":"Kafka（三）性能优化参数配置","slug":"kafka/kafka3","date":"2023-06-20T12:40:10.000Z","updated":"2024-04-08T13:02:51.391Z","comments":true,"path":"2023/06/20/kafka/kafka3/","link":"","permalink":"https://hqd8080.github.io/2023/06/20/kafka/kafka3/","excerpt":"","text":"Kafka（三）性能优化参数配置1.1 Kafka副本分配策略replicationKafka 采用分区机制对数据进行管理和存储，每个 topic 可以有多个分区，每个分区可以有多个副本（replication）应根据业务需求合理配置副本，一般建议设置至少2个副本以保证高可用性 1.2 Kafka数据备份与恢复Kafka 采用基于日志文件的存储方式，每个 Broker 节点上都有副本数据的本地备份在数据备份方面，可以通过配置 Kafka 的数据保留策略和数据分区调整策略来保证数据的持久性和安全性；在数据恢复方面，可以通过查找备份数据并进行相应的分区副本替换来恢复数据 1.3 参数配置优化服务端： 参数名 默认参数值 位置 优化场景 说明 num.network.threads 3 服务端 低延迟 num.io.threads 8 服务端 低延迟 socket.send.buffer.bytes 102400(100K) 服务端 高吞吐 socket.receive.buffer.bytes 65536(64K) 服务端 高吞吐 生产端： 参数名 默认参数值 位置 优化场景 说明 max.in.flight.requests.per.connection 5 生产端 幂等 buffer.memory 33554432（32M） 生产端 高吞吐 batch.size 16384(16K) 生产端 提高性能 linger.ms 0 生产端 提高性能 消费端： 参数名 默认参数值 位置 优化场景 说明 fetch.min.bytes 1 消费端 提高性能 网络交互次数 max.poll.records 500 消费端 批量处理 控制批量获取消息数量 fetch.max.bytes 57671680 (55M) 消费端 批量处理 控制批量获取消息字节大小","categories":[{"name":"Kafka","slug":"Kafka","permalink":"https://hqd8080.github.io/categories/Kafka/"}],"tags":[{"name":"golang","slug":"golang","permalink":"https://hqd8080.github.io/tags/golang/"},{"name":"kafka","slug":"kafka","permalink":"https://hqd8080.github.io/tags/kafka/"}]},{"title":"Kafka（二）常用脚本命令整理","slug":"kafka/kafka2","date":"2023-06-20T10:30:10.000Z","updated":"2024-04-02T13:39:39.252Z","comments":true,"path":"2023/06/20/kafka/kafka2/","link":"","permalink":"https://hqd8080.github.io/2023/06/20/kafka/kafka2/","excerpt":"","text":"Kafka（二）常用脚本命令整理1.1 Kafka服务端常用的脚本首先先启动Kafka服务，因为我本地是用docker-compose安装的，所以直接进去docker容器 12345docker exec -it kafka bash# kafka的服务端脚本位置在 /opt/bitnami/kafka/bincd /opt/bitnami/kafka/bin 1234567connect-distributed.sh kafka-configs.sh kafka-dump-log.sh kafka-metadata-quorum.sh kafka-server-start.sh kafka-verifiable-producer.shconnect-mirror-maker.sh kafka-console-consumer.sh kafka-e2e-latency.sh kafka-metadata-shell.sh kafka-server-stop.sh trogdor.shconnect-plugin-path.sh kafka-console-producer.sh kafka-features.sh kafka-mirror-maker.sh kafka-storage.sh windowsconnect-standalone.sh kafka-consumer-groups.sh kafka-get-offsets.sh kafka-producer-perf-test.sh kafka-streams-application-reset.sh zookeeper-security-migration.shkafka-acls.sh kafka-consumer-perf-test.sh kafka-jmx.sh kafka-reassign-partitions.sh kafka-topics.sh zookeeper-server-start.shkafka-broker-api-versions.sh kafka-delegation-tokens.sh kafka-leader-election.sh kafka-replica-verification.sh kafka-transactions.sh zookeeper-server-stop.shkafka-cluster.sh kafka-delete-records.sh kafka-log-dirs.sh kafka-run-class.sh kafka-verifiable-consumer.sh zookeeper-shell.sh 12345678910111213# topic主题相关操作//创建一个新的topic./kafka-topics.sh --bootstrap-server localhost:9092 --topic test-topic --create //列出已经存在的topic列表./kafka-topics.sh --bootstrap-server localhost:9092 --list //查看指定topic主题详情./kafka-topics.sh --bootstrap-server localhost:9092 --topic test-topic --describe //修改指定topic信息./kafka-topics.sh --bootstrap-server localhost:9092 --topic test-topic --alter --partitions 2 1234# 生产者和消费者./kafka-console-producer.sh --bootstrap-server localhost:9092 --topic test-topic //生产者./kafka-console-consumer.sh --bootstrap-server localhost:9092 --topic test-topic //消费者 2.1 java操作kafkamaven依赖 12345&lt;dependency&gt; &lt;groupId&gt;org.apache.kafka&lt;/groupId&gt; &lt;artifactId&gt;kafka-clients&lt;/artifactId&gt; &lt;version&gt;3.6.1&lt;/version&gt;&lt;/dependency&gt; 2.2 生产端代码12345678910111213141516171819202122232425262728293031323334package com.hqd8080.test.producer;import org.apache.kafka.clients.producer.KafkaProducer;import org.apache.kafka.clients.producer.ProducerConfig;import org.apache.kafka.clients.producer.ProducerRecord;import org.apache.kafka.common.serialization.StringSerializer;import java.util.HashMap;import java.util.Map;public class KafkaProducerTest &#123; public static void main(String[] args) &#123; //1.创建配置对象 //2.创建生产者对象 //3.创建数据 //4.通过生产者对象将数据发送到kafka //5.关闭生产者对象 Map&lt;String, Object&gt; producerConfig = new HashMap&lt;&gt;(); producerConfig.put(ProducerConfig.BOOTSTRAP_SERVERS_CONFIG, &quot;localhost:9092&quot;); producerConfig.put(ProducerConfig.KEY_SERIALIZER_CLASS_CONFIG, StringSerializer.class.getName()); producerConfig.put(ProducerConfig.VALUE_SERIALIZER_CLASS_CONFIG, StringSerializer.class.getName()); KafkaProducer&lt;String, String&gt; producer = new KafkaProducer&lt;String, String&gt;(producerConfig); for (int i =1; i &lt;= 10; i++) &#123; ProducerRecord&lt;String, String&gt; record = new ProducerRecord&lt;String, String&gt;( &quot;test-topic&quot;,&quot;key-&quot;+i,&quot;this is a test-&quot;+i ); producer.send(record); &#125; producer.close(); &#125;&#125; 2.3 消费端代码12345678910111213141516171819202122232425262728293031323334353637package com.hqd8080.test.consumer;import org.apache.kafka.clients.consumer.ConsumerConfig;import org.apache.kafka.clients.consumer.ConsumerRecord;import org.apache.kafka.clients.consumer.ConsumerRecords;import org.apache.kafka.clients.consumer.KafkaConsumer;import org.apache.kafka.common.serialization.StringDeserializer;import java.util.Collections;import java.util.HashMap;import java.util.Map;public class KafkaConsumerTest &#123; public static void main(String[] args) &#123; //1.创建配置对象 //2.创建消费者对象 //3.订阅主题 //4.消费者对象从kafka主题中拉取数据 //5.关闭消费者对象 Map&lt;String, Object&gt; consumerConfig = new HashMap&lt;&gt;(); consumerConfig.put(ConsumerConfig.BOOTSTRAP_SERVERS_CONFIG, &quot;localhost:9092&quot;); consumerConfig.put(ConsumerConfig.KEY_DESERIALIZER_CLASS_CONFIG, StringDeserializer.class.getName()); consumerConfig.put(ConsumerConfig.VALUE_DESERIALIZER_CLASS_CONFIG, StringDeserializer.class.getName()); consumerConfig.put(ConsumerConfig.GROUP_ID_CONFIG, &quot;consumer-group-id&quot;); KafkaConsumer&lt;String, String&gt; consumer = new KafkaConsumer&lt;String, String&gt;(consumerConfig); consumer.subscribe(Collections.singleton(&quot;test-topic&quot;)); while (true) &#123; final ConsumerRecords&lt;String, String&gt; records = consumer.poll(100); for (ConsumerRecord&lt;String, String&gt; record : records) &#123; System.out.println(record); &#125; &#125; //consumer.close(); &#125;&#125; 2.4 代码创建Topic主题kafka broker中的config/server.properties配置文件中配置了auto.create.topics.enable参数为true（默认值就是true）那么当生产者向一个尚未创建的topic发送消息时,会自动创建一个num.partitions（默认值为1）个分区和default.replication.factor（默认值为1）个副本的对应topic 不过一般不建议将auto.create.topics.enable参数设置为true，因为这个参数会影响topic的管理与维护 1234567891011121314151617181920212223242526272829303132package com.hqd8080.test.admin;import org.apache.kafka.clients.admin.Admin;import org.apache.kafka.clients.admin.AdminClientConfig;import org.apache.kafka.clients.admin.CreateTopicsResult;import org.apache.kafka.clients.admin.NewTopic;import java.util.Arrays;import java.util.HashMap;import java.util.Map;public class AdminTopicTest &#123; public static void main(String[] args) &#123; Map&lt;String, Object&gt; confMap = new HashMap&lt;&gt;(); confMap.put(AdminClientConfig.BOOTSTRAP_SERVERS_CONFIG, &quot;localhost:9092&quot;); final Admin admin = Admin.create(confMap); String topicName = &quot;hqd8080-topic&quot;; //主题、逻辑分区 int partitionCount = 1; //分区 short replicationCount = 1; //副本 NewTopic topic = new NewTopic(topicName, partitionCount, replicationCount); final CreateTopicsResult result = admin.createTopics( Arrays.asList(topic) ); admin.close(); &#125;&#125;","categories":[{"name":"Kafka","slug":"Kafka","permalink":"https://hqd8080.github.io/categories/Kafka/"}],"tags":[{"name":"golang","slug":"golang","permalink":"https://hqd8080.github.io/tags/golang/"},{"name":"kafka","slug":"kafka","permalink":"https://hqd8080.github.io/tags/kafka/"}]},{"title":"Kafka（一）学习笔记","slug":"kafka/kafka1","date":"2023-06-19T11:10:10.000Z","updated":"2024-04-26T05:30:19.196Z","comments":true,"path":"2023/06/19/kafka/kafka1/","link":"","permalink":"https://hqd8080.github.io/2023/06/19/kafka/kafka1/","excerpt":"","text":"Kafka（一）学习笔记1.1 Go语言操作KafkaKafka是一种高吞吐量的分布式发布订阅消息MQ系统，本文介绍了如何使用kafka-go这个库实现Go语言操作kafkasegmentio/kafka-go 是纯Go实现，提供了与kafka交互的低级别和高级别两套API，同时也支持Context并发控制 1.2 Kafka开发环境搭建这里使用docker-compose快速搭建一套单节点zookeeper和单节点kafka本地发环境 deployment/docker-compose.yml 12345678910111213141516171819202122232425262728293031323334353637383940version: &#x27;3&#x27;services: zookeeper: container_name: zookeeper hostname: zookeeper image: bitnami/zookeeper:latest ports: - 2181:2181 environment: ALLOW_ANONYMOUS_LOGIN: yes kafka: container_name: kafka image: bitnami/kafka:3.6.1 # 失败重启容器3次 restart: on-failure:3 links: - zookeeper ports: - 9092:9092 - 9093:9093 environment: KAFKA_CFG_BROKER_ID: 1 KAFKA_CFG_DELETE_TOPIC_ENABLE: &#x27;true&#x27; KAFKA_CFG_ADVERTISED_HOST_NAME: &#x27;localhost&#x27; KAFKA_CFG_ADVERTISED_PORT: &#x27;9092&#x27; KAFKA_CFG_ZOOKEEPER_CONNECT: zookeeper:2181 KAFKA_CFG_AUTO_CREATE_TOPICS_ENABLE: &#x27;true&#x27; KAFKA_CFG_MESSAGE_MAX_BYTES: &#x27;200000000&#x27; KAFKA_CFG_LISTENERS: &#x27;PLAINTEXT://:9092,SASL_PLAINTEXT://:9093&#x27; KAFKA_CFG_ADVERTISED_LISTENERS: &#x27;PLAINTEXT://localhost:9092,SASL_PLAINTEXT://localhost:9093&#x27; KAFKA_CFG_SASL_ENABLED_MECHANISMS: &#x27;PLAIN,SCRAM-SHA-256,SCRAM-SHA-512&#x27; KAFKA_CFG_AUTHORIZER_CLASS_NAME: &#x27;kafka.security.authorizer.AclAuthorizer&#x27; KAFKA_CFG_ALLOW_EVERYONE_IF_NO_ACL_FOUND: &#x27;true&#x27; KAFKA_OPTS: &quot;-Djava.security.auth.login.config=/opt/bitnami/kafka/config/kafka_jaas.conf&quot; ALLOW_PLAINTEXT_LISTENER: yes entrypoint: - &quot;/bin/bash&quot; - &quot;-c&quot; - echo -e &#x27;KafkaServer &#123;\\norg.apache.kafka.common.security.scram.ScramLoginModule required\\n username=&quot;adminscram&quot;\\n password=&quot;admin-secret&quot;;\\n org.apache.kafka.common.security.plain.PlainLoginModule required\\n username=&quot;adminplain&quot;\\n password=&quot;admin-secret&quot;\\n user_adminplain=&quot;admin-secret&quot;;\\n &#125;;&#x27; &gt; /opt/bitnami/kafka/config/kafka_jaas.conf; /opt/bitnami/kafka/bin/kafka-configs.sh --zookeeper zookeeper:2181 --alter --add-config &quot;SCRAM-SHA-256=[password=admin-secret-256],SCRAM-SHA-512=[password=admin-secret-512]&quot; --entity-type users --entity-name adminscram; exec /entrypoint.sh /run.sh 1.3 启动Kafka开发环境容器1docker-compose up -d 1234docker psc2d4264c208b bitnami/kafka:3.6.1 &quot;/bin/bash -c &#x27;echo …&quot; About an hour ago Up 2 minutes 0.0.0.0:9092-9093-&gt;9092-9093/tcp kafkaf29188f9b4ac bitnami/zookeeper:latest &quot;/opt/bitnami/script…&quot; About an hour ago Up 2 minutes 2888/tcp, 3888/tcp, 0.0.0.0:2181-&gt;2181/tcp, 8080/tcp zookeeper 1.4 安装kafka-go1go get -u -v github.com/segmentio/kafka-go 2.1 kafka生产端1234567891011121314151617181920212223242526272829303132// 生产者func writeKafka(ctx context.Context) &#123; writer := &amp;kafka.Writer&#123; Addr: kafka.TCP(&quot;localhost:9092&quot;), Topic: topic, Balancer: &amp;kafka.Hash&#123;&#125;, WriteTimeout: time.Second * 1, RequiredAcks: kafka.RequireNone, AllowAutoTopicCreation: true, // 自动创建topic &#125; defer writer.Close() // 5次写入重试机会 for i := 1; i &lt;= 5; i++ &#123; if err := writer.WriteMessages(ctx, kafka.Message&#123;Key: []byte(&quot;Key-A&quot;), Value: []byte(&quot;this&quot;)&#125;, kafka.Message&#123;Key: []byte(&quot;Key-B&quot;), Value: []byte(&quot;is&quot;)&#125;, kafka.Message&#123;Key: []byte(&quot;Key-C&quot;), Value: []byte(&quot;a&quot;)&#125;, kafka.Message&#123;Key: []byte(&quot;Key-D&quot;), Value: []byte(&quot;test&quot;)&#125;, ); err != nil &#123; if err == kafka.LeaderNotAvailable &#123; time.Sleep(time.Millisecond * 500) continue &#125; else &#123; fmt.Printf(&quot;failed to write message:%v\\n&quot;, err) &#125; &#125; else &#123; fmt.Printf(&quot;kafka write message success:%d\\n&quot;, i) break // 写入成功退出循环 &#125; &#125;&#125; 2.2 kafka消费端123456789101112131415161718192021// 消费者func readKafka(ctx context.Context) &#123; reader = kafka.NewReader(kafka.ReaderConfig&#123; Brokers: []string&#123;&quot;localhost:9092&quot;&#125;, Topic: topic, CommitInterval: time.Second * 1, GroupID: &quot;consumer-group-id&quot;, StartOffset: kafka.FirstOffset, &#125;) defer reader.Close() for &#123; if message, err := reader.ReadMessage(ctx); err != nil &#123; fmt.Printf(&quot;failed to read message:%v\\n&quot;, err) break &#125; else &#123; fmt.Printf(&quot;message at topic:%s,partition:%d,offset:%d,key:%s,value:%s\\n&quot;, message.Topic, message.Partition, message.Offset, string(message.Key), string(message.Value)) &#125; &#125;&#125; 2.3 退出信号监听，用于消费端正确退出12345678910func listenSignal() &#123; quit := make(chan os.Signal, 1) signal.Notify(quit, syscall.SIGINT, syscall.SIGTERM) sig := &lt;-quit // 收到退出信号 fmt.Printf(&quot;recv:%s\\n&quot;, sig.String()) if reader != nil &#123; reader.Close() &#125; os.Exit(0)&#125; 2.4 main函数调用1234567func main() &#123; ctx := context.Background() writeKafka(ctx) go listenSignal() readKafka(ctx)&#125; 123456kafka write message success:1message at topic:test-topic,partition:0,offset:32,key:Key-A,value:thismessage at topic:test-topic,partition:0,offset:33,key:Key-B,value:ismessage at topic:test-topic,partition:0,offset:34,key:Key-C,value:amessage at topic:test-topic,partition:0,offset:35,key:Key-D,value:test^Crecv:interrupt 2.5 最后附上全部代码1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586878889909192939495// @package : main// @file : kafka.go// @author : hqd8080// @contact : hanquanding@163.com// @time : 2023/6/19// @description: golang使用kafkapackage mainimport ( &quot;context&quot; &quot;fmt&quot; &quot;github.com/segmentio/kafka-go&quot; &quot;os&quot; &quot;os/signal&quot; &quot;syscall&quot; &quot;time&quot;)var topic = &quot;test-topic&quot;var reader *kafka.Reader// 生产者func writeKafka(ctx context.Context) &#123; writer := &amp;kafka.Writer&#123; Addr: kafka.TCP(&quot;localhost:9092&quot;), Topic: topic, Balancer: &amp;kafka.Hash&#123;&#125;, WriteTimeout: time.Second * 1, RequiredAcks: kafka.RequireNone, AllowAutoTopicCreation: true, // 自动创建topic &#125; defer writer.Close() // 5次写入重试机会 for i := 1; i &lt;= 5; i++ &#123; if err := writer.WriteMessages(ctx, kafka.Message&#123;Key: []byte(&quot;Key-A&quot;), Value: []byte(&quot;this&quot;)&#125;, kafka.Message&#123;Key: []byte(&quot;Key-B&quot;), Value: []byte(&quot;is&quot;)&#125;, kafka.Message&#123;Key: []byte(&quot;Key-C&quot;), Value: []byte(&quot;a&quot;)&#125;, kafka.Message&#123;Key: []byte(&quot;Key-D&quot;), Value: []byte(&quot;test&quot;)&#125;, ); err != nil &#123; if err == kafka.LeaderNotAvailable &#123; time.Sleep(time.Millisecond * 500) continue &#125; else &#123; fmt.Printf(&quot;failed to write message:%v\\n&quot;, err) &#125; &#125; else &#123; fmt.Printf(&quot;kafka write message success:%d\\n&quot;, i) break // 写入成功退出循环 &#125; &#125;&#125;// 消费者func readKafka(ctx context.Context) &#123; reader = kafka.NewReader(kafka.ReaderConfig&#123; Brokers: []string&#123;&quot;localhost:9092&quot;&#125;, Topic: topic, CommitInterval: time.Second * 1, GroupID: &quot;consumer-group-id&quot;, StartOffset: kafka.FirstOffset, &#125;) defer reader.Close() for &#123; if message, err := reader.ReadMessage(ctx); err != nil &#123; fmt.Printf(&quot;failed to read message:%v\\n&quot;, err) break &#125; else &#123; fmt.Printf(&quot;message at topic:%s,partition:%d,offset:%d,key:%s,value:%s\\n&quot;, message.Topic, message.Partition, message.Offset, string(message.Key), string(message.Value)) &#125; &#125;&#125;func listenSignal() &#123; quit := make(chan os.Signal, 1) signal.Notify(quit, syscall.SIGINT, syscall.SIGTERM) sig := &lt;-quit // 收到退出信号 fmt.Printf(&quot;recv:%s\\n&quot;, sig.String()) if reader != nil &#123; reader.Close() &#125; os.Exit(0)&#125;func main() &#123; ctx := context.Background() writeKafka(ctx) go listenSignal() readKafka(ctx)&#125;","categories":[{"name":"Kafka","slug":"Kafka","permalink":"https://hqd8080.github.io/categories/Kafka/"}],"tags":[{"name":"golang","slug":"golang","permalink":"https://hqd8080.github.io/tags/golang/"},{"name":"kafka","slug":"kafka","permalink":"https://hqd8080.github.io/tags/kafka/"}]},{"title":"Hardhat环境搭建、创建、运行、测试","slug":"blockchain/hardhat","date":"2023-06-03T11:35:10.000Z","updated":"2023-08-28T05:57:09.665Z","comments":true,"path":"2023/06/03/blockchain/hardhat/","link":"","permalink":"https://hqd8080.github.io/2023/06/03/blockchain/hardhat/","excerpt":"","text":"Hardhat环境搭建、创建、运行、测试、学会使用hardhat进行本地合约开发、测试是很方便的； Hardhat是一个用于开发智能合约和DApp的开发框架； 它是一个基于Node.js的命令行工具和开发环境， 为以太坊开发人员提供了一个快速、可靠和灵活的方式来编写、测试和部署智能合约和去中心化应用； 官网网址：https://hardhat.org 安装Hardhat创建hardhat安装目录 12mkdir hardhatcd hardhat 安装hardhat 1npm install --save-dev hardhat 在安装hardhat的目录下运行hardhat 1npx hardhat 选择创建hardhat配置文件、这里我选择javascript语言项目 编写、编译、测试、调试智能合约写一个简单的智能合约、在hardhat目录下创建一个新的目录 12mkdir contractscd contracts 添加Token.sol智能合约 12345678// SPDX-License-Identifier: GPL-3.0pragma solidity &gt;=0.8.2 &lt;0.9.0;contract Token &#123;&#125; 编译 1npx hardhat compile 测试、创建test文件夹，创建测试文件Token.js 12mkdir testcd test 12345678910const &#123; expect &#125; = require(&quot;chai&quot;);describe(&quot;Token contract&quot;, function () &#123; it(&quot;Deployment should assign the total supply of tokens to the owner&quot;, async function () &#123; const [owner] = await ethers.getSigners(); const Token = await ethers.getContractFactory(&quot;Token&quot;); const hardhatToken = await Token.deploy(); const ownerBalance = await hardhatToken.balanceOf(owner.address); expect(await hardhatToken.totalSupply()).to.equal(ownerBalance); &#125;);&#125;); 运行test命令 1npx hardhat test 部署合约到网络创建scripts文件夹，添加deploy.js文件 123456789101112async function main() &#123; const [deployer] = await ethers.getSigners(); console.log(&quot;Deploying contracts with the account:&quot;, deployer.address); console.log(&quot;Account balance:&quot;, (await deployer.getBalance()).toString()); const Token = await ethers.getContractFactory(&quot;Token&quot;); const token = await Token.deploy(); console.log(&quot;Token address:&quot;, token.address);&#125;main().then(() =&gt; process.exit(0)).catch((error) =&gt; &#123; console.error(error);process.exit(1);&#125;); 发布到hardhat自己的网络实例 1npx hardhat run scripts/deploy.js 发布到指定测试网络 12npx hardhat run scripts/deploy.js --network localhostlocalhost就是指定本地，可以替换成goeril之类的测试网络和eth主网","categories":[{"name":"区块链","slug":"区块链","permalink":"https://hqd8080.github.io/categories/%E5%8C%BA%E5%9D%97%E9%93%BE/"}],"tags":[{"name":"区块链","slug":"区块链","permalink":"https://hqd8080.github.io/tags/%E5%8C%BA%E5%9D%97%E9%93%BE/"},{"name":"Blockchain","slug":"Blockchain","permalink":"https://hqd8080.github.io/tags/Blockchain/"},{"name":"Solidity","slug":"Solidity","permalink":"https://hqd8080.github.io/tags/Solidity/"},{"name":"hardhat","slug":"hardhat","permalink":"https://hqd8080.github.io/tags/hardhat/"}]},{"title":"使用 kubectl 命令生成 YAML 样版文件","slug":"kubernetes/0010","date":"2023-04-26T04:50:10.000Z","updated":"2023-11-01T01:19:40.186Z","comments":true,"path":"2023/04/26/kubernetes/0010/","link":"","permalink":"https://hqd8080.github.io/2023/04/26/kubernetes/0010/","excerpt":"","text":"使用kubectl命令生成YAML样版文件可以利用kubectl指令来生成YAML配置文件的模板，简化我们编写YAML配置文件的过程 使用kubectl命令生成Pod的 YAML 样板示例1kubectl run mynginx --image=nginx:alpine --dry-run=client -o yaml 生成好的YAML配置文件模板123456789101112131415apiVersion: v1kind: Podmetadata: creationTimestamp: null labels: run: mynginx name: mynginxspec: containers: - image: nginx:alpine name: mynginx resources: &#123;&#125; dnsPolicy: ClusterFirst restartPolicy: Alwaysstatus: &#123;&#125; 使用生成好的文件发布pod资源对象1kubectl apply -f mynginx.yaml 查看pod1kubectl get pods","categories":[{"name":"Kubernetes","slug":"Kubernetes","permalink":"https://hqd8080.github.io/categories/Kubernetes/"}],"tags":[{"name":"kubernetes","slug":"kubernetes","permalink":"https://hqd8080.github.io/tags/kubernetes/"},{"name":"k8s","slug":"k8s","permalink":"https://hqd8080.github.io/tags/k8s/"}]},{"title":"Go语言并发控制总结","slug":"golang/go-goroutine","date":"2022-04-01T14:09:10.000Z","updated":"2023-10-07T11:34:29.298Z","comments":true,"path":"2022/04/01/golang/go-goroutine/","link":"","permalink":"https://hqd8080.github.io/2022/04/01/golang/go-goroutine/","excerpt":"","text":"Go语言的并发控制Go语言原生支持的三种常用并发控制有Channel、WaitGroup、Context等； ① Channel：使用chan控制子协程； ② WaitGroup：使用信号量机制控制子协程； ③ Context：使用上下文控制子协程； 三种方式各有优缺点： Channel的优点是：实现简单，流程清晰易懂； WaitGroup的优点是：子协程数可动态调整； Context的优点是：对子协程派生出来的孙子协程的控制； Channel使用chan控制子协程chan是Go语言原生支持的通道类型、用于协程之间的通信；也可以用于并发控制； 1234567891011121314151617181920212223242526272829303132package mainimport ( &quot;fmt&quot; &quot;time&quot;)// channel 并发控制func main() &#123; channels := make([]chan int, 10) // 创建一个包含10个元素的切片，元素类型为channel for i := 0; i &lt; 10; i++ &#123; // 在切片中放入一个channel channels[i] = make(chan int) // 启动协程，传入一个管道用于通信 go Process(channels[i]) &#125; // 遍历切片，等待子协程结束 for i, ch := range channels &#123; &lt;-ch fmt.Println(&quot;routine &quot;, i, &quot; quit!&quot;) &#125;&#125;func Process(ch chan int) &#123; // do some work... time.Sleep(time.Second * 1) // 在管道中写入一个元素、表示当前协程已结束 ch &lt;- 1&#125; Go语言生产者和消费者的例子 12345678910111213141516171819202122232425262728293031package mainimport &quot;fmt&quot;// 消费者func consumer(data chan int, done chan bool) &#123; // 接收数据，直到通道被关闭 for v := range data &#123; fmt.Println(&quot;recv:&quot;, v) &#125; // 通知main消费结束 done &lt;- true&#125;// 生产者func producer(data chan int) &#123; for i := 0; i &lt; 4; i++ &#123; // 发送数据 data &lt;- i &#125; // 生产结束，关闭通道 close(data)&#125;func main() &#123; done := make(chan bool) // 用于接收消费者结束信号 data := make(chan int) // 数据管道 go consumer(data, done) // 启动消费者 go producer(data) // 启动生产者 &lt;-done // 阻塞，直到消费者发回结束信号&#125; 使用Channel并发控制的总结： 使用Channel控制子协程的优点是：实现简单； 缺点是：当需要大量创建子协程时就需要有相同数量的channel，而且对于子协程继续派生出来的协程不方便控制； WaitGroup使用信号量机制（等待组）控制子协程WaitGroup是Go应用开发中经常用的并发控制技术；WaitGroup对外提供了三个接口： ① Add(delta int)：将delta值加到counter中； ② Wait：阻塞等待信号量； ③ Done：counter递减1，按照waiter数值释放响应次数的信号量； 注意： Add操作必须早于Wait()，否则会触发panic； Add设置的值必须与实际等待的goroutine的个数一致，否则会触发panic； 123456789101112131415161718192021222324252627282930313233package mainimport ( &quot;fmt&quot; &quot;sync&quot; &quot;time&quot;)func main() &#123; var wg sync.WaitGroup wg.Add(2) go func() &#123; // do some work time.Sleep(time.Second) fmt.Println(&quot;finished!&quot;) wg.Done() &#125;() go func() &#123; // do some work time.Sleep(time.Second) wg.Done() &#125;() wg.Wait() fmt.Println(&quot;ok&quot;)&#125; Context使用上下文控制子协程Go语言的Context是开发中经常用到的并发控制技术；它与WaitGroup最大的不同点是： context对于派生goroutine有更强的控制力，它可以控制多级的goroutine；context翻译成中文是”上下文”； 源码：src/context/context.go:Context定义了该接口： 123456789type Context interface &#123; Deadline() (deadline time.Time, ok bool) Done() &lt;-chan struct&#123;&#125; Err() error Value(key interface&#123;&#125;) interface&#123;&#125;&#125; 一个典型的cancel context使用例子: 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859package mainimport ( &quot;context&quot; &quot;fmt&quot; &quot;time&quot;)func main() &#123; ctx, cancel := context.WithCancel(context.Background()) go HandelRequest(ctx) time.Sleep(time.Second * 5) fmt.Println(&quot;its time to stop all sub goroutine!&quot;) cancel() time.Sleep(time.Second * 5)&#125;func HandelRequest(ctx context.Context) &#123; go WriteRedis(ctx) go WriteDatabase(ctx) for &#123; select &#123; case &lt;-ctx.Done(): fmt.Println(&quot;HandelRequest Done.&quot;) return default: fmt.Println(&quot;HandelRequest running.&quot;) time.Sleep(time.Second * 2) &#125; &#125;&#125;func WriteRedis(ctx context.Context) &#123; for &#123; select &#123; case &lt;-ctx.Done(): fmt.Println(&quot;WriteRedis Done.&quot;) return default: fmt.Println(&quot;WriteRedis running.&quot;) time.Sleep(time.Second * 2) &#125; &#125;&#125;func WriteDatabase(ctx context.Context) &#123; for &#123; select &#123; case &lt;-ctx.Done(): fmt.Println(&quot;WriteDatabase Done.&quot;) return default: fmt.Println(&quot;WriteDatabase running.&quot;) time.Sleep(time.Second * 2) &#125; &#125;&#125; 12345678910111213WriteDatabase running.WriteRedis running.HandelRequest running.HandelRequest running.WriteRedis running.WriteDatabase running.WriteDatabase running.WriteRedis running.HandelRequest running.its time to stop all sub goroutine!HandelRequest Done.WriteRedis Done.WriteDatabase Done.","categories":[{"name":"Go语言","slug":"Go语言","permalink":"https://hqd8080.github.io/categories/Go%E8%AF%AD%E8%A8%80/"}],"tags":[{"name":"golang","slug":"golang","permalink":"https://hqd8080.github.io/tags/golang/"}]},{"title":"Go语言内存管理和垃圾回收（GC）","slug":"golang/go-stw","date":"2022-04-01T13:10:10.000Z","updated":"2023-10-07T11:37:09.896Z","comments":true,"path":"2022/04/01/golang/go-stw/","link":"","permalink":"https://hqd8080.github.io/2022/04/01/golang/go-stw/","excerpt":"","text":"Go语言的内存管理和垃圾回收（GC）Go语言使用三色标记法回收内存 Go语言的GC是自动管理内存的机制，垃圾回收器会尝试回收程序不再使用的对象和占用的内存 常见垃圾回收算法： 1.引用计数 2.标记-清除 Go 3.分代收集 引用计数：对每个对象维护一个引用计数，当引用该对象的对象被销毁时，引用计数减1，当引用计数器为0时回收该对象优点：对象可以很快被回收缺点：不能很好的处理循环引用，而且实时的维护引用计数也有一定的代价代表语言：php，python 标记-清除：从根变量开始遍历所有引用的对象，引用的对象标记为”被引用”，没有被标记的变量被回收优点：解决引用计数的缺点，不能很好的处理循环引用，而且实时的维护引用计数也有一定的代价的缺点缺点：暂停程序的执行代表语言：Go （三色标记法） 分代收集按照对象生命周期的长短划分不同的代空间，生命周期长的放入老年代，而短的放入新生代，不同代有不同的回收算法和回收频率优点：收回性能好缺点：算法复杂代表语言:java Go的垃圾回收Go垃圾回收的原理是，标记出哪些内存还在使用中，（即被引用到），哪些内存不在使用了（即未被引用），把未被引用的内存回收，以供后续内存分配时再使用缺点就是，不是实时的回收内存，而是暂停程序的执行去处理内存回收 三色标记法这里的三色是对应了垃圾回收过程中对象的三种状态1.灰色：对象还在标记队列中等待2.黑色：对象已经被标记(该对象不会在本次GC中被清理)3.白色：对象未被标记(该对象会在本次GC中被清理) Go的STWGo中的STW（Stop The World）就是停止所有的goroutine，专心做垃圾回收，待垃圾回收结束后，再恢复goroutine,STW的长短直接影响了程序的性能 垃圾回收优化1.写屏障就是让goroutine与GC同时运行的手段，GC过程中新分配的内存会被立即标记，即本轮不回收，下次GC时再确定 2.补助GC使用goroutine参与一部分的GC工作来提高性能 垃圾回收的触发时机1.内存分配量达到阈值触发GC每次内存分配时都会检查当前内存分配量是否已达到阈值，如果达到阈值则立即触发GC阈值 = 上次GC内存分配量 X 内存增长率内存增长率由环境变量GOGC控制，默认为100，即每当内存扩大一倍时启动GC 2.定期触发GC默认情况下，最长两分钟触发一次GC 3.手动触发使用 runtime.GC() 来手动触发GC主要用于GC的性能测试和统计 逃逸分析是指由编译器决定内存分配的位置，不需要程序员指定 在函数中申请一个新的对象：如果分配在栈中，则函数执行结束后，可自动将内存回收如果分配在堆中，则函数执行结束后可交给GC（垃圾回收）处理 1.逃逸策略在函数中申请新的对象时，编辑器会根据该对象是否被函数外部引用来决定是否逃逸：如果函数外部没有引用，则优先放在栈中如果函数外部存在引用，则必定存放在堆中 注意：对于仅在函数内部使用的变量，也有可能存放在堆中，比如内存过大，超过栈的存储能力 使用interface类型存在逃逸的可能（动态类型逃逸）闭包引用对象逃逸","categories":[{"name":"Go语言","slug":"Go语言","permalink":"https://hqd8080.github.io/categories/Go%E8%AF%AD%E8%A8%80/"}],"tags":[{"name":"golang","slug":"golang","permalink":"https://hqd8080.github.io/tags/golang/"}]},{"title":"Go的通道、管道类型（chan）","slug":"golang/go-channel","date":"2022-04-01T12:10:10.000Z","updated":"2023-10-07T11:33:13.549Z","comments":true,"path":"2022/04/01/golang/go-channel/","link":"","permalink":"https://hqd8080.github.io/2022/04/01/golang/go-channel/","excerpt":"","text":"Go语言的通道、管道类型（chan）chan通道、管道类型的数据结构： 12345678910111213141516171819202122// 源码来自Go 1.19// 源码包：src/runtime/chan.go type hchan struct &#123; qcount uint // 当前队列中剩余的元素个数 dataqsiz uint // 环形队列长度、即可以存放的元素个数 buf unsafe.Pointer // 环形队列指针 elemsize uint16 // 每个元素的大小 closed uint32 // 关闭标示字段 elemtype *_type // 元素类型 sendx uint // 队列下标、元素写入时存放在队列中的位置 recvx uint // 队列下标、指示下一个被读取的元素在队列中的位置 recvq waitq // 等待读消息的协程队列 sendq waitq // 等待写消息的协程队列 // lock protects all fields in hchan, as well as several // fields in sudogs blocked on this channel. // // Do not change another G&#x27;s status while holding this lock // (in particular, do not ready a G), as this can deadlock // with stack shrinking. lock mutex // 互斥锁、保证chan并发安全操作&#125; 通道、管道类型是Go在语言层面提供的协程间的通信方式、也可以用于并发控制； Go语言的通道、管道类型实现互斥锁12345678910var counter int = 0var ch = make(chan int, 1)func Work() &#123; ch &lt;- 1 // 写入 counter++ &lt;-ch // 读取&#125;// 只有一个缓冲区的通道、写入数据类似于加锁、读取数据类似释放锁 通道、管道数据读写通道、管道没有缓冲区时，从管道读取数据会阻塞，直到有协程向管道中写入数据；类似的，向通道、管道写入数据也会阻塞，直到有协程从管道读取数据； 内置函数len()查询通道、管道缓冲区中数据的个数；内置函数cap()查询缓冲区的大小； 123456789func myChan() &#123; ch := make(chan int, 10) ch &lt;-1 ch &lt;-2 fmt.Println(len(ch)) // 2 fmt.Println(cap(ch)) // 10&#125; 通道、管道实现了一种FIFO（先入先出）的队列、数据总是按照写入的顺序流出管道； 单项管道的使用例子123456789101112131415func readChan(chanName &lt;-chan int) &#123; data:= &lt;- chanName fmt.Println(data)&#125;func writeChan(chanName chan&lt;- int) &#123; chanName &lt;- 1 &#125;func main() &#123; var mychan = make(chan int, 10) writeChan(mychan) readChan(mychan)&#125; 通道、管道 + select监控多个协程的执行情况123456789101112131415161718192021222324252627282930313233package mainimport ( &quot;fmt&quot; &quot;time&quot;)func main() &#123; var ch1 = make(chan int, 10) var ch2 = make(chan int, 10) go work(ch1) go work(ch2) for&#123; select&#123; case e:=&lt;-ch1: fmt.Printf(&quot;get element from ch1:%d\\n&quot;, e) case e:=&lt;-ch2: fmt.Printf(&quot;get element from ch2:%d\\n&quot;, e) default: fmt.Println(&quot;no element in ch1 and ch2!&quot;) time.Sleep(time.Second * 1) &#125; &#125;&#125;func work(ch chan int) &#123; for&#123; ch &lt;-1 time.Sleep(time.Second * 1) &#125; &#125; select在main中监控多个协程的执行情况；case的执行顺序是随机的（伪随机算法）实现I/O多路复用；","categories":[{"name":"Go语言","slug":"Go语言","permalink":"https://hqd8080.github.io/categories/Go%E8%AF%AD%E8%A8%80/"}],"tags":[{"name":"golang","slug":"golang","permalink":"https://hqd8080.github.io/tags/golang/"}]},{"title":"Go语言的时间类型（time）","slug":"golang/go-time","date":"2022-03-31T15:10:10.000Z","updated":"2023-10-07T11:37:47.083Z","comments":true,"path":"2022/03/31/golang/go-time/","link":"","permalink":"https://hqd8080.github.io/2022/03/31/golang/go-time/","excerpt":"","text":"Go语言的时间类型（time）12345678910111213141516171819202122232425// 源码来自Go 1.19// 源码包：/usr/local/go/src/time/time.gotype Time struct &#123; // wall and ext encode the wall time seconds, wall time nanoseconds, // and optional monotonic clock reading in nanoseconds. // // From high to low bit position, wall encodes a 1-bit flag (hasMonotonic), // a 33-bit seconds field, and a 30-bit wall time nanoseconds field. // The nanoseconds field is in the range [0, 999999999]. // If the hasMonotonic bit is 0, then the 33-bit field must be zero // and the full signed 64-bit wall seconds since Jan 1 year 1 is stored in ext. // If the hasMonotonic bit is 1, then the 33-bit field holds a 33-bit // unsigned wall seconds since Jan 1 year 1885, and ext holds a // signed 64-bit monotonic clock reading, nanoseconds since process start. wall uint64 ext int64 // loc specifies the Location that should be used to // determine the minute, hour, month, day, and year // that correspond to this Time. // The nil location means UTC. // All UTC times are represented with loc==nil, never loc==&amp;utcLoc. loc *Location&#125; wall：表示距离公元 1 年 1 月 1 日 00:00:00UTC 的秒数;ext：表示纳秒;loc：代表时区，主要处理偏移量，不同的时区，对应的时间不一样; 公认最准确的计算应该是使用“原子震荡周期”所计算的物理时钟了（Atomic Clock, 也被称为原子钟），这也被定义为标准时间（International Atomic Time） 而我们常常看见的 UTC（Universal Time Coordinated，世界协调时间）就是利用这种 Atomic Clock 为基准所定义出来的正确时间。UTC 标准时间是以 GMT（Greenwich Mean Time，格林尼治时间）这个时区为主，所以本地时间与 UTC 时间的时差就是本地时间与 GMT 时间的时差UTC + 时区差 ＝ 本地时间 国内一般使用的是北京时间，与 UTC 的时间关系如下：UTC + 8 个小时 = 北京时间 在Go语言的 time 包里面有两个时区变量，如下： time.UTC：UTC 时间 time.Local：本地时间 获取当前时间我们可以通过time.Now()函数来获取当前的时间对象，然后通过事件对象来获取当前的时间信息 12345678910111213141516package mainimport ( &quot;fmt&quot; &quot;time&quot;)func main() &#123; now := time.Now() //获取当前时间 fmt.Printf(&quot;current time:%v\\n&quot;, now) year := now.Year() //年 month := now.Month() //月 day := now.Day() //日 hour := now.Hour() //小时 minute := now.Minute() //分钟 second := now.Second() //秒 fmt.Printf(&quot;%d-%02d-%02d %02d:%02d:%02d\\n&quot;, year, month, day, hour, minute, second)&#125; 时间操作函数我们在日常的开发过程中可能会遇到要求某个时间 + 时间间隔之类的需求，Go语言中的 Add 方法实现func (t Time) Add(d Duration) Time 12345678910package mainimport ( &quot;fmt&quot; &quot;time&quot;)func main() &#123; now := time.Now() later := now.Add(time.Hour) // 当前时间加1小时后的时间 fmt.Println(later)&#125; 求两个时间之间的差值func (t Time) Sub(u Time) Duration 判断两个时间是否相同，会考虑时区的影响，因此不同时区标准的时间也可以正确比较func (t Time) Equal(u Time) bool 如果t代表的时间点在u之前，返回真；否则返回假func (t Time) Before(u Time) bool 如果t代表的时间点在u之后，返回真；否则返回假func (t Time) After(u Time) bool 定时器使用time.Tick(时间间隔)来设置定时器，定时器的本质上是一个通道（channel） 123456func TestTick() &#123; ticker := time.Tick(time.Second) //定义一个1秒间隔的定时器 for i := range ticker &#123; fmt.Println(i)//每秒都会执行的任务 &#125;&#125;","categories":[{"name":"Go语言","slug":"Go语言","permalink":"https://hqd8080.github.io/categories/Go%E8%AF%AD%E8%A8%80/"}],"tags":[{"name":"golang","slug":"golang","permalink":"https://hqd8080.github.io/tags/golang/"}]},{"title":"Go的异常处理、异常处理机制defer、recover、panic（error）","slug":"golang/go-error","date":"2022-03-31T14:10:10.000Z","updated":"2023-10-24T06:07:37.816Z","comments":true,"path":"2022/03/31/golang/go-error/","link":"","permalink":"https://hqd8080.github.io/2022/03/31/golang/go-error/","excerpt":"","text":"Go语言的异常处理Go语言的异常处理和Java、PHP语言的try…catch不一样！Go是使用内置的error来处理错误，用panic和recover来处理异常； panic抛出异常、这个异常直接回导致程序崩溃暂停程序的执行，官方建议并发程序中慎用！ defer捕获异常、defer延迟执行、实现类似栈的”先进后出”的数据结构、一般defer后面直接和匿名函数+recover来捕获和处理异常； recover恢复异常处理！recover必须和defer直接调用才有效，否则永远返回nil（编程陷阱）！ 1234567891011func worker() &#123; defer func() &#123; if err := recover(); err != nil &#123; // 日志记录堆栈信息 glog.Errorln(string(debug.Stack())) log.Println(&quot;err:%v&quot;, err) &#125; &#125;() panic(&quot;抛出异常、致命恐慌、会中断程序&quot;) fmt.Println(&quot;执行不到的代码行&quot;)&#125;","categories":[{"name":"Go语言","slug":"Go语言","permalink":"https://hqd8080.github.io/categories/Go%E8%AF%AD%E8%A8%80/"}],"tags":[{"name":"golang","slug":"golang","permalink":"https://hqd8080.github.io/tags/golang/"}]},{"title":"Go语言接口类型（interface）","slug":"golang/go-interface","date":"2022-03-31T13:10:10.000Z","updated":"2023-12-20T07:55:55.842Z","comments":true,"path":"2022/03/31/golang/go-interface/","link":"","permalink":"https://hqd8080.github.io/2022/03/31/golang/go-interface/","excerpt":"","text":"Go语言的接口类型（interface）在Go语言中、如果一个类型实现了一个接口的所有方法，那么这个类型的实例就可以存储在这个接口类型的实例中「鸭子类型」 Go语言不是一个「面向对象」的编程语言、使用「interface」实现类似面向对象的、继承、封装、多态、编程的思想； 接口的使用1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768package mainimport &quot;fmt&quot;// 接口抽象type Card interface &#123; Display()&#125;type Memory interface &#123; Storage()&#125;type CPU interface &#123; Calculate()&#125;type Computer struct &#123; cpu CPU memory Memory card Card&#125;// 工厂函数func NewComputer(cpu CPU, memory Memory, card Card) *Computer &#123; return &amp;Computer&#123; cpu: cpu, memory: memory, card: card, &#125;&#125;func (c *Computer) DoWork() &#123; c.cpu.Calculate() c.memory.Storage() c.card.Display()&#125;// 实现接口部分type IntelCPU struct &#123; CPU&#125;func (i *IntelCPU) Calculate() &#123; fmt.Println(&quot;001--&gt;IntelCPU 实现 CPU接口的 Calculate()方法....&quot;)&#125;type IntelMemory struct &#123; Memory&#125;func (i *IntelMemory) Storage() &#123; fmt.Println(&quot;002--&gt;IntelMemory 实现 Memory接口的 Storage()方法....&quot;)&#125;type IntelCard struct &#123; Card&#125;func (i *IntelCard) Display() &#123; fmt.Println(&quot;003--&gt;IntelCard 实现 Card接口的 Display()方法....&quot;)&#125;func main() &#123; // 业务逻辑 computer := NewComputer(&amp;IntelCPU&#123;&#125;, &amp;IntelMemory&#123;&#125;, &amp;IntelCard&#123;&#125;) computer.DoWork()&#125; 123001--&gt;IntelCPU 实现 CPU接口的 Calculate()方法....002--&gt;IntelMemory 实现 Memory接口的 Storage()方法....003--&gt;IntelCard 实现 Card接口的 Display()方法....","categories":[{"name":"Go语言","slug":"Go语言","permalink":"https://hqd8080.github.io/categories/Go%E8%AF%AD%E8%A8%80/"}],"tags":[{"name":"golang","slug":"golang","permalink":"https://hqd8080.github.io/tags/golang/"}]},{"title":"Go语言结构体类型、使用组合实现OOP（struct）","slug":"golang/go-struct","date":"2022-03-31T12:10:10.000Z","updated":"2023-10-07T11:36:58.389Z","comments":true,"path":"2022/03/31/golang/go-struct/","link":"","permalink":"https://hqd8080.github.io/2022/03/31/golang/go-struct/","excerpt":"","text":"Go语言的结构体类型、使用组合实现面向对象（struct）Go语言的struct和其他语言的class有些类似；","categories":[{"name":"Go语言","slug":"Go语言","permalink":"https://hqd8080.github.io/categories/Go%E8%AF%AD%E8%A8%80/"}],"tags":[{"name":"golang","slug":"golang","permalink":"https://hqd8080.github.io/tags/golang/"}]},{"title":"Go语言的字典类型Map、以及并发安全的sync.Map类型（map）","slug":"golang/go-map","date":"2022-03-30T13:10:10.000Z","updated":"2023-10-24T06:27:25.745Z","comments":true,"path":"2022/03/30/golang/go-map/","link":"","permalink":"https://hqd8080.github.io/2022/03/30/golang/go-map/","excerpt":"","text":"Go语言的字典类型Map、以及并发安全的sync.Map类型（map）Go语言的map类型底层使用Hash表实现；（无序集合）； map类型的数据结构： 123456789101112131415// 源码来自Go 1.19// 源码包：/usr/local/go/src/runtime/map.gotype hmap struct &#123; count int // # live cells == size of map. Must be first (used by len() builtin) flags uint8 B uint8 // log_2 of # of buckets (can hold up to loadFactor * 2^B items) noverflow uint16 // approximate number of overflow buckets; see incrnoverflow for details hash0 uint32 // hash seed buckets unsafe.Pointer // array of 2^B Buckets. may be nil if count==0. oldbuckets unsafe.Pointer // previous bucket array of half the size, non-nil only when growing nevacuate uintptr // progress counter for evacuation (buckets less than this have been evacuated) extra *mapextra // optional fields&#125; map类型的增、删、改、查1234567891011func mapCURD() &#123; m := make(map[string]string, 10) m[&quot;apple&quot;] = &quot;red&quot; // 添加 m[&quot;apple&quot;] = &quot;green&quot; // 修改 delete(m, &quot;apple&quot;) // 删除 val, exist := m[&quot;apple&quot;] // 查询 if exist &#123; fmt.Println(&quot;apple - %s\\n&quot;, val) &#125; &#125; sync.Map并发安全的字典类型123456type Map struct &#123; mu Mutex read atomic.Value // 只负责读数据 dirty map[interface&#123;&#125;]*entey misses int&#125; sync.Map的主要思想就是：读写分离，空间换时间 1.(read)字段负责只读数据，并发安全（atomic.Value），避免读写冲突； 2.动态调整，miss次数多了之后，将dirty数据迁移到read中； 1234567891011121314151617type Map struct &#123; // 当涉及到脏数据(dirty)操作时候，需要使用这个锁 mu Mutex // read是一个只读数据结构，包含一个map结构， // 读不需要加锁，只需要通过 atomic 加载最新的数据即可 read atomic.Value // readOnly // dirty 包含部分map的键值对，如果操作需要mutex获取锁 // 最后dirty中的元素会被全部提升到read里的map去 dirty map[interface&#123;&#125;]*entry // misses是一个计数器，用于记录read中没有的数据而在dirty中有的数据的数量 // 也就是说如果read不包含这个数据，会从dirty中读取，并misses+1 // 当misses的数量等于dirty的长度，就会将dirty中的数据迁移到read中 misses int&#125;","categories":[{"name":"Go语言","slug":"Go语言","permalink":"https://hqd8080.github.io/categories/Go%E8%AF%AD%E8%A8%80/"}],"tags":[{"name":"golang","slug":"golang","permalink":"https://hqd8080.github.io/tags/golang/"}]},{"title":"Go语言切片类型、数组和切片的区别（slice）","slug":"golang/go-slice","date":"2022-03-30T12:10:10.000Z","updated":"2023-10-07T11:36:06.792Z","comments":true,"path":"2022/03/30/golang/go-slice/","link":"","permalink":"https://hqd8080.github.io/2022/03/30/golang/go-slice/","excerpt":"","text":"Go语言的切片类型、数组和切片的区别切片slice、也叫动态数组； 切片的数据结构: 1234567// 源码来自Go 1.19// 源码包：/usr/local/go/src/runtime/slice.gotype slice struct &#123; array unsafe.Pointer // 底层数组 len int // 切片的长度 cap int // 切片的容量&#125; 切片和数组的区别 ①、切片是指针类型，数组是值类型 ②、数组的长度是固定的，而切片长度可以自动扩容（切片是动态的数组） ③、数组只有长度一个属性，而切片比数组多了一个容量（cap)属性 ④、切片的底层也是数组实现的 切片的扩容规则 ①、如果原slice的容量小于1024，则新slice的容量将扩大为原来的2倍； ②、如果原slice的容量大于或等于1024，则新slice的容量将扩大为原来的1.25倍； 理解切片的长度和容量12345slice := []int&#123;10, 20, 30, 40, 50&#125;new := slice[1:3]fmt.Println(new) // [20, 30]fmt.Println(len(new)) // 2fmt.Println(cap(new)) // 4 切片的使用例子声明、初始化切片 12// 变量声明var s []int 123// 字面量声明s1 := []int&#123;&#125;s2 := []int&#123;1, 2, 3&#125; 123// 使用内置函数make创建s1 := make([]int, 12) // 指定长度s2 := make([]int, 10, 100) // 指定长度和空间 基于数组创建切片例子123456array := [5]int&#123;1,2,3,4,5&#125;s1 := array[0:2] // 1 2s2 := array[0:1] // 1fmt.Println(s1)fmt.Println(s2)","categories":[{"name":"Go语言","slug":"Go语言","permalink":"https://hqd8080.github.io/categories/Go%E8%AF%AD%E8%A8%80/"}],"tags":[{"name":"golang","slug":"golang","permalink":"https://hqd8080.github.io/tags/golang/"}]},{"title":"Go的数组类型（array）","slug":"golang/go-array","date":"2022-03-29T04:10:10.000Z","updated":"2023-10-07T11:32:53.328Z","comments":true,"path":"2022/03/29/golang/go-array/","link":"","permalink":"https://hqd8080.github.io/2022/03/29/golang/go-array/","excerpt":"","text":"Go语言的数组类型（array）","categories":[{"name":"Go语言","slug":"Go语言","permalink":"https://hqd8080.github.io/categories/Go%E8%AF%AD%E8%A8%80/"}],"tags":[{"name":"golang","slug":"golang","permalink":"https://hqd8080.github.io/tags/golang/"}]},{"title":"Go语言的字符串类型（string）","slug":"golang/go-string","date":"2022-03-29T02:10:10.000Z","updated":"2023-10-07T11:36:13.279Z","comments":true,"path":"2022/03/29/golang/go-string/","link":"","permalink":"https://hqd8080.github.io/2022/03/29/golang/go-string/","excerpt":"","text":"Go语言的字符串类型string是Go语言的基本数据类型 string的数据结构： 123456// 源码来自Go 1.19// 源码包：/usr/local/go/src/runtime/string.gotype stringStruct struct &#123; str unsafe.Pointer // 首地址 len int // 字符串长度&#125; 1.string可以为空（长度为0），但不会是nil; 2.string对象不可以修改； 字符串类型常用类型转换项目中经常需要在string和字节切片[]byte之间转换 123456// string to []bytefunc stringToByte() &#123; s:= &quot;Hello&quot; b:= []byte(s) fmt.Pringln(b) // [72 101 108 108 111]&#125; 123456// []byte to stringfunc byteToString() &#123; b:= []byte(&#x27;H&#x27;, &#x27;e&#x27;, &#x27;l&#x27;, &#x27;l&#x27;, &#x27;o&#x27;) s:= string(b) fmt.Pringln(s) // Hello&#125; 常用字符串函数（标准库函数）1func Contains(s, substr string) bool // 检查字符串s中是否包含子串substr 1func Split(s, sep string) []string // 将字符串s，根据分隔符sep拆分并生成子串的切片 1func Join(elems []string, sep string) string // 将字符串切片elems中的元素，使用分隔符sep拼接成单个字符串 1func HasPrefix(s, prefix string) bool // 检查字符串s中是否包含前缀prefix 1func HasSuffix(s, suffix string) bool // 检查字符串s中是否包含后缀缀suffix 1func ToUpper(s string) string // 将字符串s中的所有字符转换成大写 1func ToLower(s string) string // 将字符串s中的所有字符转换成小写 1func Trim(s string, cutset string) string // 清除字符串s首部和尾部cutset中的字符 1func TrimSpace(s string) string // 清除字符串s首部和尾部所有空白字符 1func Replace(s, old, new string, n int) string // 字符串替换，将字符串s的前n个子串中的old替换成子串new 1func ReplaceAll(s, old, new string) string // 将字符串s中的所有子串old替换成子串new 1func EqualFold(s, t string) bool // 忽略大小写、比较两个子串是否相等","categories":[{"name":"Go语言","slug":"Go语言","permalink":"https://hqd8080.github.io/categories/Go%E8%AF%AD%E8%A8%80/"}],"tags":[{"name":"golang","slug":"golang","permalink":"https://hqd8080.github.io/tags/golang/"}]},{"title":"Go语言设计统一接口响应格式","slug":"golang/go-response","date":"2022-03-28T02:10:10.000Z","updated":"2023-10-07T11:35:46.209Z","comments":true,"path":"2022/03/28/golang/go-response/","link":"","permalink":"https://hqd8080.github.io/2022/03/28/golang/go-response/","excerpt":"","text":"自己封装统一api接口响应格式，使用Gin框架的项目可直接使用1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071/** * @Author: hqd8080 * @Description: response,响应处理 * @Date: 2022-03-28 10:53 */package respimport ( &quot;go-vueadmin/pkg/errcode&quot; &quot;github.com/gin-gonic/gin&quot;)// Response 统一格式返回type Response struct &#123; Code int `json:&quot;code&quot;` Msg string `json:&quot;msg&quot;` Data interface&#123;&#125; `json:&quot;data&quot;`&#125;// PaginationParam 分页参数type PaginationParam struct &#123; List interface&#123;&#125; `json:&quot;list&quot;` Count int64 `json:&quot;count&quot;` PageIndex int `json:&quot;page_index&quot;` PageSize int `json:&quot;page_size&quot;`&#125;// PageResponse 分页统一格式type PageResponse struct &#123; Code int `json:&quot;code&quot;` Msg string `json:&quot;msg&quot;` Data PaginationParam `json:&quot;data&quot;`&#125;// Correct 正常返回数据,无分页func Correct(c *gin.Context, httpCode int, errCode int, data interface&#123;&#125;) &#123; response := &amp;Response&#123; Code: errCode, Msg: errcode.GetErrorMsg(errCode), Data: data, &#125; c.JSON(httpCode, response)&#125;// CorrectOK 正常返回分页数据func CorrectOK(c *gin.Context, httpCode int, errCode int, data interface&#123;&#125;, count int64, pageIndex int, pageSize int) &#123; pagination := PaginationParam&#123; List: data, Count: count, PageIndex: pageIndex, PageSize: pageSize, &#125; response := &amp;PageResponse&#123; Code: errCode, Msg: errcode.GetErrorMsg(errCode), Data: pagination, &#125; c.JSON(httpCode, response)&#125;// ErrorCode 可以定制返回错误码，错误信息func ErrorCode(c *gin.Context, httpCode int, errCode int) &#123; response := &amp;Response&#123; Code: errCode, Msg: errcode.GetErrorMsg(errCode), Data: nil, &#125; c.JSON(httpCode, response)&#125; 公共错误码标准化定义/pkg/errcode/errcode.go/pkg/errcode/errmsg.go 12345678910111213141516171819202122/** * @Author: hqd8080 * @Description: errcode,公共错误码标准化 * @Date: 2022-03-28 09:43 */package errcodeconst ( ErrCodeSuccess = 2000 // 公共错误码、成功 ErrCodeError = 5000 // 公共错误码、服务端错误 ErrCodeInvalidParam = 4000 // 公共错误码、请求参数错误 // 轮播图模块 ErrBannerList = 10000 ErrBannerExist = 10001 ErrBannerNotFound = 10002 ErrBannerCreate = 10003 ErrBannerUpdate = 10004 ErrBannerUpdateStatus = 10005 ErrBannerDelete = 10006) 123456789101112131415161718192021222324252627282930/** * @Author: hqd8080 * @Description: errmsg,公共错误码标准化 * @Date: 2022-03-28 10:07 */package errcodevar ErrorMsg = map[int]string&#123; ErrCodeSuccess: &quot;ok&quot;, ErrCodeError: &quot;fail&quot;, ErrCodeInvalidParam: &quot;请求参数错误！&quot;, // 轮播图模块 ErrBannerList: &quot;获取轮播图列表失败！&quot;, ErrBannerExist: &quot;轮播图已经存在！&quot;, ErrBannerNotFound: &quot;轮播图不存在！&quot;, ErrBannerCreate: &quot;添加轮播图失败！&quot;, ErrBannerUpdate: &quot;更新轮播图失败！&quot;, ErrBannerUpdateStatus: &quot;修改轮播图状态失败！&quot;, ErrBannerDelete: &quot;删除轮播图失败！&quot;,&#125;func GetErrorMsg(code int) string &#123; msg, ok := ErrorMsg[code] if ok &#123; return msg &#125; return ErrorMsg[ErrCodeError]&#125; 使用123456789101112131415161718192021222324252627package adminimport ( &quot;go-vueadmin/models&quot; &quot;go-vueadmin/pkg/errcode&quot; &quot;go-vueadmin/pkg/resp&quot; &quot;go-vueadmin/service&quot; &quot;go-vueadmin/util&quot; &quot;net/http&quot; &quot;github.com/gin-gonic/gin&quot;)type BannerImageController struct &#123; BaseController&#125;func (b BannerImageController) GetBannerImageList(c *gin.Context) &#123; bannerService := service.NewBannerImageService() pageIndex := bannerService.GetPageIndex(c) pageSize := bannerService.GetPageSize(c) list, count, err := bannerService.BannerList(c, pageIndex, pageSize) if err != nil &#123; resp.ErrorCode(c, http.StatusOK, errcode.ErrBannerList) return &#125; resp.CorrectOK(c, http.StatusOK, errcode.ErrCodeSuccess, list, count, pageIndex, pageSize)&#125;","categories":[{"name":"Go语言","slug":"Go语言","permalink":"https://hqd8080.github.io/categories/Go%E8%AF%AD%E8%A8%80/"}],"tags":[{"name":"golang","slug":"golang","permalink":"https://hqd8080.github.io/tags/golang/"}]},{"title":"Docker查看容器指定字段列信息","slug":"docker/docker-ps","date":"2022-03-24T08:59:56.000Z","updated":"2023-08-29T09:45:58.410Z","comments":true,"path":"2022/03/24/docker/docker-ps/","link":"","permalink":"https://hqd8080.github.io/2022/03/24/docker/docker-ps/","excerpt":"","text":"Docker查看容器指定字段列信息12#查看正常启动的容器信息列表docker ps --format &quot;table &#123;&#123;.ID&#125;&#125;\\t&#123;&#123;.Image&#125;&#125;\\t&#123;&#123;.Names&#125;&#125;\\t&#123;&#123;.Status&#125;&#125;\\t&#123;&#123;.Ports&#125;&#125;&quot; 12345CONTAINER ID IMAGE NAMES STATUS PORTSd7c3b0885560 nginx:1.21.5 gateway Up 35 minutes 80/tcp, 0.0.0.0:8080-&gt;8888/tcp405689156d01 redis:6.2.5 myredis Up 35 minutes 0.0.0.0:6378-&gt;6379/tcp916d9c76f1c0 mysql/mysql-server:8.0.28 mysql Up 35 minutes (healthy) 33060-33061/tcp, 0.0.0.0:3307-&gt;3306/tcp2e42c7337985 jaegertracing/all-in-one:latest jaeger Restarting (1) 59 seconds ago 12#查看所有容器 -adocker ps -a --format &quot;table &#123;&#123;.ID&#125;&#125;\\t&#123;&#123;.Image&#125;&#125;\\t&#123;&#123;.Names&#125;&#125;\\t&#123;&#123;.Status&#125;&#125;\\t&#123;&#123;.Ports&#125;&#125;&quot; 12345678910111213141516CONTAINER ID IMAGE NAMES STATUS PORTSfec465a05eeb confluentinc/cp-kafka:7.3.2 kafka3 Exited (143) 6 days ago f96a02d22ee8 confluentinc/cp-kafka:7.3.2 kafka2 Exited (1) 6 days ago d815d0f9b838 confluentinc/cp-zookeeper:7.3.2 zk2 Exited (143) 6 days ago adc7323ff0b9 confluentinc/cp-zookeeper:7.3.2 zk3 Exited (143) 6 days ago 1ef587c5a896 confluentinc/cp-zookeeper:7.3.2 zk1 Exited (143) 6 days ago c37794d596c4 kibana:7.4.2 kibana Exited (255) 6 weeks ago 0.0.0.0:5601-&gt;5601/tcpecd16a4e857f elasticsearch:7.4.2 elasticsearch Exited (255) 6 weeks ago 0.0.0.0:9200-&gt;9200/tcp, 0.0.0.0:9300-&gt;9300/tcpa9bbb3890df0 wurstmeister/zookeeper zookeeper Exited (137) 27 minutes ago cf9c73e10246 wurstmeister/kafka deployments-kafka-1 Exited (1) 4 months ago d7c3b0885560 nginx:1.21.5 gateway Up 37 minutes 80/tcp, 0.0.0.0:8080-&gt;8888/tcp405689156d01 redis:6.2.5 myredis Up 37 minutes 0.0.0.0:6378-&gt;6379/tcp916d9c76f1c0 mysql/mysql-server:8.0.28 mysql Up 37 minutes (healthy) 33060-33061/tcp, 0.0.0.0:3307-&gt;3306/tcp4a605a079fc2 gcr.io/k8s-minikube/kicbase:v0.0.36 minikube Exited (255) 3 months ago 127.0.0.1:55004-&gt;22/tcp, 127.0.0.1:55003-&gt;2376/tcp, 127.0.0.1:55002-&gt;5000/tcp, 127.0.0.1:55001-&gt;8443/tcp, 127.0.0.1:55000-&gt;32443/tcpf4f791a3b077 cap1573/consul objective_banach Exited (255) 7 months ago 8300-8302/tcp, 8301-8302/udp, 8600/tcp, 8600/udp, 0.0.0.0:8500-&gt;8500/tcp2e42c7337985 jaegertracing/all-in-one:latest jaeger Restarting (1) 55 seconds ago","categories":[{"name":"Docker","slug":"Docker","permalink":"https://hqd8080.github.io/categories/Docker/"}],"tags":[{"name":"docker","slug":"docker","permalink":"https://hqd8080.github.io/tags/docker/"}]},{"title":"Go语言GORM 2.0的使用教程","slug":"golang/go-gorm","date":"2022-03-21T02:54:40.000Z","updated":"2023-10-07T11:34:17.042Z","comments":true,"path":"2022/03/21/golang/go-gorm/","link":"","permalink":"https://hqd8080.github.io/2022/03/21/golang/go-gorm/","excerpt":"","text":"GORM 2.0使用教程GORM1.X用过有一段时间了，感觉Go生态MySQL的ORM还是不太成熟的，有一些特性使用起来还是觉得不太顺手，GORM算是比较好用的了，目前使用的人也比较多 这是main.go项目初始化1234567891011121314func init() &#123; if err := initialize.InitConfig(); err != nil &#123; panic(err) &#125; if err := initialize.InitLogger(); err != nil &#123; panic(err) &#125; if err := initialize.InitDB(); err != nil &#123; panic(err) &#125; if err := initialize.InitRedis(); err != nil &#123; panic(err) &#125;&#125; 这是GORM初始化的代码，注意GORM 2.0，Tag是2.0,实际上目前的版本还是1.23.x的版本12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273/** * @Author: hqd8080 * @Description: mysql * @Date: 2022-03-21 09:30 */package initializeimport ( &quot;fmt&quot; &quot;log&quot; &quot;os&quot; &quot;time&quot; &quot;gorm.io/driver/mysql&quot; &quot;gorm.io/gorm&quot; &quot;gorm.io/gorm/logger&quot; &quot;gorm.io/gorm/schema&quot;)var DB *gorm.DBfunc InitDB() error &#123; var err error dsn := fmt.Sprintf(&quot;%s:%s@tcp(%s:%d)/%s?charset=utf8mb4&amp;parseTime=True&amp;loc=Local&quot;, DatabaseConfig.Username, DatabaseConfig.Password, DatabaseConfig.Host, DatabaseConfig.Port, DatabaseConfig.Name, ) config := mysql.New(mysql.Config&#123; DriverName: &quot;mysql&quot;, // mysql DSN: dsn, // dsn SkipInitializeWithVersion: false, // 根据版本自动配置 DefaultStringSize: 256, // 设置string类型字段的默认长度 &#125;) logger := logger.New(log.New(os.Stdout, &quot;\\r\\n&quot;, log.LstdFlags), logger.Config&#123; SlowThreshold: time.Second * 1, // 慢SQL阈值 Colorful: true, // 开启彩色打印 IgnoreRecordNotFoundError: false, // 忽略未找到记录错误 LogLevel: logger.Info, // 设置日志级别 &#125;, ) opts := &amp;gorm.Config&#123; DisableForeignKeyConstraintWhenMigrating: true, // 迁移时禁用外键约束 PrepareStmt: true, Logger: logger, // 日志配置 NamingStrategy: schema.NamingStrategy&#123; TablePrefix: &quot;t_&quot;, // 设置表前缀 SingularTable: true, // 使用单数表名 NameReplacer: nil, NoLowerCase: false, &#125;, &#125; db, err := gorm.Open(config, opts) if err != nil &#123; return fmt.Errorf(&quot;connection to db err:%v&quot;, err) &#125; sqlDB, err := db.DB() if err != nil &#123; return fmt.Errorf(&quot;get db conn err:%v&quot;, err) &#125; sqlDB.SetMaxOpenConns(int(DatabaseConfig.MaxOpenConn)) // 打开数据库连接的最大数量 sqlDB.SetConnMaxIdleTime(time.Hour) // sqlDB.SetMaxIdleConns(int(DatabaseConfig.MaxIdleConn)) // 空闲连接池中连接的最大数量 sqlDB.SetConnMaxLifetime(time.Hour) // 连接可复用的最大时间 DB = db log.Println(&quot;init db connection success&quot;) return err&#125;","categories":[{"name":"Go语言","slug":"Go语言","permalink":"https://hqd8080.github.io/categories/Go%E8%AF%AD%E8%A8%80/"}],"tags":[{"name":"golang","slug":"golang","permalink":"https://hqd8080.github.io/tags/golang/"},{"name":"gorm","slug":"gorm","permalink":"https://hqd8080.github.io/tags/gorm/"}]},{"title":"Docker安装Redis并配置密码详细教程","slug":"docker/docker-install-redis","date":"2022-02-17T03:37:28.000Z","updated":"2022-03-31T03:23:07.000Z","comments":true,"path":"2022/02/17/docker/docker-install-redis/","link":"","permalink":"https://hqd8080.github.io/2022/02/17/docker/docker-install-redis/","excerpt":"","text":"Docker安装Redis并配置密码详细教程 执行以下命令，查找docker官方提供的最新的redis镜像：1docker search redis --filter &quot;is-official=true&quot; 将官方Redis镜像拉取到本地1docker pull redis 执行以下命令，根据Redis镜像生成本地容器1docker run --name myredis -p 6379:6379 -d --restart=always redis:latest redis-server --appendonly yes --requirepass &quot;123456&quot; -d 设置docker容器在后台运行-p 6379:6379 设置端口映射，前者为本地端口，后者为docker容器端口-v d:/redisdata:/data 将容器中/data目录映射到本地d:\\redisdata目录,作为redis数据持久化的存储目录redis-server –appendonly yes 启用aof持久化方式 执行以下命令，根据Redis镜像生成本地容器,添加目录映射1docker run --name myredis redis:latest -d -p 6379:6379 -v d:\\redisdata:/data redis-server --appendonly yes --requirepass &quot;123456&quot; 查看镜像1docker ps","categories":[{"name":"Docker","slug":"Docker","permalink":"https://hqd8080.github.io/categories/Docker/"}],"tags":[{"name":"docker","slug":"docker","permalink":"https://hqd8080.github.io/tags/docker/"},{"name":"redis","slug":"redis","permalink":"https://hqd8080.github.io/tags/redis/"}]},{"title":"Nginx配置HTTPS详细教程","slug":"nginx/nginx-ssl","date":"2022-02-17T02:37:28.000Z","updated":"2023-08-17T11:27:17.143Z","comments":true,"path":"2022/02/17/nginx/nginx-ssl/","link":"","permalink":"https://hqd8080.github.io/2022/02/17/nginx/nginx-ssl/","excerpt":"","text":"Nginx配置HTTPS详细教程 前置条件：在配置https之前请确保下面的步骤已经完成 服务器已经安装nginx并且通过http可以正常访问 拥有ssl证书，没有的可以去阿里购买或者免费申请一年 ，如果以上条件都满足了，接下来开始配置https 第一步：Nginx的ssl模块安装在配置ssl证书之前，要确保你的nginx已经安装了ssl模块，一般情况下自己安装的nginx都是不会存在ssl模块的这里先检查下自己是否存在ssl模块：进入到你的nginx安装目录下面，我的目录是在（/usr/local/nginx），如果你的nginx安装步骤和上面的文章一致的话，那你的目录和我应该是一致的进入到目录的sbin目录下，输入: 12# 注意这里是大写的V，小写的只显示版本号nginx -V 如果出现 (configure arguments: --with-http_ssl_module), 则已安装（下面的步骤可以跳过，直接进行ssl配置步骤) 一般情况下都是不存在ssl模块的，接下来进入到你的解压缩后的nginx目录，注意这里不是nginx安装目录，是解压缩后的目录，我的是在（/usr/local/src/nginx），进入目录后，输入： 1./configure --prefix=/usr/local/nginx --with-http_stub_status_module --with-http_ssl_module 接下来执行: 12make# 切记不要执行make install，否则会重新安装nginx 上述操作执行完成以后，你的目录下会出现objs文件夹，文件夹内存在nginx文件 接下来使用新的nginx文件替换掉之前安装目录sbin下的nginx，注意这里的替换的时候可以先将之前的文件备份下，停掉nginx服务 1234nginx -s stop # 停止nginx服务# 替换之前的nginxcp /usr/local/src/nginx/objs/nginx /usr/local/nginx/sbin 成功之后，进入到nginx安装目录下，查看ssl信息是否编译成功 123# 注意这里是大写的V，小写的只显示版本号nginx -V # 可以看到这里出现了configure arguments: --with-http_ssl_module证明已经安装成功 提示：这里替换后在执行 -V命令如果提示权限不足，先给这个nginx文件提升下权限 第二步：配置ssl证书解压缩下载好的证书（证书一般是pem文件和key文件，这里名字可以随便改） 将下载好的证书上传到服务器，我将证书放在了/data/web/目录下的ssl文件夹 12# 创建ssl文件夹mkdir -p /data/web/ssl 第三步：进行nginx.conf配置进入nginx.conf文件下 123cd /usr/locla/nginx/conf# 修改nginx.conf文件vim nginx.conf 打开之后文件内容如图: 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117user www;worker_processes 1;#error_log logs/error.log;#error_log logs/error.log notice;#error_log logs/error.log info;#pid logs/nginx.pid;events &#123; worker_connections 1024;&#125;http &#123; include mime.types; default_type application/octet-stream; #log_format main &#x27;$remote_addr - $remote_user [$time_local] &quot;$request&quot; &#x27; # &#x27;$status $body_bytes_sent &quot;$http_referer&quot; &#x27; # &#x27;&quot;$http_user_agent&quot; &quot;$http_x_forwarded_for&quot;&#x27;; #access_log logs/access.log main; sendfile on; #tcp_nopush on; #keepalive_timeout 0; keepalive_timeout 65; #gzip on; server &#123; listen 80; server_name localhost; #charset koi8-r; #access_log logs/host.access.log main; location / &#123; root html; index index.html index.htm; &#125; #error_page 404 /404.html; # redirect server error pages to the static page /50x.html # error_page 500 502 503 504 /50x.html; location = /50x.html &#123; root html; &#125; # proxy the PHP scripts to Apache listening on 127.0.0.1:80 # #location ~ \\.php$ &#123; # proxy_pass http://127.0.0.1; #&#125; # pass the PHP scripts to FastCGI server listening on 127.0.0.1:9000 # #location ~ \\.php$ &#123; # root html; # fastcgi_pass 127.0.0.1:9000; # fastcgi_index index.php; # fastcgi_param SCRIPT_FILENAME /scripts$fastcgi_script_name; # include fastcgi_params; #&#125; # deny access to .htaccess files, if Apache&#x27;s document root # concurs with nginx&#x27;s one # #location ~ /\\.ht &#123; # deny all; #&#125; &#125; # another virtual host using mix of IP-, name-, and port-based configuration # #server &#123; # listen 8000; # listen somename:8080; # server_name somename alias another.alias; # location / &#123; # root html; # index index.html index.htm; # &#125; #&#125; # HTTPS server # #server &#123; # listen 443 ssl; # server_name localhost; # ssl_certificate cert.pem; # ssl_certificate_key cert.key; # ssl_session_cache shared:SSL:1m; # ssl_session_timeout 5m; # ssl_ciphers HIGH:!aNULL:!MD5; # ssl_prefer_server_ciphers on; # location / &#123; # root html; # index index.html index.htm; # &#125; #&#125; include servers/*;&#125; 可以将没用的东西都删除掉，删除的时候注意，括号要对应起来 进入servers/website.conf然后进行配置: 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647server &#123; listen 443 ssl; server_name hqd8080.me; ssl on; ssl_certificate /data/web/ssl/hqd8080.me.pem; ssl_certificate_key /data/web/ssl/hqd8080.me.key; ssl_session_cache shared:SSL:1m; ssl_session_timeout 5m; ssl_ciphers HIGH:!aNULL:!MD5; ssl_prefer_server_ciphers on; root /data/web/public; access_log /data/web/logs/hqd8080.me.access.log; error_log /data/web/logs/hqd8080.me.error.log; client_max_body_size 10m; location / &#123; index index.html index.htm; &#125; location ~ ^/(uploads|assets)/.*\\.(php|php5|jsp)$ &#123; deny all; &#125; # 配置后台服务api接口服务 代理到8080端口 location ~ ^/dev/ &#123; proxy_set_header Host $http_host; proxy_set_header X-Real-IP $remote_addr; proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for; proxy_set_header X-Forwarded-Proto $scheme; rewrite ^/dev/(.*)$ /$1 break; proxy_pass http://127.0.0.1:8080; &#125; error_page 404 /404.html; error_page 403 /403.html;&#125;server &#123; listen 80; server_name hqd8080.me; #将请求转成https rewrite ^(.*)$ https://$host$1 permanent;&#125; 注意：这里需要在安全组中开放443端口 第四步：重启nginxok，如果上述步骤都完成了，没有问题，接下来只需要重启nginx服务即可 进入sbin目录下，输入: 123./nginx -s reload./nginx -s stop./nginx 完成","categories":[{"name":"Nginx","slug":"Nginx","permalink":"https://hqd8080.github.io/categories/Nginx/"}],"tags":[{"name":"Nginx","slug":"Nginx","permalink":"https://hqd8080.github.io/tags/Nginx/"}]},{"title":"Linux系统SSH隧道与端口转发及内网穿透","slug":"linux/linux-ssh","date":"2021-11-30T07:30:28.000Z","updated":"2022-04-02T02:57:24.000Z","comments":true,"path":"2021/11/30/linux/linux-ssh/","link":"","permalink":"https://hqd8080.github.io/2021/11/30/linux/linux-ssh/","excerpt":"","text":"Linux系统SSH隧道与端口转发及内网穿透#/usr/bin/sshpass -p dbuser /usr/bin/ssh -N -f -L 3307:10.141.96.240:3306 root@121.41.118.64 -o ExitOnForwardFailure=yes 说明：需要安装sshpass 3307:10.141.96.240:3306 // 从10.141.96.240服务器上的3306数据库转发到3307端口 root@121.41.118.64 // 我本地能直接访问的服务器用户名和服务器ip地址 dbuser //数据库用户名 然后就能在本地愉快的玩远程不能直接链接的数据库了 mysql -h127.0.0.1 -udbuser -pdbpass -P3307 举个例子比如，我们有1台web服务器（内网ip: 192.168.1.101,外网ip:123.123.123.123），1台db服务器（内网ip: 192.168.1.102, 无外网ip)这时，我想从我本地连接到数据库 ssh -N -f -L 3307:192.168.1.102:3306 123.123.123.123mysql -uuser -ppasswd -h127.0.0.1 -P3307 就可以连接到数据库了 在需要保持连接的情况下，多次重复建立隧道会出现警告，但是不会退出当前进程，结果就会出现多个ssh进程，加上下面这个参数后，会在创建失败后将当前进程自动退出，适合在crontab中让ssh保持与服务端的连接 -o ExitOnForwardFailure=yes","categories":[{"name":"Linux","slug":"Linux","permalink":"https://hqd8080.github.io/categories/Linux/"}],"tags":[{"name":"linux","slug":"linux","permalink":"https://hqd8080.github.io/tags/linux/"}]},{"title":"gRPC使用实例（二）","slug":"grpc/grpc-demo","date":"2021-11-29T07:30:30.000Z","updated":"2024-03-17T14:20:12.081Z","comments":true,"path":"2021/11/29/grpc/grpc-demo/","link":"","permalink":"https://hqd8080.github.io/2021/11/29/grpc/grpc-demo/","excerpt":"","text":"首先使用gRPC先定义protobuf协议文件hello.proto 12345678910111213141516syntax = &quot;proto3&quot;;package services;message HelloRequest &#123; string name = 1;&#125;message HelloReply &#123; string message = 2;&#125;service HelloService &#123; rpc SayHello(HelloRequest) returns (HelloReply); rpc Streaming(stream HelloRequest) returns (stream HelloReply);&#125; user.proto 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130syntax = &quot;proto3&quot;;package services;// 测试官方类型import &quot;google/protobuf/timestamp.proto&quot;;import &quot;google/protobuf/empty.proto&quot;;import &quot;google/protobuf/any.proto&quot;;//import &quot;common.proto&quot;;// 测试枚举类型enum LoginStatus &#123; success = 0; // 登录成功 failed = 1; // 登录失败 error = 2; // 错误&#125;// 用户登录请求message UserLoginRequest &#123; int64 user_id = 1; // 用户编号 string user_name = 2; // 用户名 string user_nickname = 3; // 用户昵称 string user_country = 4; // 用户国籍 int32 user_gender = 5; // 用户性别 double user_credits = 6; // 用户积分 bool is_admin = 7; // 是否是管理员 bytes auth_code = 8; // 授权码 float user_balance = 9; // 用户余额 // 用户爱好 enum Hobby &#123; music = 0; // 音乐 basketball = 1; // 篮球 tour = 2; // 旅游 &#125; Hobby user_hobby = 10; // 用户爱好 repeated int32 lucky_numbers = 11; // 幸运数字 map&lt;string, string&gt; user_email = 12; // 用户email map&lt;string, int32&gt; user_weight = 13; // 用户体重 map&lt;string, PhoneNumber&gt; user_num = 14; // 测试map LoginStatus login_status = 15; // 登录状态 // 手机类型枚举 enum PhoneType &#123; mobile = 0; // 移动 home = 1; // 家庭 work = 2; // 办公室 &#125; // 手机号码类型 message PhoneNumber &#123; string phone_number = 1; // 手机号码 PhoneType phone_type = 2; // 手机号码类型 &#125; repeated PhoneNumber phones = 16; // 手机号码 google.protobuf.Timestamp last_update_date = 17; // 最后更新日期&#125;// 用户登录响应message UserLoginResponse &#123; int64 user_id = 1; // 用户编号 string user_name = 2; // 用户名 string user_pwd = 3; // 用户密码 int32 user_gender = 5; // 用户性别 double user_credits = 6; // 用户积分 bool is_admin = 7; // 是否是管理员 bytes auth_code = 8; // 授权码 float user_balance = 9; // 用户余额 // 用户爱好 enum Hobby &#123; music = 0; // 音乐 basketball = 1; // 篮球 tour = 2; // 旅游 &#125; Hobby user_hobby = 10; // 用户爱好 // 手机类型 enum PhoneType &#123; mobile = 0; // 移动 home = 1; // 家庭 work = 2; // 办公室 &#125; // 手机号码类型 message PhoneNumber &#123; string phone_number = 1; // 手机号码 PhoneType phone_type = 2; // 手机号码类型 &#125; repeated PhoneNumber phones = 11; // 手机号码 google.protobuf.Timestamp last_update_date = 12; // 最后更新日期 map&lt;string, PhoneNumber&gt; user_num = 13; // 测试map repeated int32 lucky_numbers = 14; // 幸运数字 map&lt;string, string&gt; user_email = 15; // 用户email map&lt;string, int32&gt; user_weight = 16; // 用户体重 LoginStatus login_status = 17; // 登录状态&#125;message TestRequest &#123; string name = 1; repeated Extension extensions = 2;&#125;message TestResponse &#123; string msg = 1; string name = 2; repeated Extension extensions = 3;&#125;message Extension &#123; uint64 id = 1; google.protobuf.Any data = 2; //测试官方any类型&#125;// user serviceservice UserService &#123; rpc Login(UserLoginRequest) returns (UserLoginResponse); rpc LoginStreaming(stream UserLoginRequest) returns (stream UserLoginResponse);&#125;// test serviceservice TestService &#123; rpc Test(TestRequest) returns (TestResponse); rpc Ping (google.protobuf.Empty) returns (google.protobuf.Empty);&#125; common.proto 123456789syntax = &quot;proto3&quot;;package services;enum LoginStatus &#123; success = 0; // 登录成功 failed = 1; // 登录失败 error = 3; // 错误&#125; 根据protobuf文件生成pb文件generate.sh 12#!/bin/bashprotoc -I. --go_out=plugins=grpc:../services/pb *.proto 实现接口协议services/hello.go 12345678910111213141516171819202122232425262728293031323334package servicesimport ( &quot;context&quot; pb &quot;tests/grpc/services/pb&quot; &quot;io&quot;)type HelloService struct&#123;&#125;func (h *HelloService) SayHello(ctx context.Context, request *pb.HelloRequest) (*pb.HelloReply, error) &#123; reply := &amp;pb.HelloReply&#123;Message: &quot;hello &quot; + request.GetName()&#125; return reply, nil&#125;func (h *HelloService) Streaming(stream pb.HelloService_StreamingServer) error &#123; for &#123; req, err := stream.Recv() if err != nil &#123; if err == io.EOF &#123; return nil &#125; return err &#125; reply := &amp;pb.HelloReply&#123;Message: &quot;hello &quot; + req.GetName()&#125; err = stream.Send(reply) if err != nil &#123; return err &#125; return nil &#125;&#125; services/user.go 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111package servicesimport ( &quot;context&quot; pb &quot;tests/grpc/services/pb&quot; &quot;io&quot;)type UserService struct&#123;&#125;func (u *UserService) Login(ctx context.Context, request *pb.UserLoginRequest) (*pb.UserLoginResponse, error) &#123; var phones = []*pb.UserLoginResponse_PhoneNumber&#123; &amp;pb.UserLoginResponse_PhoneNumber&#123; PhoneNumber: &quot;返回手机号码:&quot; + request.GetPhones()[0].PhoneNumber, PhoneType: pb.UserLoginResponse_PhoneType(request.GetPhones()[0].PhoneType), &#125;, &#125; var userNum = map[string]*pb.UserLoginResponse_PhoneNumber&#123; &quot;phone_001&quot;: &amp;pb.UserLoginResponse_PhoneNumber&#123; PhoneNumber: &quot;001&quot;, PhoneType: pb.UserLoginResponse_mobile, &#125;, &quot;phone_002&quot;: &amp;pb.UserLoginResponse_PhoneNumber&#123; PhoneNumber: &quot;002&quot;, PhoneType: pb.UserLoginResponse_home, &#125;, &quot;phone_003&quot;: &amp;pb.UserLoginResponse_PhoneNumber&#123; PhoneNumber: &quot;003&quot;, PhoneType: pb.UserLoginResponse_work, &#125;, &#125; reply := &amp;pb.UserLoginResponse&#123; UserId: request.GetUserId(), UserName: &quot;获取用户名称：&quot; + request.GetUserName(), UserPwd: &quot;用户密码12345678900&quot;, UserGender: request.GetUserGender(), UserCredits: request.GetUserCredits(), IsAdmin: request.GetIsAdmin(), AuthCode: request.GetAuthCode(), UserBalance: request.GetUserBalance(), UserHobby: pb.UserLoginResponse_Hobby(request.GetUserHobby()), Phones: phones, LastUpdateDate: request.GetLastUpdateDate(), UserNum: userNum, LuckyNumbers: request.GetLuckyNumbers(), UserEmail: request.GetUserEmail(), UserWeight: request.GetUserWeight(), LoginStatus: request.GetLoginStatus(), &#125; return reply, nil&#125;// 双向流func (u *UserService) LoginStreaming(stream pb.UserService_LoginStreamingServer) error &#123; for &#123; req, err := stream.Recv() if err != nil &#123; if err == io.EOF &#123; return nil &#125; return err &#125; var phones = []*pb.UserLoginResponse_PhoneNumber&#123; &amp;pb.UserLoginResponse_PhoneNumber&#123; PhoneNumber: &quot;返回手机号码:&quot; + req.GetPhones()[0].PhoneNumber, PhoneType: pb.UserLoginResponse_PhoneType(req.GetPhones()[0].PhoneType), &#125;, &#125; var userNum = map[string]*pb.UserLoginResponse_PhoneNumber&#123; &quot;phone001&quot;: &amp;pb.UserLoginResponse_PhoneNumber&#123; PhoneNumber: &quot;1111111111&quot;, PhoneType: pb.UserLoginResponse_mobile, &#125;, &quot;phone002&quot;: &amp;pb.UserLoginResponse_PhoneNumber&#123; PhoneNumber: &quot;2222222222&quot;, PhoneType: pb.UserLoginResponse_home, &#125;, &quot;phone003&quot;: &amp;pb.UserLoginResponse_PhoneNumber&#123; PhoneNumber: &quot;3333333333&quot;, PhoneType: pb.UserLoginResponse_work, &#125;, &#125; reply := &amp;pb.UserLoginResponse&#123; UserId: req.GetUserId(), UserName: &quot;返回用户名称：&quot; + req.GetUserName(), UserPwd: &quot;用户密码111111111111&quot;, UserGender: req.GetUserGender(), UserCredits: req.GetUserCredits(), IsAdmin: req.GetIsAdmin(), AuthCode: req.GetAuthCode(), UserBalance: req.GetUserBalance(), UserHobby: pb.UserLoginResponse_Hobby(req.GetUserHobby()), Phones: phones, LastUpdateDate: req.GetLastUpdateDate(), UserNum: userNum, LuckyNumbers: req.GetLuckyNumbers(), UserEmail: req.GetUserEmail(), UserWeight: req.GetUserWeight(), LoginStatus: req.GetLoginStatus(), &#125; err = stream.Send(reply) if err != nil &#123; return err &#125; return nil &#125;&#125; services/test.go 1234567891011121314151617181920212223242526272829303132333435package servicesimport ( &quot;context&quot; pb &quot;tests/grpc/services/pb&quot; &quot;strconv&quot; &quot;github.com/golang/protobuf/ptypes/empty&quot; anypb &quot;google.golang.org/protobuf/types/known/anypb&quot;)type TestService struct&#123;&#125;func (t *TestService) Test(ctx context.Context, req *pb.TestRequest) (*pb.TestResponse, error) &#123; var extension = []*pb.Extension&#123; &amp;pb.Extension&#123; Id: req.GetExtensions()[0].Id, Data: req.GetExtensions()[0].GetData(), &#125;, &amp;pb.Extension&#123; Id: 100, Data: &amp;anypb.Any&#123;TypeUrl: &quot;test any type `type_url`&quot;&#125;, &#125;, &#125; reply := &amp;pb.TestResponse&#123; Msg: &quot;ok 200&quot;, Name: req.GetName() + &quot;:&quot; + strconv.FormatInt(int64(req.Extensions[0].Id), 10), Extensions: extension, &#125; return reply, nil&#125;func (t *TestService) Ping(ctx context.Context, req *empty.Empty) (*empty.Empty, error) &#123; return &amp;empty.Empty&#123;&#125;, nil&#125; 实现gRPC客户端client/client.go 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236package mainimport ( &quot;context&quot; &quot;crypto/tls&quot; &quot;crypto/x509&quot; &quot;flag&quot; pb &quot;tests/grpc/services/pb&quot; &quot;io&quot; &quot;io/ioutil&quot; &quot;log&quot; &quot;time&quot; &quot;github.com/golang/protobuf/ptypes/empty&quot; &quot;github.com/golang/protobuf/ptypes/timestamp&quot; &quot;google.golang.org/grpc&quot; &quot;google.golang.org/grpc/credentials&quot; &quot;google.golang.org/protobuf/types/known/anypb&quot;)var ( address = flag.String(&quot;addr&quot;, &quot;localhost:8888&quot;, &quot;addr&quot;) name = flag.String(&quot;name&quot;, &quot;world&quot;, &quot;name&quot;))func main() &#123; flag.Parse() cert, err := tls.LoadX509KeyPair(&quot;cert/client.pem&quot;, &quot;cert/client.key&quot;) if err != nil &#123; log.Fatalf(&quot;load cert files failed,err:%v&quot;, err) &#125; certPool := x509.NewCertPool() ca, err := ioutil.ReadFile(&quot;cert/ca.pem&quot;) if err != nil &#123; log.Fatalf(&quot;read ca file failed,err:%v&quot;, err) &#125; if ok := certPool.AppendCertsFromPEM(ca); !ok &#123; log.Fatal(&quot;failed to append ca certs&quot;) &#125; creds := credentials.NewTLS(&amp;tls.Config&#123; Certificates: []tls.Certificate&#123;cert&#125;, // 客户端证书 ServerName: &quot;localhost&quot;, RootCAs: certPool, &#125;) //conn, err := grpc.Dial(*address, grpc.WithInsecure()) conn, err := grpc.Dial(*address, grpc.WithTransportCredentials(creds)) if err != nil &#123; log.Fatalf(&quot;failed to connect server,err:%v&quot;, err) &#125; defer conn.Close() // hello client helloClient := pb.NewHelloServiceClient(conn) sayHello(helloClient) // user client userClient := pb.NewUserServiceClient(conn) login(userClient) loginStreaming(userClient) // test client testClient := pb.NewTestServiceClient(conn) test(testClient) ping(testClient)&#125;func sayHello(client pb.HelloServiceClient) &#123; reply, err := client.SayHello(context.Background(), &amp;pb.HelloRequest&#123;Name: *name&#125;) if err != nil &#123; log.Fatal(err) &#125; log.Println(reply.GetMessage()) stream, err := client.Streaming(context.Background()) if err != nil &#123; log.Fatalf(&quot;failed to call:%v&quot;, err) &#125; go func() &#123; for &#123; err := stream.Send(&amp;pb.HelloRequest&#123;Name: *name&#125;) if err != nil &#123; log.Fatalf(&quot;failed to send,err:%v&quot;, err) break &#125; time.Sleep(time.Second) &#125; &#125;() for &#123; reply, err := stream.Recv() if err != nil &#123; if err == io.EOF &#123; break &#125; log.Fatalf(&quot;failed to recv,err:%v&quot;, err) break &#125; log.Println(reply.GetMessage()) &#125;&#125;func login(client pb.UserServiceClient) &#123; var userEmail = map[string]string&#123;&quot;email&quot;: &quot;test@qq.com&quot;&#125; var userWeight = map[string]int32&#123;&quot;weight&quot;: 170&#125; var userNum = map[string]*pb.UserLoginRequest_PhoneNumber&#123; &quot;001&quot;: &#123;PhoneNumber: &quot;001&quot;, PhoneType: pb.UserLoginRequest_mobile&#125;, &quot;002&quot;: &#123;PhoneNumber: &quot;002&quot;, PhoneType: pb.UserLoginRequest_home&#125;, &quot;003&quot;: &#123;PhoneNumber: &quot;003&quot;, PhoneType: pb.UserLoginRequest_work&#125;, &#125; var phones = []*pb.UserLoginRequest_PhoneNumber&#123; &#123;PhoneNumber: &quot;1111111&quot;, PhoneType: pb.UserLoginRequest_mobile&#125;, &#123;PhoneNumber: &quot;2222222&quot;, PhoneType: pb.UserLoginRequest_home&#125;, &#123;PhoneNumber: &quot;3333333&quot;, PhoneType: pb.UserLoginRequest_work&#125;, &#125; var lastUpdateDate = &amp;timestamp.Timestamp&#123; Seconds: time.Now().Unix(), Nanos: int32(999999999), &#125; request := &amp;pb.UserLoginRequest&#123; UserId: int64(100), UserName: &quot;aaaaa&quot;, UserNickname: &quot;用户昵称&quot;, UserCountry: &quot;china&quot;, UserGender: 1, UserCredits: 111.111, IsAdmin: true, AuthCode: []byte(&quot;abcdefg&quot;), UserBalance: 10000000.0000, UserHobby: pb.UserLoginRequest_music, LuckyNumbers: []int32&#123;2, 4, 6, 8, 10&#125;, UserEmail: userEmail, UserWeight: userWeight, UserNum: userNum, LoginStatus: pb.LoginStatus_success, Phones: phones, LastUpdateDate: lastUpdateDate, &#125; resp, err := client.Login(context.Background(), request) if err != nil &#123; log.Fatal(err) &#125; log.Println(resp)&#125;func loginStreaming(client pb.UserServiceClient) &#123; var userEmail = map[string]string&#123;&quot;email&quot;: &quot;test123@qq.com&quot;&#125; var userWeight = map[string]int32&#123;&quot;weight&quot;: 180&#125; var userNum = map[string]*pb.UserLoginRequest_PhoneNumber&#123; &quot;test001&quot;: &#123;PhoneNumber: &quot;001&quot;, PhoneType: pb.UserLoginRequest_mobile&#125;, &quot;test002&quot;: &#123;PhoneNumber: &quot;002&quot;, PhoneType: pb.UserLoginRequest_home&#125;, &quot;test003&quot;: &#123;PhoneNumber: &quot;003&quot;, PhoneType: pb.UserLoginRequest_work&#125;, &#125; var phones = []*pb.UserLoginRequest_PhoneNumber&#123; &#123;PhoneNumber: &quot;test-1111111&quot;, PhoneType: pb.UserLoginRequest_mobile&#125;, &#123;PhoneNumber: &quot;test-2222222&quot;, PhoneType: pb.UserLoginRequest_home&#125;, &#123;PhoneNumber: &quot;test-3333333&quot;, PhoneType: pb.UserLoginRequest_work&#125;, &#125; var lastUpdateDate = &amp;timestamp.Timestamp&#123; Seconds: time.Now().Unix(), Nanos: int32(999999999), &#125; login := &amp;pb.UserLoginRequest&#123; UserId: int64(101), UserName: &quot;bbbbbbb&quot;, UserNickname: &quot;用户昵称&quot;, UserCountry: &quot;china&quot;, UserGender: 2, UserCredits: 222.222, IsAdmin: true, AuthCode: []byte(&quot;xxxxx&quot;), UserBalance: 20000000.0000, UserHobby: pb.UserLoginRequest_tour, LuckyNumbers: []int32&#123;34, 55, 333, 33, 199&#125;, UserEmail: userEmail, UserWeight: userWeight, UserNum: userNum, LoginStatus: pb.LoginStatus_error, Phones: phones, LastUpdateDate: lastUpdateDate, &#125; stream, err := client.LoginStreaming(context.Background()) if err != nil &#123; log.Fatalf(&quot;failed to call:%v&quot;, err) &#125; go func() &#123; for &#123; err := stream.Send(login) if err != nil &#123; log.Fatalf(&quot;failed to send,err:%v&quot;, err) break &#125; time.Sleep(time.Second) &#125; &#125;() for &#123; reply, err := stream.Recv() if err != nil &#123; if err == io.EOF &#123; break &#125; log.Printf(&quot;failed to recv,err:%v&quot;, err) break &#125; log.Println(reply) &#125;&#125;func test(client pb.TestServiceClient) &#123; req := &amp;pb.TestRequest&#123; Name: &quot;test&quot;, Extensions: []*pb.Extension&#123; &amp;pb.Extension&#123;Id: 8888, Data: nil&#125;, &amp;pb.Extension&#123;Id: 9999, Data: &amp;anypb.Any&#123;TypeUrl: &quot;type url&quot;&#125;&#125;, &#125;, &#125; reply, err := client.Test(context.Background(), req) if err != nil &#123; log.Fatal(err) &#125; log.Println(reply)&#125;func ping(client pb.TestServiceClient) &#123; reply, err := client.Ping(context.Background(), &amp;empty.Empty&#123;&#125;) if err != nil &#123; log.Fatal(err) &#125; log.Printf(&quot;%v&quot;, reply)&#125; gRPC服务端server/server.go 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162package mainimport ( &quot;crypto/tls&quot; &quot;crypto/x509&quot; &quot;flag&quot; &quot;tests/grpc/services&quot; pb &quot;tests/grpc/services/pb&quot; &quot;io/ioutil&quot; &quot;log&quot; &quot;net&quot; &quot;google.golang.org/grpc&quot; &quot;google.golang.org/grpc/credentials&quot;)var ( serverPort = flag.String(&quot;port&quot;, &quot;:8888&quot;, &quot;port&quot;))func main() &#123; flag.Parse() cert, err := tls.LoadX509KeyPair(&quot;cert/server.pem&quot;, &quot;cert/server.key&quot;) if err != nil &#123; log.Fatalf(&quot;load cert files failed,err:%v&quot;, err) &#125; certPool := x509.NewCertPool() ca, err := ioutil.ReadFile(&quot;cert/ca.pem&quot;) if err != nil &#123; log.Fatalf(&quot;read ca file failed,err:%v&quot;, err) &#125; if ok := certPool.AppendCertsFromPEM(ca); !ok &#123; log.Fatal(&quot;failed to append certs&quot;) &#125; creds := credentials.NewTLS(&amp;tls.Config&#123; Certificates: []tls.Certificate&#123;cert&#125;, // 服务端证书 ClientAuth: tls.RequireAndVerifyClientCert, ClientCAs: certPool, &#125;) server := grpc.NewServer(grpc.Creds(creds)) pb.RegisterHelloServiceServer(server, new(services.HelloService)) pb.RegisterUserServiceServer(server, new(services.UserService)) pb.RegisterTestServiceServer(server, new(services.TestService)) l, err := net.Listen(&quot;tcp&quot;, *serverPort) if err != nil &#123; log.Fatalf(&quot;failed to listen,err:%v&quot;, err) &#125; log.Printf(&quot;server start at [%s]&quot;, *serverPort) err = server.Serve(l) if err != nil &#123; log.Fatal(err) &#125;&#125; gRPC使用实例查看目录结构： 1cd tests 查看目录层级： 1tree -L 1 1234567└── grpc ├── client ├── proto ├── server └── services5 directories, 0 files 1234567891011121314151617181920212223242526272829└── grpc ├── client │ ├── cert │ │ ├── ca.pem │ │ ├── client.key │ │ └── client.pem │ └── client.go ├── proto │ ├── common.proto │ ├── generate.sh │ ├── hello.proto │ └── user.proto ├── server │ ├── auth_server.go │ ├── cert │ │ ├── ca.pem │ │ ├── server.key │ │ └── server.pem │ └── server.go └── services ├── hello.go ├── pb │ ├── common.pb.go │ ├── hello.pb.go │ └── user.pb.go ├── test.go └── user.go8 directories, 19 files","categories":[{"name":"gRPC","slug":"gRPC","permalink":"https://hqd8080.github.io/categories/gRPC/"}],"tags":[{"name":"golang","slug":"golang","permalink":"https://hqd8080.github.io/tags/golang/"},{"name":"gRPC","slug":"gRPC","permalink":"https://hqd8080.github.io/tags/gRPC/"}]},{"title":"Linux使用tar压缩时排除某个目录或文件","slug":"linux/linux-tar-exclude","date":"2021-11-29T06:30:28.000Z","updated":"2021-12-02T02:14:13.000Z","comments":true,"path":"2021/11/29/linux/linux-tar-exclude/","link":"","permalink":"https://hqd8080.github.io/2021/11/29/linux/linux-tar-exclude/","excerpt":"","text":"例如：在/home/abc/目录下有4个子目录：abc01、abc02、abc03、abc04，现在想把/home/abc/目录下的abc01、abc02、abc03打包成abc.tar.gz，不打包abc04！ 操作如下： cd /home 1tar -zcvf abc.tar.gz --exclude=abc04 ./abc 打包成功，可以在/home目录下面看到abc.tar.gz文件了","categories":[{"name":"Linux","slug":"Linux","permalink":"https://hqd8080.github.io/categories/Linux/"}],"tags":[{"name":"linux","slug":"linux","permalink":"https://hqd8080.github.io/tags/linux/"}]},{"title":"Linux进程维护shell脚本","slug":"linux/linux-process-start","date":"2021-11-29T06:30:28.000Z","updated":"2021-11-29T06:45:36.000Z","comments":true,"path":"2021/11/29/linux/linux-process-start/","link":"","permalink":"https://hqd8080.github.io/2021/11/29/linux/linux-process-start/","excerpt":"","text":"start.sh 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647#!/bin/bashprocess_name=`pwd | xargs basename`usage() &#123; echo &quot;./start.sh [ start | stop | reload | status ]&quot;&#125;status() &#123; ps -ef | grep $process_name | grep -v grep&#125;start() &#123; echo &quot;start $process_name....&quot; nohup ./$process_name 2&gt;&amp;1 1&gt;/dev/null &amp; status&#125;stop() &#123; echo &quot;stop $process_name...&quot; ps -ef | grep $process_name | grep -v grep | awk &#x27;&#123;print $2&#125;&#x27; |xargs kill -9 status&#125;reload() &#123; echo &quot;reload $process_name...&quot; ps -ef | grep $process_name |grep -v grep | awk &#x27;&#123;print $2&#125;&#x27; |xargs kill -HUP status&#125;case &quot;$1&quot; in start) start ;; stop) stop ;; reload) reload ;; status) status ;; *) usage ;;esac","categories":[{"name":"Linux","slug":"Linux","permalink":"https://hqd8080.github.io/categories/Linux/"}],"tags":[{"name":"linux","slug":"linux","permalink":"https://hqd8080.github.io/tags/linux/"}]},{"title":"Linux服务器备份数据库shell脚本","slug":"linux/linux-db-backup","date":"2021-11-16T09:42:28.000Z","updated":"2021-11-25T03:09:51.000Z","comments":true,"path":"2021/11/16/linux/linux-db-backup/","link":"","permalink":"https://hqd8080.github.io/2021/11/16/linux/linux-db-backup/","excerpt":"","text":"data_backup.sh 123456789101112131415161718192021222324252627282930313233343536#!/bin/bashDIR=&quot;/usr/local/data/data_backup&quot;DATE=date +%Y%m%d%H%M%SDATE_DAY=date +%Y%m%decho $DATEDB_HOST=&quot;127.0.0.1&quot;DB_USER=&quot;root&quot;DB_PASS=&quot;dbpwd&quot;mkdir $&#123;DIR&#125;/$&#123;DATE_DAY&#125;cd $&#123;DIR&#125;/$&#123;DATE_DAY&#125;/usr/local/mysql/bin/mysqldump -h$&#123;DB_HOST&#125; -u$&#123;DB_USER&#125; -p$&#123;DB_PASS&#125; --databases dbname &gt;dbname-$&#123;DATE&#125;.sqlif [ $? -eq 0 ]thentar -zcf mydatabase-$&#123;DATE&#125;.sql.tgz dbname-$&#123;DATE&#125;.sqlelsesleep 20/usr/local/mysql/bin/mysqldump -h$&#123;DB_HOST&#125; -u$&#123;DB_USER&#125; -p$&#123;DB_PASS&#125; --databases dbname &gt;dbname-$&#123;DATE&#125;.sqlif [ $? -eq 0 ];thentar -zcf mydatabase-$&#123;DATE&#125;.sql.tgz dbname-$&#123;DATE&#125;.sqlfirm -rf dbname-$&#123;DATE&#125;.sql#find $DIR -type d -mtime +30 |xargs rm -rfDATE_STR=date +%Y%m%d%H%M%Secho $DATE &gt;&gt;$&#123;DIR&#125;/$&#123;DATE_DAY&#125;/mysql_dump$DATE_DAY.logecho $DATE_STR &gt;&gt;$&#123;DIR&#125;/$&#123;DATE_DAY&#125;/mysql_dump$DATE_DAY.log 12#设置脚本data_backup.sh有可执行的权限chmod +x ./data_backup.sh 12345crontab -e #添加计划任务0 23 * * * /usr/local/data/data_backup.shsystemctl start crond.service #设置cron开机启动 解决：mysqldump: [Warning] Using a password on the command line interface can be insecure.1234567vim /etc/my.cnf[mysqldump]host=127.0.0.1user=rootpassword=123456port=3306 修改完配置文件后,只需要执行mysqldump脚本就可以了;备份脚本中不需要涉及用户名密码相关信息","categories":[{"name":"Linux","slug":"Linux","permalink":"https://hqd8080.github.io/categories/Linux/"}],"tags":[{"name":"MySQL","slug":"MySQL","permalink":"https://hqd8080.github.io/tags/MySQL/"},{"name":"linux","slug":"linux","permalink":"https://hqd8080.github.io/tags/linux/"}]},{"title":"Linux计划任务Crontab实例详解","slug":"linux/linux-crontab","date":"2021-11-15T01:40:28.000Z","updated":"2021-12-02T09:01:57.000Z","comments":true,"path":"2021/11/15/linux/linux-crontab/","link":"","permalink":"https://hqd8080.github.io/2021/11/15/linux/linux-crontab/","excerpt":"","text":"crontab是一个用于设置周期性被执行任务的工具，类似于Windows系统中的任务计划程序。 安装并检查crontab服务 检查crond工具是不是安装：crontab -l #任务列表 检查crond服务是否启动：service crond status #查看crontab状态 安装crontab yum install vixie-cron #安装 chkconfig crond on #设为开机启动，先要安装chkconfig（yum install chkconfig） service crond start #启动 service crond stop #停止 /etc/rc.d/init.d/crond restart #重启 /etc/rc.d/init.d/crond reload #不中断服务，重新载入配置 设置任务计划 /home/test.sh #要自动执行的脚本程序路径 chmod +x /home/test.sh #对脚本文件添加执行权限，否则不能执行 crontab -e #编辑配置文件，在最后一行添加内容 30 1 * * * root /home/test.sh #表示每天凌晨1点30分执行脚本 :wq! #保存退出 crontab文件的格式minute hour day month weekday username command minute：分，值为0-59 hour：小时，值为1-23 day：天，值为1-31 month：月，值为1-12 weekday：星期，值为0-6（0代表星期天，1代表星期一，以此类推） username：要执行程序的用户，一般设置为root command：要执行的程序路径（设置为绝对路径）例如：/home/test.sh crontab实例 每晚的21：30重启apache 130 21 * * * service httpd restart 每月的1，10，22日的4：45重启apache 145 4 1，10，22，* * service httpd restart 每月的1到10日的4：45重启apache 145 4 1-10 * * service httpd restart 每隔两分钟重启apache服务器 12*/2 * * * * service httpd restart1-59/2 * * * * service httpd restart 晚上11点到早上7点之间，每隔一小时重启apache 10 23-7/1 * * * service httpd restart 每天18：00至23：00之间每隔30分钟重启apache 120，30 18-23 * * * service httpd restart0-59/30 18-23 * * * service httpd restart 每周一到周五的11:41开始，每隔10分钟执行一次 12341,51 11 * * 1-5 root /home/test.sh1-59/10 12-23 * * 1-5 root /home/test.sh 在每天的10:31开始，每隔2小时重复一次 131 10-23/2 * * * root /home/test.sh 每天的10:30开始，每隔2小时重复一次 130 10-23/2 * * * root /home/test.sh 每周一到周五9:30 130 9 * * 1-5 root /home/test.sh 每周一到周五8:00，每周一到周五9:00 10 8,9 * * 1-5 root /home/test.sh 每周一到周五9:25到11:35之间、13:00到15:00之间，每隔10分钟运行一次 123456725,35,45,55 9 * * 1-5 root /home/test.sh5-59/10 10 * * 1-5 root /home/test.sh5,15,25,35 11 * * 1-5 root /home/test.sh*/10 13-15 * * 1-5 root /home/test.sh 每周一到周五8:30、8:50、9:30、10:00、10:30、11:00、11:30、13:30、14:00、14:30、5:00分别执行一次 12345678930,50 8 * * 1-5 root /home/test.sh30 9 * * 1-5 root /home/test.sh*/30 10-11 * * 1-5 root /home/test.sh30 13 * * 1-5 root /home/test.sh0,30 14-15 * * 1-5 root /home/test.sh 1`crontab -e -u root` #为某个用户添加计划任务 crontab中最小只能设置到每分钟执行一个命令，如果想每半分钟执行某个命令，可以通过shell脚本的sleep命令配合crontab即可完成这一功能 1*/1 * * * * sleep 30s； echo &quot;this is a test!!&quot; 小结: *，表示任何时候都匹配 可以用&ldquo;A，B，C&rdquo;表示A或者B或者C时执行命令 可以用&ldquo;A-B&rdquo;表示A到B之间时执行命令 可以用&ldquo;*/A&rdquo;表示每A分钟（小时等）执行一次命令","categories":[{"name":"Linux","slug":"Linux","permalink":"https://hqd8080.github.io/categories/Linux/"}],"tags":[{"name":"linux","slug":"linux","permalink":"https://hqd8080.github.io/tags/linux/"}]},{"title":"Linux使用cp命令直接覆盖不提示的方法","slug":"linux/linux-cp","date":"2021-11-15T01:30:28.000Z","updated":"2021-12-02T02:19:55.000Z","comments":true,"path":"2021/11/15/linux/linux-cp/","link":"","permalink":"https://hqd8080.github.io/2021/11/15/linux/linux-cp/","excerpt":"","text":"普通的cp命令使用例如：cp abc.txt /home 如果/home里面之前有abc.txt文件，会提示你是否要覆盖？这个时候你需要输入Y，假如文件很多的话，每复制一个文件都要输入一次Y。 下面介绍cp文件时直接覆盖不提示的方法命令如下： \\cp abc.txt /home 直接复制abc.txt 到/home里面，不管/home里面之前是否有这个文件都会直接覆盖，不再出现覆盖提示！","categories":[{"name":"Linux","slug":"Linux","permalink":"https://hqd8080.github.io/categories/Linux/"}],"tags":[{"name":"linux","slug":"linux","permalink":"https://hqd8080.github.io/tags/linux/"}]},{"title":"Solidity（七）多签钱包合约程序wallet","slug":"blockchain/solidity-erc-wallet","date":"2021-05-01T04:50:26.000Z","updated":"2024-06-03T10:13:07.537Z","comments":true,"path":"2021/05/01/blockchain/solidity-erc-wallet/","link":"","permalink":"https://hqd8080.github.io/2021/05/01/blockchain/solidity-erc-wallet/","excerpt":"","text":"单签钱包：只由一个私钥或者助记词来管理、由一个人管理钱包私钥的方式；执行持有对应的私钥就能控制该钱包中的资金；包括收款、转账、提现等交易操作； 单签钱包的优点是方便管理；单签钱包的缺点是一旦私钥被盗，将面临资金全部丢失的风险； 1 简单的单签钱包合约123456789101112131415161718192021222324252627282930313233343536373839404142434445464748// author：hqd8080// contracts/EtherWallet.sol// SPDX-License-Identifier: MITpragma solidity &gt;=0.8.2 &lt;0.9;/*** 简单的单签钱包实例**/contract EtherWallet &#123; //合约的所有者 address payable public owner; //定义转账事件 event TransferEvent(address from, address to, uint256 amount); //构造函数 constructor() &#123; owner = payable(msg.sender); &#125; //收款时合约会自动调用的函数 receive() external payable &#123; &#125; //函数修改器 modifier onlyOwner() &#123; require(msg.sender == owner, &quot;wallet: caller is not owner&quot;); _; &#125; //提现函数，限制只有合约的所有者才能体现 function withdraw(uint256 amount) external onlyOwner&#123; payable (msg.sender).transfer(amount); &#125; //转账函数，限制只有合约的所有者才能转账 function transfer(address payable to, uint256 amount) public onlyOwner &#123; require(owner.balance &gt;= amount, &quot;wallet: balance not enough&quot;); // 使用 call 函数实现转账 (bool succeed, ) = to.call&#123;value: amount&#125;(&quot;&quot;); require(succeed, &quot;wallet: transfer failed&quot;); emit TransferEvent(owner, to, amount); &#125; //获取账户余额 function getBalance() external view returns (uint256) &#123; return address(this).balance; &#125;&#125; 2 多签钱包合约所谓多签钱包，是指设定多个人共同来管理一个地址；必须满足一定数量的管理者签名同意之后才能动用地址账户内的资金；大大降低了资产被盗取的风险； 多签钱包的最大特点是：需要有多个私钥所有者的授权才能执行钱包的交易操作；与单签钱包相比多签钱包在使用和操作上多了授权和撤销两个操作；因为多签钱包机制是由多个用户共同管理一份资产； 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129// author：hqd8080// contracts/MultiSignWallet.sol// SPDX-License-Identifier: MITpragma solidity &gt;=0.8.2 &lt;0.9;/*** 多签钱包合约**/contract MultiSignWallet &#123; //存款事件，记录两个数据：存款方地址，存款金额 event Deposit(address indexed sender, uint256 amount); //提交交易申请 event Submit(uint256 indexed txId); //授权批准事件，记录两个数据：批准者账号，批准的交易序号 event Approve(address indexed owner, uint256 indexed txId); //撤销批准事件，记录两个数据：撤销者账号，撤销批准的交易序号 event Revoke(address indexed owner, uint256 txId); //执行的交易 event Execute(uint256 indexed txId); //存储所有的私钥持有人，类型为address，总的签名个数 address[] public owners; //存储和判断某个地址是不是私钥持有人 mapping (address =&gt; bool) public isOwner; //执行签名的最少人数 uint public required; struct Transaction &#123; address to; //接收方地址 uint256 value; //交易金额 bytes data; //如果发送到的是合约地址，可以执行此合约代码 bool executed; // 该交易是否执行 &#125; //存储提交的交易 Transaction[] public transactions; //用户判断持有人是否同意了某一笔交易 mapping (uint =&gt; mapping (address =&gt; bool)) public approved; //构造函数,初始化私钥持有人和确认数量 constructor (address[] memory _owners, uint256 _required) &#123; require(_owners.length &gt; 0, &quot;wallet: owners is required&quot;); require(_required &gt; 0 &amp;&amp; _required &lt;= _owners.length, &quot;wallet: invalid require number of owners&quot;); for (uint256 i = 0; i &lt; _owners.length; i ++) &#123; address _owner = _owners[i]; require(_owner != address(0), &quot;wallet: invalid owner&quot;); require(!isOwner[_owner], &quot;wallet: owner had&quot;); isOwner[_owner] = true; owners.push(_owner); &#125; //执行签名的最少人数 required = _required; &#125; //收款时合约会自动调用的函数 receive() external payable &#123; //记录存款地址和数量 emit Deposit(msg.sender, msg.value); &#125; //函数修改器 modifier onlyOwner() &#123; require(isOwner[msg.sender], &quot;wallet: invalid is owner&quot;); _; &#125; //判断是否存在txId modifier isTxId(uint _txId) &#123; require(_txId &lt; transactions.length, &quot;wallet: invalid txId&quot;); _; &#125; //用于判断txId的地址是否已授权 modifier notApproved(uint _txId) &#123; require(!approved[_txId][msg.sender], &quot;wallet: had approved&quot;); _; &#125; //用于判断txId对应的交易是否已经执行 modifier notExecuted(uint _txId) &#123; require(!transactions[_txId].executed, &quot;wallet: had executed&quot;); _; &#125; //提交交易申请 function submitTransaction(address _to, uint256 _value, bytes calldata _data) external onlyOwner &#123; transactions.push(Transaction(&#123;to: _to, value: _value, data: _data, executed: false&#125;)); emit Submit(transactions.length - 1); &#125; //私钥持有人授权函数 function approve(uint _txId) external onlyOwner isTxId(_txId) notApproved(_txId) notExecuted(_txId) &#123; approved[_txId][msg.sender] = true; emit Approve(msg.sender, _txId); &#125; //授权人数 function getApproveCount(uint _txId) private view returns (uint256)&#123; uint256 count = 0; for (uint256 i = 0; i &lt; owners.length; i ++) &#123; address owner = owners[i]; if (approved[_txId][owner]) &#123; count ++; &#125; &#125; return count; &#125; //执行交易方法 function execute(uint _txId) external isTxId(_txId) notExecuted(_txId) &#123; require(getApproveCount(_txId) &gt;= required, &quot;wallet: approveCount &lt; required&quot;); Transaction storage transaction = transactions[_txId]; transaction.executed = true; (bool successed,) = transaction.to.call&#123;value: transaction.value&#125;(transaction.data); require(successed, &quot;wallet: execute failed&quot;); emit Execute(_txId); &#125; //撤销批准 function revoke(uint _txId) external onlyOwner isTxId(_txId) notExecuted(_txId) &#123; require(approved[_txId][msg.sender], &quot;wallet: not approved&quot;); approved[_txId][msg.sender] = false; emit Revoke(msg.sender, _txId); &#125;&#125;","categories":[{"name":"区块链","slug":"区块链","permalink":"https://hqd8080.github.io/categories/%E5%8C%BA%E5%9D%97%E9%93%BE/"}],"tags":[{"name":"区块链","slug":"区块链","permalink":"https://hqd8080.github.io/tags/%E5%8C%BA%E5%9D%97%E9%93%BE/"},{"name":"Blockchain","slug":"Blockchain","permalink":"https://hqd8080.github.io/tags/Blockchain/"},{"name":"Ethereum","slug":"Ethereum","permalink":"https://hqd8080.github.io/tags/Ethereum/"},{"name":"Solidity","slug":"Solidity","permalink":"https://hqd8080.github.io/tags/Solidity/"}]},{"title":"Solidity（六）合约标准ERC-1155","slug":"blockchain/solidity-erc-1155","date":"2021-05-01T02:10:26.000Z","updated":"2024-05-28T16:19:56.185Z","comments":true,"path":"2021/05/01/blockchain/solidity-erc-1155/","link":"","permalink":"https://hqd8080.github.io/2021/05/01/blockchain/solidity-erc-1155/","excerpt":"","text":"以太坊已经存在了ERC-20和ERC-721两种代币标准；分别用于处理【同质化代币】和【非同质化代币】；然而这两种标准仍然有一些局限性，无法满足复杂的代币经济系统的需求； 例如：在游戏中，可能需要同时管理多种类型的代币，包括同质化代币和非同质化代币；为了解决这个复杂问题，以太坊2018年退出ERC-1155代币标准、目标是创建一个灵活且高效的代币标准；可以同时管理多种类型的代币； 1 IERC-1155代币接口定义介绍ERC-1155协议同样需要依赖ERC-165协议；通过IERC-165接口合约实现ERC-1155协议的标准；IERC-1155接口的定义如下： 1234567891011121314151617181920212223242526272829// author:hqd8080// contracts/IERC1155.sol// SPDX-License-Identifier: MITpragma solidity &gt;=0.8.2&lt; 0.9.0;//IERC-1155接口定义、包含4个时间和6个函数interface IERC1155 &#123; //单类代币转账事件 event TransferSingle(address indexed _operator, address indexed _from, address indexed _to, uint256 _id, uint256 _value); //批量转账事件 event TransferBatch(address indexed _operator, address indexed _from, address indexed _to, uint256[] _ids, uint256[] _values); //批量授权事件 event ApprovalForAll(address indexed _owner, address indexed _operator, bool _approved); //_id 种类代币的 URI 发送变化时触发的事件 _value为新的URI event URI(string _value, uint256 indexed _id); //安全转账函数 function safeTransferFrom(address _from, address _to, uint256 _id, uint256 _value, bytes calldata _data) external; //批量安全转账函数 function safeBatchTransferFrom(address _from, address _to, uint256[] calldata _ids, uint256[] calldata _values, bytes calldata _data) external; //持仓查询函数，查询 _owner 所拥有的 _id 种类的代币持有量 function balanceOf(address _owner, uint256 _id) external view returns (uint256); //批量持仓查询函数 function balanceOfBatch(address[] calldata _owners, uint256[] calldata _ids) external view returns (uint256[] memory); //批量授权函数 function setApprovalForAll(address _operator, bool _approved) external; //批量授权查询函数 function isApprovedForAll(address _owner, address _operator) external view returns (bool);&#125; 2 IERC-1155MetadataURI接口对于每种代币的URI元数据，通过【IERC-1155MetadataURI】接口来定义，该接口的定义如下： 12345//IERC1155MetadataURI、对于每种代币的URI元数据interface IERC1155MetadataURI &#123; //返回第 _id 种代币的 URI function uri(uint256 _id) external view returns (string memory);&#125; 3 IERC-1155Receiver接口与ERC-721协议类似；为了避免误操作，造成代币损失，ERC-1155要求代币的接收合约需要继承【IERC-1155Receiver】接口，并定义了两个函数，该接口的定义如下： 1234567//IERC1155TokenReceiver、安全转账接口interface IERC1155TokenReceiver &#123; //单币种的转账接收函数 function onERC1155Received(address _operator, address _from, uint256 _id, uint256 _value, bytes calldata _data) external returns(bytes4); //批量多币种转账接收函数 function onERC1155BatchReceived(address _operator, address _from, uint256[] calldata _ids, uint256[] calldata _values, bytes calldata _data) external returns(bytes4);&#125; 4 实现ERC-1155接口合约程序下面的合约程序实现了【ERC-1155协议】合约接口；还实现了单币种和多币种的铸造及销毁函数； 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173// author:hqd8080// contracts/ERC1155.sol// SPDX-License-Identifier: MITpragma solidity &gt;= 0.8.20 &lt; 0.9.0;import &quot;./IERC1155.sol&quot;;import &quot;./IERC165.sol&quot;;//npm install @openzeppelin/contracts@v4.8.2import &quot;@openzeppelin/contracts/utils/Strings.sol&quot;;//ERC-1155合约,实现IERC-165、IERC-1155、IERC1155MetadataURIcontract ERC1155 is IERC165, IERC1155, IERC1155MetadataURI &#123; using Strings for uint256; string public name; string public symbol; //owner =&gt; id =&gt; balance mapping (address =&gt; mapping (uint256 =&gt; uint256)) public _balanceOf; //owner =&gt; operator =&gt; approved mapping (address =&gt; mapping (address =&gt; bool)) public _isApprovedForAll; //构造函数 constructor(string memory name_, string memory symbol_) &#123; name = name_; symbol = symbol_; &#125; //安全转账函数 function safeTransferFrom(address _from, address _to, uint256 _id, uint256 _value, bytes calldata _data) override external &#123; require(msg.sender == _from || _isApprovedForAll[_from][msg.sender], &quot;ERC1155: not approved!&quot;); require(_to != address(0), &quot;ERC1155: to is a zero address&quot;); _balanceOf[_from][_id] -= _value; _balanceOf[_to][_id] += _value; emit TransferSingle(msg.sender, _from, _to, _id, _value); if (_to.code.length &gt; 0) &#123; require( IERC1155TokenReceiver(_to).onERC1155Received(msg.sender, _from, _id, _value, _data) == IERC1155TokenReceiver.onERC1155Received.selector, &quot;ERC1155: unsaft transfer!&quot; ); &#125; &#125; //批量安全转账函数 function safeBatchTransferFrom(address _from, address _to, uint256[] calldata _ids, uint256[] calldata _values, bytes calldata _data) override external &#123; require(msg.sender == _from || _isApprovedForAll[_from][msg.sender], &quot;ERC1155: not approved!&quot;); require(_to != address(0), &quot;ERC1155: to is a zero address&quot;); require(_ids.length == _values.length, &quot;ERC1155: _ids length != _values length!&quot;); for (uint256 i = 0; i &lt; _ids.length; i++) &#123; _balanceOf[_from][_ids[i]] -= _values[i]; _balanceOf[_to][_ids[i]] += _values[i]; &#125; emit TransferBatch(msg.sender, _from, _to, _ids, _values); if (_to.code.length &gt; 0 ) &#123; require( IERC1155TokenReceiver(_to).onERC1155BatchReceived(msg.sender, _from, _ids, _values, _data) == IERC1155TokenReceiver.onERC1155BatchReceived.selector, &quot;ERC1155: unsaft transfer!&quot; ); &#125; &#125; //持仓查询函数，查询 _owner 所拥有的 _id 种类的代币持有量 function balanceOf(address _owner, uint256 _id) override external view returns (uint256) &#123; require(_owner != address(0), &quot;ERC1155: address zero is not a vaild owner!&quot;); return _balanceOf[_owner][_id]; &#125; //批量持仓查询函数 function balanceOfBatch(address[] calldata _owners, uint256[] calldata _ids) override external view returns (uint256[] memory balances) &#123; require(_owners.length == _ids.length, &quot;ERC1155: owner length != ids length!&quot;); balances = new uint256[](_owners.length); unchecked &#123; for (uint256 i = 0; i &lt; _owners.length; i++) &#123; balances[i] = _balanceOf[_owners[i]][_ids[i]]; &#125; &#125; &#125; //批量授权函数 function setApprovalForAll(address _operator, bool _approved) override external &#123; _isApprovedForAll[msg.sender][_operator] = _approved; emit ApprovalForAll(msg.sender, _operator, _approved); &#125; //批量授权查询函数 function isApprovedForAll(address _owner, address _operator) override external view returns (bool) &#123; return _isApprovedForAll[_owner][_operator]; &#125; //检测是否实现了某个接口的函数 function supportsInterface(bytes4 interfaceID) override external pure returns (bool) &#123; return interfaceID == type(IERC1155).interfaceId || interfaceID == type(IERC1155MetadataURI).interfaceId || interfaceID == type(IERC165).interfaceId; &#125; //返回第 _id 种代币的 URI function uri(uint256 _id) override external view returns (string memory) &#123; string memory baseURI = _baseURI(); return bytes(baseURI).length &gt; 0 ? string(abi.encodePacked(baseURI, _id.toString())) : &quot;&quot;; &#125; function _baseURI() internal view virtual returns (string memory) &#123; return &quot;&quot;; &#125; //代币铸造 function _mint(address _to, uint256 _id, uint256 _value, bytes memory _data) internal &#123; require(_to != address(0), &quot;ERC1155: _to is a zero address&quot;); _balanceOf[_to][_id] += _value; emit TransferSingle(msg.sender, address(0), _to, _id, _value); if (_to.code.length &gt; 0) &#123; require( IERC1155TokenReceiver(_to).onERC1155Received(msg.sender, address(0), _id, _value, _data) == IERC1155TokenReceiver.onERC1155Received.selector, &quot;ERC1155: unsaft transfer!&quot; ); &#125; &#125; //批量代币铸造 function _batchMint(address _to, uint256[] calldata _ids, uint256[] calldata _values, bytes calldata _data) internal &#123; require(_to != address(0), &quot;ERC1155: _to is a zero address&quot;); require(_ids.length == _values.length, &quot;ERC1155: _ids length != _values length!&quot;); for (uint256 i = 0; i &lt; _ids.length; i++) &#123; _balanceOf[_to][_ids[i]] += _values[i]; &#125; emit TransferBatch(msg.sender, address(0), _to, _ids, _values); if (_to.code.length &gt; 0) &#123; require( IERC1155TokenReceiver(_to).onERC1155BatchReceived(msg.sender, address(0), _ids, _values, _data) == IERC1155TokenReceiver.onERC1155BatchReceived.selector, &quot;ERC1155: unsaft transfer!&quot; ); &#125; &#125; //销毁代币 function _burn(address _from, uint256 _id, uint256 _value) internal &#123; require(_from != address(0), &quot;ERC1155: _from is a zero address&quot;); _balanceOf[_from][_id] -= _value; emit TransferSingle(msg.sender, _from, address(0), _id, _value); &#125; //批量销毁代币 function _batchBurn(address _from, uint256[] calldata _ids, uint256[] calldata _values) internal &#123; require(_from != address(0), &quot;ERC1155: _from is a zero address&quot;); require(_ids.length == _values.length, &quot;ERC1155: _ids length != _values length!&quot;); for (uint256 i = 0; i &lt; _ids.length; i++) &#123; _balanceOf[_from][_ids[i]] -= _values[i]; &#125; emit TransferBatch(msg.sender, _from, address(0), _ids, _values); &#125;&#125; 5 自定义ERC-1155代币合约在ERC-1155实现的合约基础上，开发者可以定义实现自己的ERC-1155标准代币并指定发行量上限； 主要思想是在构造函数中输入多标准代币的自定义名称和简称；然后重写单币种铸造函数多多币种的铸造函数，增加总供应量上限判断逻辑，以及单币种销毁函数和多币种销毁函数； 另外还可以通过重写_baseURI函数，设置开发者自己的URI值； 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748// author:hqd8080// contracts/MyMultiToken.sol// SPDX-License-Identifier: MITpragma solidity &gt;= 0.8.20 &lt; 0.9.0;import &quot;./ERC1155.sol&quot;;//自定义ERC1155代币合约contract MyMultiToken is ERC1155 &#123; uint256 constant MAX_COUNT = 10000; //构造函数 constructor() ERC1155 (&quot;MULTITOKEN&quot;, &quot;MT&quot;) &#123; &#125; //代币铸造 function _mint(uint256 _id, uint256 _value, bytes memory _data) external &#123; require(_id &lt; MAX_COUNT, &quot;MyMultiToken: _id overflow!&quot;); _mint(msg.sender, _id, _value, _data); &#125; //批量代币铸造 function _batchMint(uint256[] calldata _ids, uint256[] calldata _values, bytes calldata _data) external &#123; for (uint256 i = 0; i &lt; _ids.length; i++) &#123; require(_ids[i] &lt; MAX_COUNT, &quot;MyMultiToken: id overflow!&quot;); &#125; _batchMint(msg.sender, _ids, _values, _data); &#125; //销毁代币 function _burn(uint256 _id, uint256 _value) external &#123; _burn(msg.sender, _id, _value); &#125; //批量销毁代币 function _batchBurn(uint256[] calldata _ids, uint256[] calldata _values) external &#123; _batchBurn(msg.sender, _ids, _values); &#125; //重写_baseURI函数 function _baseURI() internal pure override returns (string memory) &#123; return &quot;ipfs://xxxxxx&quot;; &#125;&#125;","categories":[{"name":"区块链","slug":"区块链","permalink":"https://hqd8080.github.io/categories/%E5%8C%BA%E5%9D%97%E9%93%BE/"}],"tags":[{"name":"区块链","slug":"区块链","permalink":"https://hqd8080.github.io/tags/%E5%8C%BA%E5%9D%97%E9%93%BE/"},{"name":"Blockchain","slug":"Blockchain","permalink":"https://hqd8080.github.io/tags/Blockchain/"},{"name":"Ethereum","slug":"Ethereum","permalink":"https://hqd8080.github.io/tags/Ethereum/"},{"name":"Solidity","slug":"Solidity","permalink":"https://hqd8080.github.io/tags/Solidity/"}]},{"title":"Solidity（五）合约标准ERC-721","slug":"blockchain/solidity-erc-721","date":"2021-04-01T13:36:00.000Z","updated":"2024-05-28T15:36:42.973Z","comments":true,"path":"2021/04/01/blockchain/solidity-erc-721/","link":"","permalink":"https://hqd8080.github.io/2021/04/01/blockchain/solidity-erc-721/","excerpt":"","text":"以太币、比特币这样的代币均属于【同质化代币】；即每个代币都是一样的；没有什么区别、均可以用于交换和转账；然而在现实生活中存在着很多物品是非同质化的； 比如：名画、艺术品、古董等；因为每一件物品都是不相同的；因此以太坊提出ERC-721代币标准；用于抽象和描述飞同质化的实物； 【非同质化代币】的特点： 独特性：唯一、比如：艺术品、游戏道具、房产 所有权：每个代币都有一个所有权；可用于交易和转移 可编程性：可使用智能合约根据应用场景创建各种飞同质化的应用和场景 元数据：每个ERC-721都可以关联元数据、用于描述代币的属性和特征、通常以URI的形式存储 1 IERC-165接口定义介绍ERC-165合约：标准接口监控协议；用于发布和检测智能合约实现了那些接口；在IERC-165接口合约中实现了ERC-165的逻辑描述、接口合约只有一个函数；下面介绍的ERC-721依赖于ERC-165合约； 123456789// author:hqd8080// contracts/IERC165.sol// SPDX-License-Identifier: MITpragma solidity &gt;=0.8.2&lt; 0.9.0;interface IERC165 &#123; //检测是否实现了某个接口的函数 function supportsInterface(bytes4 interfaceID) external view returns (bool);&#125; 2 IERC-721接口定义介绍1234567891011121314151617181920212223242526272829303132333435363738394041// author:hqd8080// contracts/IERC721.sol// SPDX-License-Identifier: MITpragma solidity &gt;=0.8.2&lt; 0.9.0;//ERC-721依赖于ERC-165interface IERC165 &#123; function supportsInterface(bytes4 interfaceID) external view returns (bool);&#125;//安全转账接口interface ERC721TokenReceiver &#123; function onERC721Received(address _operator, address _from, uint256 _tokenId, bytes memory _data) external returns(bytes4);&#125;//IERC-721接口定义interface IERC721 is IERC165 &#123; event Transfer(address indexed _from, address indexed _to, uint256 indexed _tokenId); //转账事件 event Approval(address indexed _owner, address indexed _approved, uint256 indexed _tokenId); //授权事件 event ApprovalForAll(address indexed _owner, address indexed _operator, bool _approved); //批量授权事件 //余额查询 function balanceOf(address _owner) external view returns (uint256); //查询某个飞同质化代币的所有者 function ownerOf(uint256 _tokenId) external view returns (address); //安全转账函数 function safeTransferFrom(address _from, address _to, uint256 _tokenId, bytes memory data) external payable; //安全转账函数重载 function safeTransferFrom(address _from, address _to, uint256 _tokenId) external payable; //转移飞同质化代币的所有权 function transferFrom(address _from, address _to, uint256 _tokenId) external payable; //授权操作 function approve(address _approved, uint256 _tokenId) external payable; //批量授权 function setApprovalForAll(address _operator, bool _approved) external; //获取某个非同质化代币的授权信息 function getApproved(uint256 _tokenId) external view returns (address); //判断是否已经对某个地址授权 function isApprovedForAll(address _owner, address _operator) external view returns (bool);&#125; 另外两个可选接口： IERC721Metadata： 定义查询元数据的相关信息 IERC721Enumerale：定义查询代币的唯一信息标识 3 实现ERC-721接口合约程序123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128// author:hqd8080// contracts/ERC721.sol// SPDX-License-Identifier: MITpragma solidity &gt;=0.8.2&lt; 0.9.0;import &quot;./IERC721.sol&quot;;//ERC-721合约,实现IERC-721接口函数contract ERC721 is IERC721 &#123; mapping (bytes4 =&gt; bool) supportsInterfaces; bytes4 invalID = 0xffffffff; bytes4 constant ERC165ID = 0x01ffc9a7; bytes4 constant ERC721ID = 0x80ac58cd; mapping (address =&gt; uint256) ercTokenCount; mapping (uint256 =&gt; address) ercTokenOwner; mapping (uint256 =&gt; address) ercTokenApproved; mapping (address =&gt; mapping (address =&gt; bool)) ercOperatorForAll; address private owner; constructor() &#123; _registerInterface(ERC165ID); _registerInterface(ERC721ID); owner = msg.sender; &#125; //授权 modifier canOperator(uint256 _tokenId) &#123; address _owner = ercTokenOwner[_tokenId]; require(msg.sender == _owner || ercOperatorForAll[owner][msg.sender], &quot;ERC721: permission denied&quot;); _; &#125; //转账 modifier canTransfer(uint256 _tokenId, address _from) &#123; address _owner = ercTokenOwner[_tokenId]; require(_owner == _from, &quot;ERC721: token owner is not _from&quot;); require(msg.sender == owner || ercTokenApproved[_tokenId] == msg.sender || ercOperatorForAll[owner][msg.sender], &quot;ERC721: permission denied&quot;); _; &#125; //铸造代币,新定义的函数不属于IERC-721接口 function mint(address _to, uint256 _tokenId, bytes memory data) external &#123; require(msg.sender == owner, &quot;ERC721: caller is not owner&quot;); require(_to != address(0), &quot;ERC721: to is a zero address&quot;); require(ercTokenOwner[_tokenId] == address(0), &quot;ERC721: _tokenId. already exists&quot;); ercTokenOwner[_tokenId] = _to; ercTokenCount[_to] += 1; bytes4 result = ERC721TokenReceiver(_to).onERC721Received(msg.sender, _to, _tokenId, data); require(result == ERC721TokenReceiver.onERC721Received.selector, &quot;ERC721: result not equal onERC721Received interfaceID&quot;); emit Transfer(address(0), _to, _tokenId); &#125; //注册接口 function _registerInterface(bytes4 interfaceID) internal &#123; supportsInterfaces[interfaceID] = true; &#125; //ERC-156函数 function supportsInterface(bytes4 interfaceID) override external view returns (bool) &#123; require(interfaceID != invalID, &quot;ERC721: invalid interfaceID&quot;); return supportsInterfaces[interfaceID]; &#125; //ERC-721部分函数 function balanceOf(address _owner) override external view returns (uint256) &#123; return ercTokenCount[_owner]; &#125; function ownerOf(uint256 _tokenId) override external view returns (address) &#123; return ercTokenOwner[_tokenId]; &#125; function approve(address _approved, uint256 _tokenId) override canOperator(_tokenId) external payable &#123; ercTokenApproved[_tokenId] = _approved; emit Approval(msg.sender, _approved, _tokenId); &#125; function setApprovalForAll(address _operator, bool _approved) override external &#123; ercOperatorForAll[msg.sender][_operator] = _approved; emit ApprovalForAll(msg.sender, _operator, _approved); &#125; function getApproved(uint256 _tokenId) override external view returns (address) &#123; return ercTokenApproved[_tokenId]; &#125; function isApprovedForAll(address _owner, address _operator) override external view returns (bool) &#123; return ercOperatorForAll[_owner][_operator]; &#125; function transferFrom(address _from, address _to, uint256 _tokenId) override external payable &#123; _transferFrom(_from, _to, _tokenId); &#125; function _transferFrom(address _from, address _to, uint256 _tokenId) internal canTransfer(_tokenId, _from) &#123; ercTokenOwner[_tokenId] = _to; ercTokenCount[_from] -= 1; ercTokenCount[_to] += 1; //取消授权 ercTokenApproved[_tokenId] = address(0); emit Transfer(_from, _to, _tokenId); &#125; function safeTransferFrom(address _from, address _to, uint256 _tokenId, bytes memory data) override external payable &#123; _safeTransferFrom(_from, _to, _tokenId, data); &#125; function safeTransferFrom(address _from, address _to, uint256 _tokenId) override external payable &#123; _safeTransferFrom(_from, _to, _tokenId, &quot;&quot;); &#125; function _safeTransferFrom(address _from, address _to, uint256 _tokenId, bytes memory data) internal &#123; _transferFrom(_from, _to, _tokenId); bytes4 result = ERC721TokenReceiver(_to).onERC721Received(msg.sender, _from, _tokenId, data); require(result == ERC721TokenReceiver.onERC721Received.selector, &quot;ERC721: result not equal onERC721Received interfaceID&quot;); &#125;&#125;","categories":[{"name":"区块链","slug":"区块链","permalink":"https://hqd8080.github.io/categories/%E5%8C%BA%E5%9D%97%E9%93%BE/"}],"tags":[{"name":"区块链","slug":"区块链","permalink":"https://hqd8080.github.io/tags/%E5%8C%BA%E5%9D%97%E9%93%BE/"},{"name":"Blockchain","slug":"Blockchain","permalink":"https://hqd8080.github.io/tags/Blockchain/"},{"name":"Ethereum","slug":"Ethereum","permalink":"https://hqd8080.github.io/tags/Ethereum/"},{"name":"Solidity","slug":"Solidity","permalink":"https://hqd8080.github.io/tags/Solidity/"}]},{"title":"Solidity（四）合约标准ERC-20","slug":"blockchain/solidity-erc-20","date":"2021-04-01T11:00:00.000Z","updated":"2024-05-28T15:31:58.184Z","comments":true,"path":"2021/04/01/blockchain/solidity-erc-20/","link":"","permalink":"https://hqd8080.github.io/2021/04/01/blockchain/solidity-erc-20/","excerpt":"","text":"ERC-20协议：是以太坊网络上的一种代币标准，2015年提出；ERC-20协议定义了【同质化】标准代币基本的逻辑和组成； 同质化标准：同质化标准代币是指在一个特定的代币标准下，每个代币都是可以相互替换的，没有区别或者差异的代币； 同质化代币的特点： 可互换性 可分割性 可传输性 余额查询 代币交易 1 IERC-20接口定义介绍IERC-20接口规定了ERC-20协议标准中的代币需要实现的函数和事件；在具体应用时，所有的ERC-20代币均具有统一的函数名称、输入参数和输出结果； 12345678910111213141516171819202122232425// author:hqd8080// contracts/IERC20.sol// SPDX-License-Identifier: MITpragma solidity &gt;=0.8.2&lt; 0.9.0;//IERC-20接口定义interface IERC20 &#123; //可选函数 function name() external view returns (string memory); function symbol() external view returns (string memory); function decimals() external view returns (uint8); //必须实现函数 function totalSupply() external view returns (uint256); function balanceOf(address _owner) external view returns (uint256 balance); function transfer(address _to, uint256 _value) external returns (bool success); function transferFrom(address _from, address _to, uint256 _value) external returns (bool success); function approve(address _spender, uint256 _value) external returns (bool success); function allowance(address _owner, address _spender) external view returns (uint256 remaining); //转账事件 event Transfer(address indexed _from, address indexed _to, uint256 _value); //授权事件 event Approval(address indexed _owner, address indexed _spender, uint256 _value);&#125; 2 实现ERC-20接口合约程序123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119// author:hqd8080// contracts/ERC20.sol// SPDX-License-Identifier: MITpragma solidity &gt;=0.8.2&lt; 0.9.0;import &quot;./IERC20.sol&quot;;//npm install @openzeppelin/contracts@v4.8.2import &quot;@openzeppelin/contracts/utils/math/SafeMath.sol&quot;;//ERC-20合约,实现IERC-20接口contract ERC20 is IERC20 &#123; using SafeMath for uint256; string public ercName; string public ercSymbol; uint8 public ercDecimals = 18; //小数位数；以太币为18 uint256 public ercTotalSupply; mapping (address =&gt; uint256) public ercBalances; mapping (address =&gt; mapping (address =&gt; uint256)) public ercAllowances; address private owner; //构造函数 constructor(string memory _name, string memory _symbol, uint8 _decimals) &#123; ercName = _name; ercSymbol = _symbol; ercDecimals = _decimals; owner = msg.sender; &#125; //铸造代币,新定义的函数不属于IERC-20接口 function mint(address _to, uint256 amount) external &#123; require(msg.sender == owner, &quot;caller is not owner&quot;); require(_to != address(0), &quot;to is a zero address&quot;); require(amount &gt; 0, &quot;amount must &gt; 0&quot;); ercBalances[_to] = ercBalances[_to].add(amount); ercTotalSupply = ercTotalSupply.add(amount); emit Transfer(address(0), _to, amount); &#125; //销毁代币,新定义的函数不属于IERC-20接口 function burn(address _to, uint256 amount) external &#123; require(msg.sender == owner, &quot;caller is not owner&quot;); require(_to != address(0), &quot;to is a zero address&quot;); require(amount &gt; 0, &quot;amount must &gt; 0&quot;); ercBalances[_to] = ercBalances[_to].sub(amount); ercTotalSupply = ercTotalSupply.sub(amount); emit Transfer(_to, address(0), amount); &#125; function name() override external view returns (string memory) &#123; return ercName; &#125; function symbol() override external view returns (string memory) &#123; return ercSymbol; &#125; function decimals() override external view returns (uint8) &#123; return ercDecimals; &#125; //发行总量 function totalSupply() override external view returns (uint256) &#123; return ercTotalSupply; &#125; //账户余额 function balanceOf(address _owner) override external view returns (uint256 balance) &#123; return ercBalances[_owner]; &#125; //转账逻辑 function transfer(address _to, uint256 _value) override external returns (bool success) &#123; require(_value &gt; 0, &quot;_value must &gt; 0&quot;); require(_to != address(0), &quot;to is zero address&quot;); require(ercBalances[msg.sender] &gt;= _value, &quot;user balance not enough&quot;); ercBalances[msg.sender] = ercBalances[msg.sender].sub(_value); ercBalances[_to] = ercBalances[_to].add(_value); emit Transfer(msg.sender, _to, _value); return true; &#125; //针对授权进行转账 function transferFrom(address _from, address _to, uint256 _value) override external returns (bool success) &#123; require(ercBalances[_from] &gt;= _value, &quot;user balance not enough&quot;); require(ercAllowances[msg.sender][_from] &gt;= _value, &quot;approve balance not enough&quot;); require(_value &gt; 0, &quot;_value must &gt; 0&quot;); require(_to != address(0), &quot;_to is zero address&quot;); ercBalances[_from] = ercBalances[_from].sub(_value); ercBalances[_to] = ercBalances[_to].add(_value); ercAllowances[_from][msg.sender] = ercAllowances[_from][msg.sender].sub(_value); emit Transfer(_from, _to, _value); return true; &#125; //授权函数 function approve(address _spender, uint256 _value) override external returns (bool success) &#123; require(_value &gt; 0, &quot;_value must &gt; 0&quot;); require(_spender != address(0), &quot;_spender is zero address&quot;); require(ercBalances[msg.sender] &gt;= _value, &quot;user balance not enough&quot;); ercAllowances[msg.sender][_spender] = _value; emit Approval(msg.sender, _spender, _value); return true; &#125; //owner授权给spender余额 function allowance(address _owner, address _spender) override external view returns (uint256 remaining) &#123; return ercAllowances[_owner][_spender]; &#125;&#125; 3 使用OpenZeppelin库实现代币合约OpenZeppelin库根据IERC-20接口也实现了ERC-20合约逻辑，借助OpenZeppelin库合约程序开发自己的代币合约，只需继承该库合约即可； 1234567891011121314151617181920// author:hqd8080// contracts/MyToken.sol// SPDX-License-Identifier: MITpragma solidity &gt;=0.8.2&lt; 0.9.0;import &quot;@openzeppelin/contracts/token/ERC20/ERC20.sol&quot;;//自定义MyToken合约，继承openzeppelin库的ERC20合约contract MyToken is ERC20 &#123; //构造函数 constructor(string memory name, string memory symbol) ERC20(name, symbol) &#123; //铸造100枚自定义代币，** 为指定代币数量 _mint(msg.sender, 100 * 10 ** uint256(decimals())); &#125;&#125;上面MyToken合约继承了openzeppelin库的ERC-20合约，并编写了初始化合约的构造函数，大大提高了代币的发布效率；还可以根据实际的业务需求编写其他业务逻辑实现；","categories":[{"name":"区块链","slug":"区块链","permalink":"https://hqd8080.github.io/categories/%E5%8C%BA%E5%9D%97%E9%93%BE/"}],"tags":[{"name":"区块链","slug":"区块链","permalink":"https://hqd8080.github.io/tags/%E5%8C%BA%E5%9D%97%E9%93%BE/"},{"name":"Blockchain","slug":"Blockchain","permalink":"https://hqd8080.github.io/tags/Blockchain/"},{"name":"Ethereum","slug":"Ethereum","permalink":"https://hqd8080.github.io/tags/Ethereum/"},{"name":"Solidity","slug":"Solidity","permalink":"https://hqd8080.github.io/tags/Solidity/"}]},{"title":"go-zero（四）日志输出格式配置","slug":"go-zero/gozero004","date":"2021-03-30T13:10:10.000Z","updated":"2024-06-07T05:26:51.392Z","comments":true,"path":"2021/03/30/go-zero/gozero004/","link":"","permalink":"https://hqd8080.github.io/2021/03/30/go-zero/gozero004/","excerpt":"","text":"两种方式配置日志输出格式 1.在配置文件etc/conf.yaml配置日志输出格式123456# 日志输出格式配置Log: ServiceName: user-api Encoding: plain Stat: false TimeFormat: 2006-01-02 15:04:05 2.在main.go文件配置日志输出格式12// 硬编码的方式配置日志输出格式logx.MustSetup(logx.LogConf&#123;Stat: false, Encoding: &quot;plain&quot;&#125;)","categories":[{"name":"go-zero","slug":"go-zero","permalink":"https://hqd8080.github.io/categories/go-zero/"}],"tags":[{"name":"golang","slug":"golang","permalink":"https://hqd8080.github.io/tags/golang/"},{"name":"go-zero","slug":"go-zero","permalink":"https://hqd8080.github.io/tags/go-zero/"}]},{"title":"go-zero（三）工具goctl生成api、rpc代码","slug":"go-zero/gozero003","date":"2021-03-30T12:10:10.000Z","updated":"2024-04-08T13:26:51.822Z","comments":true,"path":"2021/03/30/go-zero/gozero003/","link":"","permalink":"https://hqd8080.github.io/2021/03/30/go-zero/gozero003/","excerpt":"","text":"go-zero工具goctl生成api、rpc代码go-zero常用代码生成脚本 12345cat ~/.bash_profilealias apigen=&quot;goctl api go -api *.api -dir ../ --style=goZero&quot;alias rpcgen=&quot;goctl rpc protoc *.proto --go_out=../ --go-grpc_out=../ --zrpc_out=../ --style=goZero&quot; 生成单个proto文件代码 1protoc -I./ --go_out = paths = source_relative:.--go -grpc_out = paths = source_relative:.common.proto","categories":[{"name":"go-zero","slug":"go-zero","permalink":"https://hqd8080.github.io/categories/go-zero/"}],"tags":[{"name":"golang","slug":"golang","permalink":"https://hqd8080.github.io/tags/golang/"},{"name":"go-zero","slug":"go-zero","permalink":"https://hqd8080.github.io/tags/go-zero/"}]},{"title":"以太坊（三）代币协议标准ERC-20与ERC-223的区别","slug":"blockchain/blockchain-eth-erc","date":"2021-03-29T12:10:10.000Z","updated":"2024-05-26T16:22:53.845Z","comments":true,"path":"2021/03/29/blockchain/blockchain-eth-erc/","link":"","permalink":"https://hqd8080.github.io/2021/03/29/blockchain/blockchain-eth-erc/","excerpt":"","text":"ERC-20标准ERC-20标准是在2015年11月份推出的，使用这种规则的代币，表现出一种通用的和可预测的方式。简单地说，任何 ERC-20 代币都能立即兼容以太坊钱包（几乎所有支持以太币的钱包，包括Jaxx、MEW、imToken等，也支持 erc-20的代币），由于交易所已经知道这些代币是如何操作的，它们可以很容易地整合这些代币。这就意味着，在很多情况下，这些代币都是可以立即进行交易的。 ERC-20代币标准【官方文档】：https://github.com/ethereum/EIPs/blob/master/EIPS/eip-20.md ERC-20是各个代币的标准接口，ERC-20代币仅仅是以太坊代币的子集。为了充分兼容ERC-20，开发者需要将一组特定的函数（接口）集成到他们的智能合约中，以便在高层面能够执行以下操作： 获得代币总供应量 获得账户余额 转让代币 批准花费代币 ERC-20让以太坊区块链上的其他智能合约和去中心化应用之间无缝交互。一些具有部分但非所有ERC20标准功能的代币被认为是部分ERC-20兼容，这还要视其具体缺失的功能而定，但总体是它们仍然很容易与外部交互。 ERC-20标准存在的问题ERC-20标准无法通过接收方合同处理传入的交易，这是该令牌存在的最大问题，也是开发者一直希望改进的地方。ERC-20令牌无法将令牌发送给一个与这些令牌不兼容的契约，也正因为这样，部分资金存在丢失的风险。Reddit上的一篇文章指出，由于被发送到“错误”的合同上，大约价值40万美元的ERC-20令牌被困，这对整个以太坊生态系统而言是一个巨大的威胁。 场景：将令牌直接发送给令牌的智能合同将导致资金损失，这是因为一个令牌的合同只会跟踪和分配资金。例如，当您从钱包中向另一个用户发送令牌时，该钱包将调用令牌的合约来更新数据库，所以如果您试图将令牌直接传输到令牌的合约中，那么由于该令牌的合约无法响应，所以金钱就“丢失”了。 ERC-223要解决的首要问题自从引入ERC-20令牌标准以来，几乎所有的基于以太坊的令牌都成功的接受了这个新标准。然而其自身的缺点需要及时解决，这便是ERC-223令牌诞生的原因。ERC-223令牌标准将向现有的ERC-20标准引入一个新功能，以防止意外转移的发生。 ERC-223标准ERC-223允许用户通过一个函数transfer调用，将令牌发送到合约或电子钱包地址，而不需要针对钱包交易或合约交易做不同的处理如果接收者是钱包，则ERC-223令牌传输将与ERC-20传输相同。如果接收方是合约，ERC-223令牌合约将尝试在接收方合约中调用tokenFallback函数。如果接收方没有tokenFallback函数，合约事务将失败。 tokenFallback函数是Ether事务的后备功能模拟，可用于处理传入事务。有一种方法可以将bytes _data附加到类似于连接到Ether事务的_data的令牌事务。 它将通过令牌合约，并将通过接收方合同的tokenFallback函数处理。还有一种方法可以在没有数据参数的情况下使用ERC223令牌合约传输函数，或者使用没有传输函数数据的ERC-20 ABI。 在这种情况下_data将为空字节数组。 ERC-223定义的接口12//获取总量function totalSupply() constant returns (uint256 totalSupply); 12//得到token的名字function name() constant returns (string _name); 12//得到token的符号function symbol() constant returns (bytes32 _symbol); 12//得到token的小数点后几位function decimals() constant returns (uint8 _decimals); 12//得到地址是_owner的账户的余额function balanceOf(address _owner) constant returns (uint256 balance); 1234//转移令牌function transfer(address _to, uint _value) returns (bool);function transfer(address _to, uint _value, bytes _data) returns (bool); 由于向后兼容性原因，因为ERC20传输函数没有字节参数。1、如果_to是合约，则此函数必须传输令牌并调_to中的函数tokenFallback(address,uint256,bytes)。2、如果_to（接收方合同）中没有实现tokenFallback函数，则事务必须失败，并且不会发生令牌的传输。3、如果_to是外部拥有的地址，则必须发送事务，而不尝试在_to中执行tokenFallback。4、_data可以附加到这个令牌交易中，它将永远保持在块状（需要更多的gas）。 _data可以是空的。 注意：检查_to是合约还是地址的推荐方法是组装_to的代码。 如果_to中没有代码，那么这是一个外部拥有的地址，否则就是一个合约。重要: 将在接收方合约中调用的令牌备用功能必须命名为tokenFallback，并使用参数address,uint256，bytes。 此函数必须具有0xc0ee0b8a签名。 事件12//当token转移的时候触发，合约和token一起工作event Transfer(address indexed _from, address indexed _to, uint256 indexed _value, bytes _data); 12//令牌持有者发送令牌时处理从令牌合同所调用的令牌传输的功能function tokenFallback(address _from, uint _value, bytes _data); _from是令牌发送者，_value是传入令牌的数量，_data是附加的数据，类似于Ether事务中的数据。 适用于以太交易的回退功能，并且不返回任何内容。 注意：msg.sender将是tokenFallback函数内的令牌合同。 过滤哪些令牌（通过令牌契约地址）发送可能很重要。 令牌发送者（谁发起了代币交易的人）在_from thetokenFallback函数内。 重要: 这个函数必须命名为tokenFallback，并使用参数地址uint256，字节来匹配函数签名0xc0ee0b8a。 示例代码12345678910111213141516171819202122//ERC223.solpragma solidity ^0.4.9;//ERC223contract ERC223 &#123; uint256 public totalSupply; event Transfer(address indexed from, address indexed to, uint value, bytes indexed data); function balanceOf(address who) constant returns (uint); function name() constant returns (string _name); function symbol() constant returns (string _symbol); function decimals() constant returns (uint8 _decimals); function totalSupply() constant returns (uint256 _supply); function transfer(address to, uint value) returns (bool ok); function transfer(address to, uint value, bytes data) returns (bool ok); function transfer(address to, uint value, bytes data, string custom_fallback) returns (bool ok); &#125; 123456789101112131415161718192021222324252627282930pragma solidity ^0.4.9;//ContractReceivercontract ContractReceiver &#123; struct TKN &#123; address sender; //调用合约的人 uint value; bytes data; bytes4 sig; //签名 &#125; function tokenFallback(address _from, uint _value, bytes _data)&#123; TKN memory tkn; tkn.sender = _from; tkn.value = _value; tkn.data = _data; uint32 u = uint32(_data[3]) + (uint32(_data[2]) &lt;&lt; 8) + (uint32(_data[1]) &lt;&lt; 16) + (uint32(_data[0]) &lt;&lt; 24); tkn.sig = bytes4(u); /* tkn变量是Ether交易的msg变量的模拟 * tkn.sender是发起这个令牌交易的人（类似于msg.sender） * tkn.value发送的令牌数（msg.value的类比） * tkn.data是令牌交易的数据（类似于msg.data） * tkn.sig是4字节的功能签名 * 如果令牌事务的数据是一个函数执行 */ &#125;&#125; 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131pragma solidity ^0.4.9;import &quot;./Receiver_Interface.sol&quot;;import &quot;./ERC223_Interface.sol&quot;;contract SafeMath &#123; uint256 constant public MAX_UINT256 = 0xFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF; function safeAdd(uint256 x, uint256 y) constant internal returns (uint256 z) &#123; if (x &gt; MAX_UINT256 - y) throw; return x + y; &#125; function safeSub(uint256 x, uint256 y) constant internal returns (uint256 z) &#123; if (x &lt; y) throw; return x - y; &#125; function safeMul(uint256 x, uint256 y) constant internal returns (uint256 z) &#123; if (y == 0) return 0; if (x &gt; MAX_UINT256 / y) throw; return x * y; &#125;&#125;//示例的智能合约代码contract ERC223Token is ERC223, SafeMath &#123; mapping(address =&gt; uint) balances; string public name; string public symbol; uint8 public decimals; uint256 public totalSupply; //获取token的名称 function name() constant returns (string _name) &#123; return name; &#125; //获取token的符号 function symbol() constant returns (string _symbol) &#123; return symbol; &#125; //获取token精确到小数点后的位数 function decimals() constant returns (uint8 _decimals) &#123; return decimals; &#125; //获取token的发布总量 function totalSupply() constant returns (uint256 _totalSupply) &#123; return totalSupply; &#125; //当用户或其他合同想要转移资金时调用的功能。 function transfer(address _to, uint _value, bytes _data, string _custom_fallback) returns (bool success) &#123; //如果to是合约 if(isContract(_to)) &#123; if (balanceOf(msg.sender) &lt; _value) throw; //如果当前的余额不够就抛出 balances[msg.sender] = safeSub(balanceOf(msg.sender), _value);//发送者的余额做减法 balances[_to] = safeAdd(balanceOf(_to), _value); //接收者的余额做加法 ContractReceiver receiver = ContractReceiver(_to); //初始化接收合约，构造函数参数为接收者的合约地址 receiver.call.value(0)(bytes4(sha3(_custom_fallback)), msg.sender, _value, _data); Transfer(msg.sender, _to, _value, _data); return true; &#125; else &#123; return transferToAddress(_to, _value, _data); &#125;&#125; //当用户或其他合同想要转移资金时调用的功能。 function transfer(address _to, uint _value, bytes _data) returns (bool success) &#123; if(isContract(_to)) &#123; return transferToContract(_to, _value, _data); &#125; else &#123; return transferToAddress(_to, _value, _data); &#125;&#125; //类似于ERC20传输的标准功能传输，没有_data //由于向后兼容性原因而增加 function transfer(address _to, uint _value) returns (bool success) &#123; //类似于没有_data的ERC20传输的标准功能传输 //由于向后兼容性原因而增加 bytes memory empty; if(isContract(_to)) &#123;//如果是合约 return transferToContract(_to, _value, empty); &#125; else &#123; return transferToAddress(_to, _value, empty); &#125;&#125; //组装定地址字节码。 如果存在字节码，那么_addr是一个合约 function isContract(address _addr) private returns (bool is_contract) &#123; uint length; assembly &#123; //检索目标地址上的代码大小，这需要汇编 length := extcodesize(_addr) &#125; return (length&gt;0); &#125; //当传递目标是一个地址时调用函数 function transferToAddress(address _to, uint _value, bytes _data) private returns (bool success) &#123; if (balanceOf(msg.sender) &lt; _value) throw; balances[msg.sender] = safeSub(balanceOf(msg.sender), _value); balances[_to] = safeAdd(balanceOf(_to), _value); Transfer(msg.sender, _to, _value, _data); return true; &#125; //当传递目标是一个合约时调用函数 function transferToContract(address _to, uint _value, bytes _data) private returns (bool success) &#123; if (balanceOf(msg.sender) &lt; _value) throw; balances[msg.sender] = safeSub(balanceOf(msg.sender), _value); balances[_to] = safeAdd(balanceOf(_to), _value); ContractReceiver receiver = ContractReceiver(_to); receiver.tokenFallback(msg.sender, _value, _data); //必须要调用这个回调 Transfer(msg.sender, _to, _value, _data); return true;&#125; //得到_owner的余额 function balanceOf(address _owner) constant returns (uint balance) &#123; return balances[_owner]; &#125;&#125;","categories":[{"name":"区块链","slug":"区块链","permalink":"https://hqd8080.github.io/categories/%E5%8C%BA%E5%9D%97%E9%93%BE/"}],"tags":[{"name":"区块链","slug":"区块链","permalink":"https://hqd8080.github.io/tags/%E5%8C%BA%E5%9D%97%E9%93%BE/"},{"name":"Blockchain","slug":"Blockchain","permalink":"https://hqd8080.github.io/tags/Blockchain/"},{"name":"Ethereum","slug":"Ethereum","permalink":"https://hqd8080.github.io/tags/Ethereum/"},{"name":"Solidity","slug":"Solidity","permalink":"https://hqd8080.github.io/tags/Solidity/"}]},{"title":"以太坊（二）私有链多节点搭建","slug":"blockchain/blockchain-eth-node","date":"2021-03-29T12:10:10.000Z","updated":"2024-05-24T08:43:47.063Z","comments":true,"path":"2021/03/29/blockchain/blockchain-eth-node/","link":"","permalink":"https://hqd8080.github.io/2021/03/29/blockchain/blockchain-eth-node/","excerpt":"","text":"以太坊搭建多节点和单个节点的思路是一样的，先启动各个单节点，然后通过节点发现的方式将多个节点连接起来，实现对多个节点的数据同步和后续操作； 我们以搭建两个节点并组成一个私有链网络，将两个节点分别称为node1和node2； 1 创建节点目录1234# 创建两个节点目录cd private-chainmkdir node1mkdir node2 2 分别初始化节点123456789101112131415161718&#123; &quot;config&quot;: &#123; &quot;chainId&quot;: 123, &quot;homesteadBlock&quot;: 0, &quot;eip150Block&quot;: 0, &quot;eip155Block&quot;: 0, &quot;eip158Block&quot;: 0 &#125;, &quot;alloc&quot; : &#123;&#125;, &quot;coinbase&quot; : &quot;0x0000000000000000000000000000000000000000&quot;, &quot;difficulty&quot; : &quot;0x2&quot;, &quot;extraData&quot; : &quot;&quot;, &quot;gasLimit&quot; : &quot;0xffffffff&quot;, &quot;nonce&quot; : &quot;0x0000000000000042&quot;, &quot;mixhash&quot; : &quot;0x0000000000000000000000000000000000000000000000000000000000000000&quot;, &quot;parentHash&quot; : &quot;0x0000000000000000000000000000000000000000000000000000000000000000&quot;, &quot;timestamp&quot; : &quot;0x00&quot;&#125; 123# 初始化节点geth --datadir ./node1/data init genesis.json // 初始化node1节点geth --datadir ./node2/data init genesis.json // 初始化node2节点 3 启动节点1234567891011# node1_start.sh#!/bin/bashgeth --datadir ./node1/data --networkid 8888 --nodiscover \\--port 30303 \\--http.port 8545 \\--http --http.addr 0.0.0.0 --http.vhosts &quot;*&quot; \\--http.api &quot;db,net,eth,web3,personal,debug&quot; \\--http.corsdomain &quot;*&quot; \\--rpc.enabledeprecatedpersonal \\--snapshot --allow-insecure-unlock console 2&gt;&gt; geth.log 1234567891011# node2_start.sh#!/bin/bashgeth --datadir ./node2/data --networkid 8888 --nodiscover --authrpc.port 8552 \\--port 30304 \\--http.port 8546 \\--http --http.addr 0.0.0.0 --http.vhosts &quot;*&quot; \\--http.api &quot;db,net,eth,web3,personal,debug&quot; \\--http.corsdomain &quot;*&quot; \\--rpc.enabledeprecatedpersonal \\--snapshot --allow-insecure-unlock console 2&gt;&gt; geth.log 4 查看节点信息1234# 在node2节点窗口查看节点信息&gt; admin.nodeInfo.enode&quot;enode://2f08c93824c4b68f8755867db1582281f7ba233b623f9fe4088204cabb3256d3977d318d6b9eda38d18a7c410cb747b869ab95c9bbdcd3343af75c7e786f12dd@127.0.0.1:30304?discport=0&quot; 5 手动添加节点1234567# 在node1节点窗口添加节点2&gt; admin.addPeer(&quot;enode://2f08c93824c4b68f8755867db1582281f7ba233b623f9fe4088204cabb3256d3977d318d6b9eda38d18a7c410cb747b869ab95c9bbdcd3343af75c7e786f12dd@127.0.0.1:30304?discport=0&quot;)true# 查看当前一共连接了几个节点数&gt; web3.net.peerCount1","categories":[{"name":"区块链","slug":"区块链","permalink":"https://hqd8080.github.io/categories/%E5%8C%BA%E5%9D%97%E9%93%BE/"}],"tags":[{"name":"区块链","slug":"区块链","permalink":"https://hqd8080.github.io/tags/%E5%8C%BA%E5%9D%97%E9%93%BE/"},{"name":"Blockchain","slug":"Blockchain","permalink":"https://hqd8080.github.io/tags/Blockchain/"},{"name":"Ethereum","slug":"Ethereum","permalink":"https://hqd8080.github.io/tags/Ethereum/"},{"name":"Solidity","slug":"Solidity","permalink":"https://hqd8080.github.io/tags/Solidity/"}]},{"title":"go-zero（二）代码生成工具goctl的使用","slug":"go-zero/gozero002","date":"2021-03-29T02:10:10.000Z","updated":"2024-04-08T13:27:15.069Z","comments":true,"path":"2021/03/29/go-zero/gozero002/","link":"","permalink":"https://hqd8080.github.io/2021/03/29/go-zero/gozero002/","excerpt":"","text":"go-zero代码生成工具goctl的使用go-zero生成API代码命令12345678910mkdir gozero_demo &amp;&amp; cd gozero_demomkdir -p user-api/api cd user-api/api// 创建user.api定义文件touch user.api 1234567891011121314151617181920212223syntax = &quot;v1&quot;info( author: &quot;hqd8080&quot; date: &quot;2022-09-27&quot; desc: &quot;api 语法示例及语法说明&quot;)type ( UserInfoReq &#123; UserId int64 `json:&quot;userId&quot;` &#125; UserInfoResp &#123; UserId int64 `json:&quot;userId&quot;` Nickname string `json:&quot;nickname&quot;` &#125;)service user-api&#123; @doc &quot;获取用户信息&quot; @handler userInfo post /user/info (UserInfoReq) returns (UserInfoResp)&#125; 12// 在当前目录下执行goctl api go -api *.api -dir ../ --style=gozero go-zero生成RPC代码命令1234567891011121314151617181920在项目根路径创建user-rpc目录，在目录里面创建pb文件夹，在pb文件夹里面创建user.proto文件syntax = &quot;proto3&quot;;option go_package = &quot;./pb&quot;;package pb;message GetUserInfoReq &#123; int64 id = 1;&#125;message GetUserInfoResp &#123; int64 id = 1; string nickname = 2;&#125;service usercenter &#123; rpc GetUserInfo(GetUserInfoReq) returns (GetUserInfoResp);&#125; 12在当前目录执行goctl rpc protoc *.proto --go_out=../ --go-grpc_out=../ --zrpc_out=../ --style=goZero go-zero生成model文件命令123goctl model mysql datasource -url=&quot;$&#123;username&#125;:$&#123;passwd&#125;@tcp($&#123;host&#125;:$&#123;port&#125;)/$&#123;dbname&#125;&quot; -table=&quot;$&#123;tables&#125;&quot; -dir=&quot;$&#123;modeldir&#125;&quot; -cache=true --style=goZerogoctl model mysql datasource -url=root:12345678@tcp(127.0.0.1:3306)/zerodemo -table=user -dir=./model -cache=true --style=goZero go-zero生成dockerfile文件1goctl docker -go user.go go-zero生成k8s部署文件1goctl kube deploy -name user-api -namespace go-zero -image user-api:v1.0 -o user-api.yaml -port 1001 -nodePort 31001","categories":[{"name":"go-zero","slug":"go-zero","permalink":"https://hqd8080.github.io/categories/go-zero/"}],"tags":[{"name":"golang","slug":"golang","permalink":"https://hqd8080.github.io/tags/golang/"},{"name":"go-zero","slug":"go-zero","permalink":"https://hqd8080.github.io/tags/go-zero/"}]},{"title":"以太坊（一）私有链搭建","slug":"blockchain/blockchain-eth-geth","date":"2021-03-28T11:10:10.000Z","updated":"2024-05-28T15:27:00.274Z","comments":true,"path":"2021/03/28/blockchain/blockchain-eth-geth/","link":"","permalink":"https://hqd8080.github.io/2021/03/28/blockchain/blockchain-eth-geth/","excerpt":"","text":"智能合约：就是运行在以太坊这个”全球计算机”上的【进程】”，之所以有上述比喻，是因为以太坊网络的节点遍布全球，在这样的网络中运行计算就相当于在”【一台全球计算机】”中运行计算； 智能：智能合约是可以【自动运行的】 合约：以太坊的合约代码多会涉及一些【资产转移】，而现实世界中签订合同也多是伴随着【资产转移】，因此把这样的代码叫合约； 下面介绍利用【Geth】客户端搭建属于自己的区块链开发环境，通常被称为私有链； 1 macOS安装以太坊客户端Geth123456# 安装稳定版本brew tap ethereum/ethereumbrew install ethereum# 安装开发版brew install ethereum --devel 2 查看Geth安装版本12345678910# 本机安装的Geth版本是：v1.11.6geth version GethVersion: 1.11.6-stableGit Commit: ea9e62ca3db5c33aa7438ebf39c189afd53c6bf8Git Commit Date: 20230420Architecture: amd64Go Version: go1.20.3Operating System: darwin 3 创建创世区块配置文件1genesis.json 123456789101112131415161718&#123; &quot;config&quot;: &#123; &quot;chainId&quot;: 88888, &quot;homesteadBlock&quot;: 0, &quot;eip150Block&quot;: 0, &quot;eip155Block&quot;: 0, &quot;eip158Block&quot;: 0 &#125;, &quot;alloc&quot; : &#123;&#125;, &quot;coinbase&quot; : &quot;0x0000000000000000000000000000000000000000&quot;, &quot;difficulty&quot; : &quot;0x2&quot;, &quot;extraData&quot; : &quot;&quot;, &quot;gasLimit&quot; : &quot;0xffffffff&quot;, &quot;nonce&quot; : &quot;0x0000000000000042&quot;, &quot;mixhash&quot; : &quot;0x0000000000000000000000000000000000000000000000000000000000000000&quot;, &quot;parentHash&quot; : &quot;0x0000000000000000000000000000000000000000000000000000000000000000&quot;, &quot;timestamp&quot; : &quot;0x00&quot;&#125; 4 配置文件参数说明123456789coinbase： 旷工的账号，可任意填写 0x0000000000000000000000000000000000000000difficulty： 设置当前区块的难度，开发环境建议设置较小的难度值 0x2extraData： 附加信息，可任意填写 &quot;&quot;gasLimit： 设置Gas消耗总量的限制，限制区块链能包含的交易信息总和，开发环境建议设置最大值 0xffffffffnonce： 64位的随机数，用于挖矿 0x0000000000000042mixhash： 由上个区块一部分生成的哈希值，与 nonce 配合用于挖坑 0x0000000000000000000000000000000000000000000000000000000000000000parentHash： 上个区块的哈希值，因为是创世区块，这个值填0 0x0000000000000000000000000000000000000000000000000000000000000000timestamp： 创世区块的时间戳 0x00 5 使用配置初始化区块链12345678910cd private-chaintree -L 1 ./├── genesis.json├── geth.log├── node_data└── geth_run.sh# 初始化区块链geth --datadir ./node_data init genesis.json 6 启动私有节点123456789#!/bin/bashgeth --datadir ./node_data \\--networkid 88888 \\--http --http.addr 0.0.0.0 \\--http.vhosts &quot;*&quot; \\--http.api &quot;db,net,eth,web3,personal,debug&quot; \\--http.corsdomain &quot;*&quot; \\--rpc.enabledeprecatedpersonal \\--snapshot --allow-insecure-unlock console 2&gt;&gt; geth.log 1234567891011./geth_run.shWelcome to the Geth JavaScript console!instance: Geth/v1.11.6-stable-ea9e62ca/darwin-amd64/go1.20.3at block: 0 (Thu Jan 01 1970 08:00:00 GMT+0800 (CST)) datadir: /blockchain/private-chain/node_data modules: admin:1.0 debug:1.0 engine:1.0 eth:1.0 ethash:1.0 miner:1.0 net:1.0 rpc:1.0 txpool:1.0 web3:1.0To exit, press ctrl-d or type exit&gt; 7 Geth的JavaScript常用操作7.1 创建账号123456789# 查看所有账号列表&gt; eth.accounts # 创建一个账户&gt; personal.newAccount()Passphrase:Repeat passphrase:&quot;0xed563e9defde5e2a9b5ae2ae6f167c4b7672b32f&quot; 12345遇到的问题：ReferenceError: personal is not defined at &lt;eval&gt;:1:1(0)启动节点的时候加启动参数：--rpc.enabledeprecatedpersonal 7.2 查看账号余额12345# 查看账号余额&gt; eth.getBalance(&quot;0xed563e9defde5e2a9b5ae2ae6f167c4b7672b32f&quot;)0&gt; eth.getBalance(eth.accounts[0])0 7.3 启动和停止挖矿12345678910111213141516&gt; miner.setEtherbase(eth.accounts[0])true# 启动挖矿&gt; miner.start(1)# 停止挖矿&gt; miner.stop()# 查看挖到的以太币，单位转换成ETH&gt; web3.fromWei(eth.getBalance(eth.accounts[0]),&#x27;ether&#x27;)45000000000000000000# ETH转Wei&gt; web3.toWei(5,&#x27;ether&#x27;)&quot;5000000000000000000&quot; 7.4 发送交易1234567891011121314151617181920212223242526272829303132333435# 创建一个新账户，用于测试交易&gt; personal.newAccount()Passphrase:Repeat passphrase:&quot;0xcd4fb34be454508f4183286673f9137caa6429a8&quot;# 解锁账户，如果被锁住的话&gt; personal.unlockAccount(&quot;0xcd4fb34be454508f4183286673f9137caa6429a8&quot;)Unlock account 0xcd4fb34be454508f4183286673f9137caa6429a8Passphrase:true# 发送交易&gt; eth.sendTransaction(&#123;from:eth.accounts[0],to:&quot;0xcd4fb34be454508f4183286673f9137caa6429a8&quot;,value:5000000000000000000&#125;)&quot;0x59721b01c3508d160f4ab7939d656a9cac3f019d1e59822d3316a3a570c36ce5&quot;# 查看交易状态&gt; txpool.status&#123; pending: 1, queued: 0&#125;# 要使交易被处理必须要挖矿&gt; miner.setEtherbase(eth.accounts[0])true&gt; miner.start(1);admin.sleepBlocks(1);miner.stop();null# 再次查看交易状态&gt; txpool.status&#123; pending: 0, queued: 0&#125; 7.5 查看区块和交易12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849# 查看当前区块总数&gt; eth.blockNumber11# 通过区块的高度查看区块信息&gt; eth.getBlock(10)&#123; difficulty: 131072, extraData: &quot;0xd983010b06846765746888676f312e32302e338664617277696e&quot;, gasLimit: 4253208113, gasUsed: 21000, hash: &quot;0xffa6fbb05108a418ef1338e9aa302b2a35098ebe182a6dcdf602d41d5dcbdc0e&quot;, logsBloom: &quot;0x00000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000&quot;, miner: &quot;0x075e399630896d443f1d61ca5398209497dbbde3&quot;, mixHash: &quot;0xb50716b2cee9dfde25055337c9796bc0364861cb609a5aa2909ff26855cc19ff&quot;, nonce: &quot;0x34282181d0cff31d&quot;, number: 10, parentHash: &quot;0x73a0168d3f1f0c4ed77ae9d95747657fefe795500bce33041c919e70a2bdc931&quot;, receiptsRoot: &quot;0xf1a563d34902071f84087715cf7f863d133438bfe2e7bc2045c3214bf9a87fe0&quot;, sha3Uncles: &quot;0x1dcc4de8dec75d7aab85b567b6ccd41ad312451b948a7413f0a142fd40d49347&quot;, size: 652, stateRoot: &quot;0x2f236845deccf8a3abf063fa849dc609c65e3334fc6cc3d9df27624a73a570c1&quot;, timestamp: 1716535481, totalDifficulty: 1313026, transactions: [&quot;0x59721b01c3508d160f4ab7939d656a9cac3f019d1e59822d3316a3a570c36ce5&quot;], transactionsRoot: &quot;0xf53d90595d6595d9463ef610426e7a71249f9705a52ff349007499ff04fb59be&quot;, uncles: []&#125;# 根据交易哈希查看交易信息&gt; eth.getTransaction(&quot;0x4c53664dbb0b14147525b59192ab80abdd01bb335e2638bcee1111b61e19f1ff&quot;)&#123; blockHash: &quot;0xa88ec11a52573a8c9ca01df8ed14be0c7ad3e4503c10258841b8d01893f0fdce&quot;, blockNumber: 11, chainId: &quot;0x3039&quot;, from: &quot;0x075e399630896d443f1d61ca5398209497dbbde3&quot;, gas: 21000, gasPrice: 1000000000, hash: &quot;0x4c53664dbb0b14147525b59192ab80abdd01bb335e2638bcee1111b61e19f1ff&quot;, input: &quot;0x&quot;, nonce: 1, r: &quot;0x2239d302c2ba666b292f675db5683ed74a07ae1200bb80d07674cc2939e17c9c&quot;, s: &quot;0x3452e2c214128d6f2d4bba0041b720ccd3cdee3e330dc277cc101e7341f5c0ad&quot;, to: &quot;0xcd4fb34be454508f4183286673f9137caa6429a8&quot;, transactionIndex: 0, type: &quot;0x0&quot;, v: &quot;0x6095&quot;, value: 5000000000000000000&#125;","categories":[{"name":"区块链","slug":"区块链","permalink":"https://hqd8080.github.io/categories/%E5%8C%BA%E5%9D%97%E9%93%BE/"}],"tags":[{"name":"区块链","slug":"区块链","permalink":"https://hqd8080.github.io/tags/%E5%8C%BA%E5%9D%97%E9%93%BE/"},{"name":"Blockchain","slug":"Blockchain","permalink":"https://hqd8080.github.io/tags/Blockchain/"},{"name":"Ethereum","slug":"Ethereum","permalink":"https://hqd8080.github.io/tags/Ethereum/"},{"name":"Solidity","slug":"Solidity","permalink":"https://hqd8080.github.io/tags/Solidity/"}]},{"title":"MySQL5.7版本sql_mode=only_full_group_by问题解决","slug":"MySQL/mysql-only-full-group-by","date":"2021-03-28T02:10:10.000Z","updated":"2022-11-19T08:11:51.986Z","comments":true,"path":"2021/03/28/MySQL/mysql-only-full-group-by/","link":"","permalink":"https://hqd8080.github.io/2021/03/28/MySQL/mysql-only-full-group-by/","excerpt":"","text":"MySQL5.7版本sql_mode=only_full_group_by问题 MySQL5.7.x版本，默认是开启了only_full_group_by模式的，但开启这个模式后，原先的group by语句就报错，然后又把它移除了 一旦开启only_full_group_by，感觉group by将变成和distinct一样，只能获取受到其影响的字段信息，无法和其他未受其影响的字段共存，这样group by的功能将变得十分狭窄了 only_full_group_by 模式开启比较好 因为在 mysql 中有一个函数：any_value(field) 允许，非分组字段的出现（和关闭only_full_group_by模式有相同效果） 具体出错提示： 1[Err] 1055 - Expression #1 of ORDER BY clause is not in GROUP BY clause and contains nonaggregated column &#x27;information_schema.PROFILING.SEQ&#x27; which is not functionally dependent on columns in GROUP BY clause; this is incompatible with sql_mode=only_full_group_by 1、查看sql_mode 1select @@global.sql_mode; 查询出来的值为： 1ONLY_FULL_GROUP_BY,STRICT_TRANS_TABLES,NO_ZERO_IN_DATE,NO_ZERO_DATE,ERROR_FOR_DIVISION_BY_ZERO,NO_AUTO_CREATE_USER,NO_ENGINE_SUBSTITUTION; 2、去掉ONLY_FULL_GROUP_BY，重新设置值 1set @@global.sql_mode =&#x27;STRICT_TRANS_TABLES,NO_ZERO_IN_DATE,NO_ZERO_DATE,ERROR_FOR_DIVISION_BY_ZERO,NO_AUTO_CREATE_USER,NO_ENGINE_SUBSTITUTION&#x27;; 3、上面是改变了全局sql_mode，对于新建的数据库有效。对于已存在的数据库，则需要在对应的数据下执行： 1set sql_mode =&#x27;STRICT_TRANS_TABLES,NO_ZERO_IN_DATE,NO_ZERO_DATE,ERROR_FOR_DIVISION_BY_ZERO,NO_AUTO_CREATE_USER,NO_ENGINE_SUBSTITUTION&#x27;; 解决办法大致有两种： 1：在sql查询语句中不需要group by的字段上使用any_value()函数 这种对于已经开发了不少功能的项目不太合适，毕竟要把原来的sql都给修改一遍 2：修改my.cnf（windows下是my.ini）配置文件，删掉only_full_group_by这一项 若我们项目的mysql安装在ubuntu上面，找到这个文件打开一看，里面并没有sql_mode这一配置项，想删都没得删。 当然，还有别的办法，打开mysql命令行，执行命令 1select @@sql_mode; 这样就可以查出sql_mode的值，复制这个值，在my.cnf中添加配置项（把查询到的值删掉only_full_group_by这个选项，其他的都复制过去） 1sql_mode=STRICT_TRANS_TABLES,NO_AUTO_CREATE_USER,NO_ENGINE_SUBSTITUTION; 如果[mysqld]这行被注释掉的话记得要打开注释，然后重重启mysql服务 注：使用命令 1set sql_mode=STRICT_TRANS_TABLES,NO_AUTO_CREATE_USER,NO_ENGINE_SUBSTITUTION 这样可以修改一个会话中的配置项，在其他会话中是不生效的","categories":[{"name":"MySQL","slug":"MySQL","permalink":"https://hqd8080.github.io/categories/MySQL/"}],"tags":[{"name":"MySQL","slug":"MySQL","permalink":"https://hqd8080.github.io/tags/MySQL/"}]},{"title":"go-zero（一）微服务框架学习笔记","slug":"go-zero/gozero001","date":"2021-03-28T02:10:10.000Z","updated":"2024-04-08T13:27:37.245Z","comments":true,"path":"2021/03/28/go-zero/gozero001/","link":"","permalink":"https://hqd8080.github.io/2021/03/28/go-zero/gozero001/","excerpt":"","text":"Go语言微服务框架go-zero学习笔记使用 go-zero 的好处： 轻松获得支撑千万日活服务的稳定性 内建级联超时控制、限流、自适应熔断、自适应降载等微服务治理能力，无需配置和额外代码 微服务治理中间件可无缝集成到其它现有框架使用 极简的 API 描述，一键生成各端代码 自动校验客户端请求参数合法性 大量微服务治理和并发工具包 go-zero 框架设计思考： 对于微服务框架的设计，我们期望保障微服务稳定性的同时，也要特别注重研发效率。所以设计之初，我们就有如下一些准则： 保持简单，第一原则 弹性设计，面向故障编程 工具大于约定和文档 高可用 高并发 易扩展 对业务开发友好，封装复杂度 约束做一件事只有一种方式 go-zero 项目实现和特点： go-zero 是一个集成了各种工程实践的包含 web 和 rpc 框架，有如下主要特点： 强大的工具支持，尽可能少的代码编写 极简的接口 完全兼容 net/http 支持中间件，方便扩展 高性能 面向故障编程，弹性设计 内建服务发现、负载均衡 内建限流、熔断、降载，且自动触发，自动恢复 API 参数自动校验 超时级联控制 自动缓存控制 链路跟踪、统计报警等 高并发支撑，稳定保障了疫情期间每天的流量洪峰 项目架构图 开发环境安装安装goctl工具12// Go 1.16 及以后版本GOPROXY=https://goproxy.cn/,direct go install github.com/zeromicro/go-zero/tools/goctl@latest 设置环境变量123456789101112sudo vim ~/.bash_profile# golangexport GOROOT=/usr/local/goexport GOPATH=/Users/hqd/goexport GOPROXY=https://goproxy.cn,directexport GOSUMDB=sum.golang.google.cnexport GO111MODULE=onexport GOPRIVATE=*gitee.comexport PATH=$GOROOT/bin:$GOPATH/bin:$PATHsource ~/.bash_profile 查看版本goctl -v 安装protobuf工具、protoc-gen-go、protoc-gen-go-grpc去github官网下载相应版本最新版本到本地解压拿到可执行文件protoc https://github.com/protocolbuffers/protobuf/releases 123sudo mv protoc /usr/local/binsudo chmod +x /usr/local/bin/protoc 123protoc --versionlibprotoc 3.20.2 12345678protoc &gt;= 3.13.0 如果没安装请先安装 https://github.com/protocolbuffers/protobuf，下载解压到$GOPATH/bin下即可，前提是$GOPATH/bin已经加入$PATH中protoc-gen-go 如果没有安装请先安装 go install google.golang.org/protobuf/cmd/protoc-gen-go@latestprotoc-gen-go-grpc如果没有安装请先安装 go install google.golang.org/grpc/cmd/protoc-gen-go-grpc@latest","categories":[{"name":"go-zero","slug":"go-zero","permalink":"https://hqd8080.github.io/categories/go-zero/"}],"tags":[{"name":"golang","slug":"golang","permalink":"https://hqd8080.github.io/tags/golang/"},{"name":"go-zero","slug":"go-zero","permalink":"https://hqd8080.github.io/tags/go-zero/"}]},{"title":"在 Kubernetes 集群中部署 Java 项目","slug":"kubernetes/0009","date":"2021-03-09T12:30:10.000Z","updated":"2023-01-03T14:43:45.157Z","comments":true,"path":"2021/03/09/kubernetes/0009/","link":"","permalink":"https://hqd8080.github.io/2021/03/09/kubernetes/0009/","excerpt":"","text":"在 Kubernetes 集群中部署 Java 项目1.1 k8s 部署 java 项目流程 制作镜像【Dockerfile】 上传到镜像仓库【Dockerhub、阿里云、网易】 控制器部署镜像【Deployment】 对外暴露应用【Service、Ingress】 运维【监控、升级】 1.2 制作 Jar 包123456789101112131415161718192021project/└── demojenkins ├── demojenkins.iml ├── Dockerfile ├── HELP.md ├── mvnw ├── mvnw.cmd ├── pom.xml ├── src │ ├── main │ └── test ## 使用 java 和 Maven 进行打包 ## 使用 java （springboot）进行打包 └── target # jar 包 ├── classes ├── generated-sources ├── generated-test-sources ├── maven-archiver ├── maven-status ├── surefire-reports ├── demojenkins.jar ## jar 包 1.3 制作镜像 Dockerfile1234FROM openjdk:8-jdk-alpineVOLUME /tmpADD ./target/demojenkins.jar demojenkins.jarENTRYPOINT [&quot;java&quot;,&quot;-jar&quot;,&quot;/demojenkins.jar&quot;, &quot;&amp;&quot;] 打包镜像： 12cd javaproject/demojenkins/docker build -t java-demo-01:latest . 测试镜像容器： 1docker run -d -p 8111:8111 java-demo-01:latest -t 上传到镜像仓库：（本地仓库） 12345678910111213141516## 搭建私人仓库mkdir -p /data/myregistrydocker pull registry:latestdocker run -d -p 5000:5000 --name my_registry --restart=always -v /data/myregistry:/var/lib/registry registry:latest## 更改 docker 配置文件（在需要连接到私有仓库的机器上全部都执行一遍）## 在 k8smaster k8snode1 k8snode2 上均执行一遍cat &gt; /etc/docker/daemon.json &lt;&lt; EOF&#123; &quot;registry-mirrors&quot;: [&quot;https://b9pmyelo.mirror.aliyuncs.com&quot;], &quot;insecure-registries&quot;: [&quot;192.168.60.151:5000&quot;]&#125;EOF## 重启 docker，重启 registry（如果停止了的话）systemctl restart docker # 3 台机器上执行docker start my_registry # 主节点上执行（因为私人仓库在主节点上） 测试本地私有仓库： 12docker tag java-demo-01 192.168.60.151:5000/test/java-demo-01:v1docker push 192.168.60.151:5000/test/java-demo-01:v1 1.4 部署项目12345678910kubectl create deployment java01 --image=192.168.60.151:5000/test/java-demo-01:v1 --dry-run -o yaml &gt; java01.yamlkubectl create -f java01.yamlkubectl get pod -o widekubectl expose deployment java01 --port=8111 --target-port=8111 --type=NodePort## 查看暴露的端口[root@k8smaster test]# kubectl get svcNAME TYPE CLUSTER-IP EXTERNAL-IP PORT(S) AGEjava01 NodePort 10.109.195.123 &lt;none&gt; 8111:31954/TCP 15skubernetes ClusterIP 10.96.0.1 &lt;none&gt; 443/TCP 6d 其实不一定非要部署 jar 包 部署其他服务也是一样的，比如部署 nginx，将 index.html 换掉。（学会这个，其他的都会了） 总结一下要点： 制作项目的 docker 镜像将镜像上传到 docker 仓库使用 k8s 部署项目完 …….","categories":[{"name":"Kubernetes","slug":"Kubernetes","permalink":"https://hqd8080.github.io/categories/Kubernetes/"}],"tags":[{"name":"kubernetes","slug":"kubernetes","permalink":"https://hqd8080.github.io/tags/kubernetes/"},{"name":"k8s","slug":"k8s","permalink":"https://hqd8080.github.io/tags/k8s/"}]},{"title":"从零搭建高可用 Kubernetes 集群","slug":"kubernetes/0008","date":"2021-03-07T15:10:30.000Z","updated":"2023-01-03T14:33:10.043Z","comments":true,"path":"2021/03/07/kubernetes/0008/","link":"","permalink":"https://hqd8080.github.io/2021/03/07/kubernetes/0008/","excerpt":"","text":"从零搭建高可用 Kubernetes 集群说明：之前我们搭建的集群，只有一个 master 节点，当 master 节点宕机的时候，通过 node 节点将无法继续访问，而 master 主要是管理作用，所以整个集群将无法提供服务 1.1 高可用集群架构 在 node 节点和 master 节点之间，需要一个 LoadBalancer 组件 【作用 1】负载 【作用 2】检查 master 节点的状态 对外需要一个统一的 VIP 【作用 1】虚拟 ip 对外进行访问 1.2 高可用集群技术细节 keepalived：配置虚拟 ip，检查节点的状态 haproxy：负载均衡服务【类似于 nginx】 apiserver controller manager scheduler 1.3 高可用集群搭建我们采用 2 个 master 节点，一个 node 节点来搭建高可用集群 1.3.1 安装步骤使用二进制包方式搭建 Kubernetes 集群主要分为以下几步： 【环境准备】准备四台虚拟机，并安装操作系统 CentOS 7.x 【系统初始化】对四个刚安装好的操作系统进行初始化操作 【安装 docker、kubectl、kubeadm、kubectl】对四个节点进行安装 【配置高可用 VIP】对 master 节点安装keepalived和haproxy 【部署 master 组件】在 master 节点上安装kube-apiserver、kube-controller-manager、kube-scheduler 【安装网络插件】配置 CNI 网络插件，用于节点之间的连通 【测试集群】通过拉取一个 nginx 进行测试，能否进行外网测试 1.3.2 安装要求在开始之前，部署 Kubernetes 集群机器需要满足以下几个条件： 一台或多台机器，操作系统 CentOS7.x-86_x64 硬件配置：2GB 或更多 RAM，2 个 CPU 或更多 CPU，硬盘 30GB 或更多【注意】【注意】【注意】【master 需要两核】 可以访问外网，需要拉取镜像，如果服务器不能上网，需要提前下载镜像并导入节点 禁止 swap 分区 1.3.3 准备环境 角色 IP 配置 步骤 k8sLoadBalancer 192.168.60.150 2CPU 1G init docker kubectl kubeadm kubectl k8smaster1 192.168.60.151 2CPU 2G init docker kubectl kubeadm kubectl keepalived haproxy k8smaster2 192.168.60.152 2CPU 2G init docker kubectl kubeadm kubectl keepalived haproxy k8snode1 192.168.60.153 2CPU 2G init docker kubectl kubeadm kubectl 1.3.4 系统初始化12345678910111213141516171819202122232425262728293031323334353637383940414243444546# 关闭防火墙systemctl stop firewalld# 禁用 firewalld 服务systemctl disable firewalld# 关闭 selinux# 临时关闭【立即生效】告警，不启用，Permissive，查看使用 getenforce 命令setenforce 0 # 永久关闭【重启生效】sed -i &#x27;s/SELINUX=enforcing/\\SELINUX=disabled/&#x27; /etc/selinux/config # 关闭 swap# 临时关闭【立即生效】查看使用 free 命令swapoff -a # 永久关闭【重启生效】sed -ri &#x27;s/.*swap.*/#&amp;/&#x27; /etc/fstab# 在主机名静态查询表中添加 4 台主机cat &gt;&gt; /etc/hosts &lt;&lt; EOF192.168.60.150 k8sLoadBalancer192.168.60.151 k8smaster1192.168.60.152 k8smaster2192.168.60.153 k8snode1EOF# 将桥接的 IPv4 流量传递到 iptables 的链【3 个节点上都执行】cat &gt; /etc/sysctl.d/k8s.conf &lt;&lt; EOFnet.bridge.bridge-nf-call-ip6tables = 1net.bridge.bridge-nf-call-iptables = 1EOF# 生效sysctl --system # 时间同步yum install ntpdate -yntpdate time.windows.com# 根据规划设置主机名【k8sLoadBalancer 节点上操作】hostnamectl set-hostname k8sLoadBalancer# 根据规划设置主机名【k8smaster1 节点上操作】hostnamectl set-hostname ks8master1# 根据规划设置主机名【k8smaster2 节点上操作】hostnamectl set-hostname k8smaster2# 根据规划设置主机名【k8snode1 节点操作】hostnamectl set-hostname k8snode1 1.3.5 安装 docker、kubelet、kubeadm、kubectl所有节点安装 docker、kubelet、kubeadm、kubectl，Kubernetes 默认 CRI（容器运行时）为 docker，因此先安装 docker1、安装 docker（1）首先配置一下 docker 的阿里 yum 源 12345678cat &gt;/etc/yum.repos.d/docker.repo&lt;&lt;EOF[docker-ce-edge]name=Docker CE Edge - \\$basearchbaseurl=https://mirrors.aliyun.com/docker-ce/linux/centos/7/\\$basearch/edgeenabled=1gpgcheck=1gpgkey=https://mirrors.aliyun.com/docker-ce/linux/centos/gpgEOF （2）然后 yum 方式安装 docker 12345# yum 安装yum -y install docker-ce# 查看 docker 版本docker --version （3）配置 docker 的镜像源【阿里云】 12345cat &gt;&gt; /etc/docker/daemon.json &lt;&lt; EOF&#123; &quot;registry-mirrors&quot;: [&quot;https://b9pmyelo.mirror.aliyuncs.com&quot;]&#125;EOF （4）然后启动 docker 123systemctl start dockersystemctl enable dockersystemctl status docker 2、安装 kubeadm，kubelet 和 kubectl（1）配置 kubernetes 阿里云 yum 源 123456789cat &gt; /etc/yum.repos.d/kubernetes.repo &lt;&lt; EOF[kubernetes]name=Kubernetesbaseurl=https://mirrors.aliyun.com/kubernetes/yum/repos/kubernetes-el7-x86_64enabled=1gpgcheck=0repo_gpgcheck=0gpgkey=https://mirrors.aliyun.com/kubernetes/yum/doc/yum-key.gpg https://mirrors.aliyun.com/kubernetes/yum/doc/rpm-package-key.gpgEOF （2）yum 方式安装，由于版本更新频繁，这里指定版本号部署 1234567# 查看版本yum list kubeadm --showduplicates# 安装 kubelet、kubeadm、kubectl，同时指定版本yum install -y kubelet-1.18.0 kubeadm-1.18.0 kubectl-1.18.0# 设置开机启动【这里先不启动】systemctl enable kubelet 1.3.6 配置高可用 VIP【haproxy+keepalived】【k8smaster1 + k8smaster2 上操作】 1、安装 haproxy + keepalived我们需要在所有的 master 节点【k8smaster1 和 k8smaster2】上部署 haproxy + keepAlive 1yum install -y haproxy keepalived 2、配置 haproxy所有master节点的haproxy配置相同，haproxy 的配置文件是/etc/haproxy/haproxy.cfg 配置中声明了后端代理的两个 master 节点服务器，指定了 haproxy 运行的端口为 16443 等，因此 16443 端口为集群的入口 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374cat &gt; /etc/haproxy/haproxy.cfg &lt;&lt; EOF#---------------------------------------------------------------------# Global settings#---------------------------------------------------------------------global # to have these messages end up in /var/log/haproxy.log you will # need to: # 1) configure syslog to accept network log events. This is done # by adding the &#x27;-r&#x27; option to the SYSLOGD_OPTIONS in # /etc/sysconfig/syslog # 2) configure local2 events to go to the /var/log/haproxy.log # file. A line like the following can be added to # /etc/sysconfig/syslog # # local2.* /var/log/haproxy.log # log 127.0.0.1 local2 chroot /var/lib/haproxy pidfile /var/run/haproxy.pid maxconn 4000 user haproxy group haproxy daemon # turn on stats unix socket stats socket /var/lib/haproxy/stats#---------------------------------------------------------------------# common defaults that all the &#x27;listen&#x27; and &#x27;backend&#x27; sections will# use if not designated in their block#--------------------------------------------------------------------- defaults mode http log global option httplog option dontlognull option http-server-close option forwardfor except 127.0.0.0/8 option redispatch retries 3 timeout http-request 10s timeout queue 1m timeout connect 10s timeout client 1m timeout server 1m timeout http-keep-alive 10s timeout check 10s maxconn 3000#---------------------------------------------------------------------# kubernetes apiserver frontend which proxys to the backends#--------------------------------------------------------------------- frontend kubernetes-apiserver mode tcp bind *:16443 option tcplog default_backend kubernetes-apiserver #---------------------------------------------------------------------# round robin balancing between the various backends#---------------------------------------------------------------------backend kubernetes-apiserver mode tcp balance roundrobin server k8smaster1 192.168.60.151:6443 check server k8smaster2 192.168.60.152:6443 check#---------------------------------------------------------------------# collection haproxy statistics message#---------------------------------------------------------------------listen stats bind *:10080 stats auth admin:awesomePassword stats refresh 5s stats realm HAProxy\\ Statistics stats uri /admin?statsEOF 3、配置 keepalived keepalived中使用track_script机制来配置脚本进行探测kubernetes的master节点是否宕机，并以此切换节点实现高可用1）k8smaster1节点的keepalived配置文件如下所示，配置文件所在的位置/etc/keepalived/keepalived.cfg 12345678910111213141516171819202122232425262728293031323334cat &gt; /etc/keepalived/keepalived.conf &lt;&lt;EOF ! Configuration File for keepalivedglobal_defs &#123; router_id k8s&#125;vrrp_script check_haproxy &#123; script &quot;killall -0 haproxy&quot; interval 3 weight -2 fall 10 rise 2&#125;vrrp_instance VI_1 &#123; state MASTER interface ens33 mcast_src_ip 192.168.60.151 virtual_router_id 51 priority 100 advert_int 1 authentication &#123; auth_type PASS auth_pass ceb1b3ec013d66163d6ab &#125; virtual_ipaddress &#123; 192.168.60.150 &#125; track_script &#123; check_haproxy &#125;&#125;EOF 需要注意几点（前两点记得修改）： mcast_src_ip：配置多播源地址，此地址是当前主机的 ip 地址 priority：keepalived根据此项参数的大小仲裁master节点。我们这里让 master 节点为kubernetes提供服务，其他两个节点暂时为备用节点。因此k8smaster1节点设置为100，k8smaster2节点设置为99 state：我们将k8smaster1节点的state字段设置为MASTER，其他节点字段修改为BACKUP上面的集群检查功能是关闭的，等到集群建立完成后再开启 （2）配置 k8smaster2 节点 12345678910111213141516171819202122232425262728293031323334cat &gt; /etc/keepalived/keepalived.conf &lt;&lt;EOF ! Configuration File for keepalivedglobal_defs &#123; router_id k8s&#125;vrrp_script check_haproxy &#123; script &quot;killall -0 haproxy&quot; interval 3 weight -2 fall 10 rise 2&#125;vrrp_instance VI_1 &#123; state BACKUP interface ens33 mcast_src_ip 192.168.60.152 virtual_router_id 51 priority 99 advert_int 1 authentication &#123; auth_type PASS auth_pass ceb1b3ec013d66163d6ab &#125; virtual_ipaddress &#123; 192.168.60.150 &#125; track_script &#123; check_haproxy &#125;&#125;EOF 4、启动和检查 【k8smaster1 和 k8smaster2 均要启动】 123456789101112131415161718192021# 启动 haproxysystemctl start haproxysystemctl enable haproxysystemctl status haproxy# 启动 keepalivedsystemctl start keepalived.servicesystemctl enable keepalived.servicesystemctl status keepalived.service# 启动后查看 master 网卡信息ip a s ens33# 检查是否可以 ping 通ping 192.168.60.150# 如果出错# 初始化一下！！！并重新启动！！！systemctl stop firewalldsetenforce 0 swapoff -a 1.3.7 部署 Kubernetes Master 组件【k8smaster1 + k8smaster2 + k8snode1 上操作】 1、k8smaster1 节点（1）初始化操作 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182# 导出初始化配置文件，然后修改配置，再进行初始化kubeadm config print init-defaults &gt; kubeadm-init.yaml# 这里直接写入配置，并初始化cat &gt; kubeadm-init.yaml &lt;&lt; EOFapiVersion: kubeadm.k8s.io/v1beta2bootstrapTokens:- groups: - system:bootstrappers:kubeadm:default-node-token token: abcdef.0123456789abcdef ttl: 24h0m0s usages: - signing - authenticationkind: InitConfigurationlocalAPIEndpoint: advertiseAddress: 192.168.60.150 # k8sLoadBalancer ip bindPort: 6443nodeRegistration: criSocket: /var/run/dockershim.sock name: k8sloadbalancer taints: - effect: NoSchedule key: node-role.kubernetes.io/master---apiServer: # 添加两行配置 certSANs: - &quot;192.168.60.150&quot; # k8sLoadBalancer ip 即 VIP 的地址 timeoutForControlPlane: 4m0sapiVersion: kubeadm.k8s.io/v1beta2certificatesDir: /etc/kubernetes/pkiclusterName: kubernetescontrollerManager: &#123;&#125;dns: type: CoreDNSetcd: local: dataDir: /var/lib/etcdimageRepository: registry.cn-hangzhou.aliyuncs.com/google_containers # 阿里云的镜像站点controlPlaneEndpoint: &quot;192.168.60.150:16443&quot; # VIP 的地址和端口kind: ClusterConfigurationkubernetesVersion: v1.18.0networking: dnsDomain: cluster.local serviceSubnet: 10.96.0.0/12 podSubnet: 10.244.0.0/16 # 添加 pod 网段scheduler: &#123;&#125;EOF# 直接 kubeadm init 初始化，中间会拉取镜像，速度较慢，分为两步来做# （1）提前拉取镜像kubeadm config images pull --config kubeadm-init.yaml# （2）初始化kubeadm init --config kubeadm-init.yaml --upload-certs####### 初始化结果 ########Your Kubernetes control-plane has initialized successfully!To start using your cluster, you need to run the following as a regular user: mkdir -p $HOME/.kube sudo cp -i /etc/kubernetes/admin.conf $HOME/.kube/config sudo chown $(id -u):$(id -g) $HOME/.kube/configYou should now deploy a pod network to the cluster.Run &quot;kubectl apply -f [podnetwork].yaml&quot; with one of the options listed at: https://kubernetes.io/docs/concepts/cluster-administration/addons/You can now join any number of the control-plane node running the following command on each as root: kubeadm join 192.168.60.150:16443 --token abcdef.0123456789abcdef \\ --discovery-token-ca-cert-hash sha256:68d59df77d9109c44a60a8ca4e7f0932d8cd270c5d0a8adc83c9a1a7d72de73a \\ --control-plane --certificate-key b84d54cf9015ef8252e38d68ae96be4b7e41fc9380d8dc2b9ac9ae916b0e9cdaPlease note that the certificate-key gives access to cluster sensitive data, keep it secret!As a safeguard, uploaded-certs will be deleted in two hours; If necessary, you can use&quot;kubeadm init phase upload-certs --upload-certs&quot; to reload certs afterward.Then you can join any number of worker nodes by running the following on each as root:kubeadm join 192.168.60.150:16443 --token abcdef.0123456789abcdef \\ --discovery-token-ca-cert-hash sha256:68d59df77d9109c44a60a8ca4e7f0932d8cd270c5d0a8adc83c9a1a7d72de73a （2）按照提示信息，执行下方命令 1234567891011121314151617181920212223# 执行下方命令mkdir -p $HOME/.kubesudo cp -i /etc/kubernetes/admin.conf $HOME/.kube/configsudo chown $(id -u):$(id -g) $HOME/.kube/config# 查看节点kubectl get nodes# 查看 podkubectl get pods -n kube-system## 输出结果[root@ks8master1 ~]# kubectl get nodesNAME STATUS ROLES AGE VERSIONk8sloadbalancer NotReady master 3m58s v1.18.0[root@ks8master1 ~]# kubectl get pods -n kube-systemNAME READY STATUS RESTARTS AGEcoredns-546565776c-skjzz 0/1 Pending 0 3m50scoredns-546565776c-xm8wf 0/1 Pending 0 3m50setcd-k8sloadbalancer 1/1 Running 0 4m5skube-apiserver-k8sloadbalancer 1/1 Running 0 4m5skube-controller-manager-k8sloadbalancer 1/1 Running 0 4m5skube-proxy-gbjmm 1/1 Running 0 3m48skube-scheduler-k8sloadbalancer 1/1 Running 0 4m5s 2、k8smaster2 节点按照k8smaster1提示信息，将k8smaster2加入集群 12345678910# k8smaster2 加入集群kubeadm join 192.168.60.150:16443 --token abcdef.0123456789abcdef \\ --discovery-token-ca-cert-hash sha256:68d59df77d9109c44a60a8ca4e7f0932d8cd270c5d0a8adc83c9a1a7d72de73a \\ --control-plane --certificate-key b84d54cf9015ef8252e38d68ae96be4b7e41fc9380d8dc2b9ac9ae916b0e9cda # 查看集群状态kubectl get cs# 查看 podkubectl get pods -n kube-system 3、k8snode1 节点按照k8smaster1提示信息，将k8snode1加入集群 12kubeadm join 192.168.60.150:16443 --token abcdef.0123456789abcdef \\ --discovery-token-ca-cert-hash sha256:68d59df77d9109c44a60a8ca4e7f0932d8cd270c5d0a8adc83c9a1a7d72de73a 1.3.8 安装集群网络从官方地址获取到 flannel 的 yaml，在 k8smaster1 上执行 12345678910111213141516171819202122232425262728# 下载 yaml 文件wget -c https://raw.githubusercontent.com/coreos/flannel/master/Documentation/kube-flannel.yml# 安装 flannel 网络kubectl apply -f kube-flannel.yml # 检查kubectl get pods -n kube-system## 可以看到 kube-flannel 正在安装[root@ks8master1 ~]# kubectl get pods -n kube-systemNAME READY STATUS RESTARTS AGEcoredns-546565776c-skjzz 0/1 Pending 0 21mcoredns-546565776c-xm8wf 0/1 Pending 0 21metcd-k8sloadbalancer 1/1 Running 2 21metcd-k8smaster2 1/1 Running 0 7m58skube-apiserver-k8sloadbalancer 1/1 Running 3 21mkube-apiserver-k8smaster2 1/1 Running 1 7m58skube-controller-manager-k8sloadbalancer 1/1 Running 2 21mkube-controller-manager-k8smaster2 1/1 Running 1 7m58skube-flannel-ds-cv84g 0/1 Init:1/2 0 91skube-flannel-ds-j9mbn 0/1 Init:1/2 0 91skube-flannel-ds-qplqm 0/1 Init:1/2 0 91skube-proxy-gbjmm 1/1 Running 0 21mkube-proxy-qqdl5 1/1 Running 0 13mkube-proxy-s8bvq 1/1 Running 0 6m27skube-scheduler-k8sloadbalancer 1/1 Running 2 21mkube-scheduler-k8smaster2 1/1 Running 1 7m58s 1.3.9 测试 kubernetes 集群在 Kubernetes 集群中创建一个 pod，验证是否正常运行： 12345678910111213141516# 创建 nginx deploymentkubectl create deployment nginx --image=nginx# 暴露端口kubectl expose deployment nginx --port=80 --type=NodePort# 查看状态kubectl get pod,svc## [ip:port]# 浏览器访问：# 192.168.60.151:32594# 192.168.60.152:32594# 192.168.60.153:32594[root@ks8master1 ~]# kubectl get pod,svcNAME TYPE CLUSTER-IP EXTERNAL-IP PORT(S) AGEservice/kubernetes ClusterIP 10.96.0.1 &lt;none&gt; 443/TCP 24mservice/nginx NodePort 10.109.174.226 &lt;none&gt; 80:32594/TCP 8s 然后我们通过任何一个节点，都能够访问我们的 nginx 页面","categories":[{"name":"Kubernetes","slug":"Kubernetes","permalink":"https://hqd8080.github.io/categories/Kubernetes/"}],"tags":[{"name":"kubernetes","slug":"kubernetes","permalink":"https://hqd8080.github.io/tags/kubernetes/"},{"name":"k8s","slug":"k8s","permalink":"https://hqd8080.github.io/tags/k8s/"}]},{"title":"Kubernetes 集群监控 Grafana 可视化部署","slug":"kubernetes/0007","date":"2021-03-06T11:30:01.000Z","updated":"2023-11-01T01:19:40.174Z","comments":true,"path":"2021/03/06/kubernetes/0007/","link":"","permalink":"https://hqd8080.github.io/2021/03/06/kubernetes/0007/","excerpt":"","text":"Kubernetes 集群监控Grafana可视化部署1.1 部署 Grafana1.1.1 Deploymentvim grafana-deploy.yaml 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556apiVersion: apps/v1kind: Deploymentmetadata: name: grafana-core namespace: kube-system labels: app: grafana component: corespec: replicas: 1 selector: matchLabels: app: grafana component: core template: metadata: labels: app: grafana component: core spec: containers: - image: grafana/grafana:4.2.0 name: grafana-core imagePullPolicy: IfNotPresent # env: resources: # keep request = limit to keep this container in guaranteed class limits: cpu: 100m memory: 100Mi requests: cpu: 100m memory: 100Mi env: # The following env variables set up basic auth twith the default admin user and admin password. - name: GF_AUTH_BASIC_ENABLED value: &quot;true&quot; - name: GF_AUTH_ANONYMOUS_ENABLED value: &quot;false&quot; # - name: GF_AUTH_ANONYMOUS_ORG_ROLE # value: Admin # does not really work, because of template variables in exported dashboards: # - name: GF_DASHBOARDS_JSON_ENABLED # value: &quot;true&quot; readinessProbe: httpGet: path: /login port: 3000 # initialDelaySeconds: 30 # timeoutSeconds: 1 volumeMounts: - name: grafana-persistent-storage mountPath: /var volumes: - name: grafana-persistent-storage emptyDir: &#123;&#125; 1.1.2 Servicevim grafana-svc.yaml 123456789101112131415apiVersion: v1kind: Servicemetadata: name: grafana namespace: kube-system labels: app: grafana component: corespec: type: NodePort ports: - port: 3000 selector: app: grafana component: core 1.1.3 Runingvim grafana-ing.yaml 1234567891011121314apiVersion: extensions/v1beta1kind: Ingressmetadata: name: grafana namespace: kube-systemspec: rules: - host: k8s.grafana http: paths: - path: / backend: serviceName: grafana servicePort: 3000 1.1.4 Creat123kubectl create -f grafana-deploy.yamlkubectl create -f grafana-svc.yamlkubectl create -f grafana-ing.yaml 1.1.5 Get123456kubectl get pod,svc -n kube-system | grep grafana# pod/grafana-core-768b6bf79c-lmq9z 1/1 Running 0 35m# service/grafana NodePort 10.99.106.133 &lt;none&gt; 3000:32389/TCP 35m# 浏览器访问：[ip:port] http://192.168.60.151:32389/# 用户名/密码：admin/admin","categories":[{"name":"Kubernetes","slug":"Kubernetes","permalink":"https://hqd8080.github.io/categories/Kubernetes/"}],"tags":[{"name":"kubernetes","slug":"kubernetes","permalink":"https://hqd8080.github.io/tags/kubernetes/"},{"name":"k8s","slug":"k8s","permalink":"https://hqd8080.github.io/tags/k8s/"},{"name":"grafana","slug":"grafana","permalink":"https://hqd8080.github.io/tags/grafana/"}]},{"title":"Kubernetes 集群监控 Prometheus 部署","slug":"kubernetes/0006","date":"2021-03-05T15:30:01.000Z","updated":"2023-11-01T01:19:40.181Z","comments":true,"path":"2021/03/05/kubernetes/0006/","link":"","permalink":"https://hqd8080.github.io/2021/03/05/kubernetes/0006/","excerpt":"","text":"Kubernetes 集群监控Prometheus部署1.1 部署 Pormetheus1.1.1 node-exportervim node-exporter.yaml 1234567891011121314151617181920212223242526272829303132333435363738394041---apiVersion: apps/v1kind: DaemonSetmetadata: name: node-exporter namespace: kube-system labels: k8s-app: node-exporterspec: selector: matchLabels: k8s-app: node-exporter template: metadata: labels: k8s-app: node-exporter spec: containers: - image: prom/node-exporter name: node-exporter ports: - containerPort: 9100 protocol: TCP name: http---apiVersion: v1kind: Servicemetadata: labels: k8s-app: node-exporter name: node-exporter namespace: kube-systemspec: ports: - name: http port: 9100 nodePort: 31672 protocol: TCP type: NodePort selector: k8s-app: node-exporter 1.1.2 rbacvim rbac-setup.yaml 123456789101112131415161718192021222324252627282930313233343536373839apiVersion: rbac.authorization.k8s.io/v1kind: ClusterRolemetadata: name: prometheusrules:- apiGroups: [&quot;&quot;] resources: - nodes - nodes/proxy - services - endpoints - pods verbs: [&quot;get&quot;, &quot;list&quot;, &quot;watch&quot;]- apiGroups: - extensions resources: - ingresses verbs: [&quot;get&quot;, &quot;list&quot;, &quot;watch&quot;]- nonResourceURLs: [&quot;/metrics&quot;] verbs: [&quot;get&quot;]---apiVersion: v1kind: ServiceAccountmetadata: name: prometheus namespace: kube-system---apiVersion: rbac.authorization.k8s.io/v1kind: ClusterRoleBindingmetadata: name: prometheusroleRef: apiGroup: rbac.authorization.k8s.io kind: ClusterRole name: prometheussubjects:- kind: ServiceAccount name: prometheus namespace: kube-system 1.1.3 ConfigMapvim configmap.yaml 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156apiVersion: v1kind: ConfigMapmetadata: name: prometheus-config namespace: kube-systemdata: prometheus.yml: | global: scrape_interval: 15s evaluation_interval: 15s scrape_configs: - job_name: &#x27;kubernetes-apiservers&#x27; kubernetes_sd_configs: - role: endpoints scheme: https tls_config: ca_file: /var/run/secrets/kubernetes.io/serviceaccount/ca.crt bearer_token_file: /var/run/secrets/kubernetes.io/serviceaccount/token relabel_configs: - source_labels: [__meta_kubernetes_namespace, __meta_kubernetes_service_name, __meta_kubernetes_endpoint_port_name] action: keep regex: default;kubernetes;https - job_name: &#x27;kubernetes-nodes&#x27; kubernetes_sd_configs: - role: node scheme: https tls_config: ca_file: /var/run/secrets/kubernetes.io/serviceaccount/ca.crt bearer_token_file: /var/run/secrets/kubernetes.io/serviceaccount/token relabel_configs: - action: labelmap regex: __meta_kubernetes_node_label_(.+) - target_label: __address__ replacement: kubernetes.default.svc:443 - source_labels: [__meta_kubernetes_node_name] regex: (.+) target_label: __metrics_path__ replacement: /api/v1/nodes/$&#123;1&#125;/proxy/metrics - job_name: &#x27;kubernetes-cadvisor&#x27; kubernetes_sd_configs: - role: node scheme: https tls_config: ca_file: /var/run/secrets/kubernetes.io/serviceaccount/ca.crt bearer_token_file: /var/run/secrets/kubernetes.io/serviceaccount/token relabel_configs: - action: labelmap regex: __meta_kubernetes_node_label_(.+) - target_label: __address__ replacement: kubernetes.default.svc:443 - source_labels: [__meta_kubernetes_node_name] regex: (.+) target_label: __metrics_path__ replacement: /api/v1/nodes/$&#123;1&#125;/proxy/metrics/cadvisor - job_name: &#x27;kubernetes-service-endpoints&#x27; kubernetes_sd_configs: - role: endpoints relabel_configs: - source_labels: [__meta_kubernetes_service_annotation_prometheus_io_scrape] action: keep regex: true - source_labels: [__meta_kubernetes_service_annotation_prometheus_io_scheme] action: replace target_label: __scheme__ regex: (https?) - source_labels: [__meta_kubernetes_service_annotation_prometheus_io_path] action: replace target_label: __metrics_path__ regex: (.+) - source_labels: [__address__, __meta_kubernetes_service_annotation_prometheus_io_port] action: replace target_label: __address__ regex: ([^:]+)(?::\\d+)?;(\\d+) replacement: $1:$2 - action: labelmap regex: __meta_kubernetes_service_label_(.+) - source_labels: [__meta_kubernetes_namespace] action: replace target_label: kubernetes_namespace - source_labels: [__meta_kubernetes_service_name] action: replace target_label: kubernetes_name - job_name: &#x27;kubernetes-services&#x27; kubernetes_sd_configs: - role: service metrics_path: /probe params: module: [http_2xx] relabel_configs: - source_labels: [__meta_kubernetes_service_annotation_prometheus_io_probe] action: keep regex: true - source_labels: [__address__] target_label: __param_target - target_label: __address__ replacement: blackbox-exporter.example.com:9115 - source_labels: [__param_target] target_label: instance - action: labelmap regex: __meta_kubernetes_service_label_(.+) - source_labels: [__meta_kubernetes_namespace] target_label: kubernetes_namespace - source_labels: [__meta_kubernetes_service_name] target_label: kubernetes_name - job_name: &#x27;kubernetes-ingresses&#x27; kubernetes_sd_configs: - role: ingress relabel_configs: - source_labels: [__meta_kubernetes_ingress_annotation_prometheus_io_probe] action: keep regex: true - source_labels: [__meta_kubernetes_ingress_scheme,__address__,__meta_kubernetes_ingress_path] regex: (.+);(.+);(.+) replacement: $&#123;1&#125;://$&#123;2&#125;$&#123;3&#125; target_label: __param_target - target_label: __address__ replacement: blackbox-exporter.example.com:9115 - source_labels: [__param_target] target_label: instance - action: labelmap regex: __meta_kubernetes_ingress_label_(.+) - source_labels: [__meta_kubernetes_namespace] target_label: kubernetes_namespace - source_labels: [__meta_kubernetes_ingress_name] target_label: kubernetes_name - job_name: &#x27;kubernetes-pods&#x27; kubernetes_sd_configs: - role: pod relabel_configs: - source_labels: [__meta_kubernetes_pod_annotation_prometheus_io_scrape] action: keep regex: true - source_labels: [__meta_kubernetes_pod_annotation_prometheus_io_path] action: replace target_label: __metrics_path__ regex: (.+) - source_labels: [__address__, __meta_kubernetes_pod_annotation_prometheus_io_port] action: replace regex: ([^:]+)(?::\\d+)?;(\\d+) replacement: $1:$2 target_label: __address__ - action: labelmap regex: __meta_kubernetes_pod_label_(.+) - source_labels: [__meta_kubernetes_namespace] action: replace target_label: kubernetes_namespace - source_labels: [__meta_kubernetes_pod_name] action: replace target_label: kubernetes_pod_name 1.1.4 Deploymentvim prometheus.deploy.yaml 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849---apiVersion: apps/v1kind: Deploymentmetadata: labels: name: prometheus-deployment name: prometheus namespace: kube-systemspec: replicas: 1 selector: matchLabels: app: prometheus template: metadata: labels: app: prometheus spec: containers: - image: prom/prometheus:v2.0.0 name: prometheus command: - &quot;/bin/prometheus&quot; args: - &quot;--config.file=/etc/prometheus/prometheus.yml&quot; - &quot;--storage.tsdb.path=/prometheus&quot; - &quot;--storage.tsdb.retention=24h&quot; ports: - containerPort: 9090 protocol: TCP volumeMounts: - mountPath: &quot;/prometheus&quot; name: data - mountPath: &quot;/etc/prometheus&quot; name: config-volume resources: requests: cpu: 100m memory: 100Mi limits: cpu: 500m memory: 2500Mi serviceAccountName: prometheus volumes: - name: data emptyDir: &#123;&#125; - name: config-volume configMap: name: prometheus-config 1.1.5 Servicevim prometheus.svc.yaml 12345678910111213141516---kind: ServiceapiVersion: v1metadata: labels: app: prometheus name: prometheus namespace: kube-systemspec: type: NodePort ports: - port: 9090 targetPort: 9090 nodePort: 30003 selector: app: prometheus 1.1.6 Create12345kubectl create -f node-exporter.yamlkubectl create -f rbac-setup.yamlkubectl create -f configmap.yamlkubectl create -f prometheus.deploy.ymlkubectl create -f prometheus.svc.yml 1.1.7 Get123456kubectl get pod,svc -n kube-system | grep prometheus# pod/prometheus-7486bf7f4b-nv2t5 1/1 Running 0 20m# service/prometheus NodePort 10.102.173.197 &lt;none&gt; 9090:30003/TCP 20m# 浏览器访问：[ip:port] 192.168.60.151:30003","categories":[{"name":"Kubernetes","slug":"Kubernetes","permalink":"https://hqd8080.github.io/categories/Kubernetes/"}],"tags":[{"name":"kubernetes","slug":"kubernetes","permalink":"https://hqd8080.github.io/tags/kubernetes/"},{"name":"k8s","slug":"k8s","permalink":"https://hqd8080.github.io/tags/k8s/"},{"name":"prometheus","slug":"prometheus","permalink":"https://hqd8080.github.io/tags/prometheus/"}]},{"title":"Kubernetes 集群安全机制","slug":"kubernetes/0005","date":"2021-03-04T10:30:01.000Z","updated":"2023-01-03T13:38:37.923Z","comments":true,"path":"2021/03/04/kubernetes/0005/","link":"","permalink":"https://hqd8080.github.io/2021/03/04/kubernetes/0005/","excerpt":"","text":"Kubernetes 集群安全机制1.Api-server Kubernetes api-server 安全访问机制 当我们访问 K8S 集群时，都需要经过 apiserver【 apiserver 做统一协调】，每个请求到达 apiserver 需要经过三个安全关卡：① 认证② 鉴权③ 准入控制 访问过程中，需要证书、token、或者用户名和密码 如果访问 pod 需要 serviceAccount 1、认证对外不暴露 8080 端口，只能内部访问，对外使用的端口 6443 客户端身份认证常用方式 https 证书认证，基于 ca 证书 http token 认证，通过 token 来识别用户 http 基本认证，用户名 + 密码认证 2、鉴权基于 RBAC 进行鉴权操作 基于角色访问控制 3、准入控制就是准入控制器的列表，如果列表有请求内容就通过，没有的话 就拒绝 2.TLSKubernetes 认证方式之客户端证书（TLS） 客户端证书（TLS）认证方式，也叫 HTTPS 双向认证。一般我们访问一个 https 网站，认证是单向的，只有客户端回验证服务端的身份，服务端不会管客户端身份如何 3.RBAC 介绍 Kubernetes 授权方式之 RBAC 基于角色的访问控制，为某个角色设置访问内容，然后用户分配该角色后，就拥有该角色的访问权限 k8s 中有默认的几个角色 role：特定命名空间访问权限 ClusterRole：所有命名空间的访问权限 角色绑定 roleBinding：角色绑定到主体 ClusterRoleBinding：集群角色绑定到主体 主体 user：用户 group：用户组 serviceAccount：服务账号 4.RBAC 鉴权1、创建命名空间 1234# 查看已经存在的命名空间kubectl get namespace# 创建自己的命名空间kubectl create ns webServer 2、命名空间内创建 Pod如果不创建命名空间，Pod 默认在 default 1kubectl run nginx --image=nginx -n webServer 3、创建角色 通过 rbac-role.yaml 进行创建tips: 这个角色只对 pod 有 get 和 list 权限 1234567891011cat &gt; rbac-role.yaml &lt;&lt; EOFkind: RoleapiVersion: rbac.authorization.k8s.io/v1metadata: namespace: mytest name: pod-readerrules:- apiGroups: [&quot;&quot;] # &quot;&quot; indicates the core API group resources: [&quot;pods&quot;] verbs: [&quot;get&quot;, &quot;watch&quot;, &quot;list&quot;]EOF 通过 yaml 创建 role 1234# 创建kubectl apply -f rbac-role.yaml# 查看kubectl get role -n mytest 4、创建角色绑定通过 rbac-rolebinding.yaml 的方式，来创建我们的角色绑定 1234567891011121314151617181920212223cat &gt; rbac-rolebinding.yaml &lt;&lt; EOFkind: RoleBindingapiVersion: rbac.authorization.k8s.io/v1metadata: namespace: mytest name: read-podssubjects:- kind: User name: lucy apiGroup: rbac.authorization.k8s.ioroleRef: kind: Role name: pod-reader apiGroup: rbac.authorization.k8s.ioEOFkubectl apply -f rbac-rolebinding.yamlkubectl get role,rolebinding -n mytest# NAME CREATED AT# role.rbac.authorization.k8s.io/pod-reader 2021-03-04T20:05:57Z# NAME ROLE AGE# rolebinding.rbac.authorization.k8s.io/read-pods Role/pod-reader 35s","categories":[{"name":"Kubernetes","slug":"Kubernetes","permalink":"https://hqd8080.github.io/categories/Kubernetes/"}],"tags":[{"name":"kubernetes","slug":"kubernetes","permalink":"https://hqd8080.github.io/tags/kubernetes/"},{"name":"k8s","slug":"k8s","permalink":"https://hqd8080.github.io/tags/k8s/"}]},{"title":"Kubernetes 配置管理","slug":"kubernetes/0004","date":"2021-03-03T14:10:40.000Z","updated":"2023-01-03T13:08:04.968Z","comments":true,"path":"2021/03/03/kubernetes/0004/","link":"","permalink":"https://hqd8080.github.io/2021/03/03/kubernetes/0004/","excerpt":"","text":"Kubernetes 配置管理1.1.1 Secret Secret 的主要作用就是加密数据 1、Secret 应用场景对 用户名 和 密码 进行加密 2、Secret 三种类型 Opaque：使用 base64 编码存储信息，可以通过 base64 –decode 解码获得原始数据，因此安全性弱 kubernetes.io/dockerconfigjson：用于存储 docker registry 的认证信息 kubernetes.io/service-account-token：用于被 serviceaccount 引用serviceaccout 创建时 Kubernetes 会默认创建对应的 secretPod 如果使用了 serviceaccount，对应的 secret 会自动挂载到 Pod 的 /run/secrets/kubernetes.io/serviceaccount 目录中 3、Secret 创建 （1）命令行方式创建 Secret 1234567891011echo -n &quot;admin&quot; &gt; ./username.txtecho -n &quot;123456&quot; &gt; ./password.txt# 使用 kubectl create secret 命令创建 secretkubectl create secret generic db-user-pass --from-file=./username.txt --from-file=./password.txt# secret/db-user-pass created# 查看 secretkubectl get secrets# NAME TYPE DATA AGE# db-user-pass Opaque 2 59s （2）yaml 文件方式创建 Secret 1234567891011121314151617181920212223242526272829echo -n &#x27;admin&#x27; | base64# YWRtaW4=echo -n &#x27;123456&#x27; | base64# MWYxZjFmMWYxZg==# 创建 secret：创建 yaml 文件cat &gt; secret.yaml &lt;&lt; EOFapiVersion: v1kind: Secretmetadata: name: mysecrettype: Opaquedata: username: YWRtaW4= password: MWYxZjFmMWYxZg==EOF# 创建 secret：使用 yaml 文件创建 secretkubectl create -f secret.yaml# secret/mysecret created# 查看 secretkubectl get secrets | grep mysecret# mysecret Opaque 2 32s# 查看 secret 详细信息kubectl describe secrets mysecret# 查看 secret yaml 文件kubectl get secrets mysecret -o yaml 4、Secret 使用【两种方式】 以 Volume 形式 以环境变量形式 （1）将 Secret 挂载到 Volume 中 12345678910111213141516171819202122232425262728293031323334cat &gt; mypod1.yaml &lt;&lt; EOFapiVersion: v1kind: Podmetadata: name: mypod1spec: containers: - name: mypod1 image: redis volumeMounts: - name: foo mountPath: &quot;/etc/foo&quot; readOnly: true volumes: - name: foo secret: secretName: mysecretEOFkubectl create -f mypod1.yaml# pod/mypod1 createdkubectl get pods | grep mypod# mypod1 1/1 Running 0 48skubectl exec -it mypod1 /bin/bash## 查看密码和用户名root@mypod1:/data# cd /etc/foo/root@mypod1:/etc/foo# lspassword usernameroot@mypod1:/etc/foo# cat password 123456root@mypod1:/etc/foo# cat username adminroot@mypod1:/etc/foo# （2）将 Secret 设置为环境变量 1234567891011121314151617181920212223242526272829303132333435cat &gt; mypod2.yaml &lt;&lt; EOFapiVersion: v1kind: Podmetadata: name: mypod2spec: containers: - name: mypod2 image: redis env: - name: SECRET_USERNAME valueFrom: secretKeyRef: name: mysecret key: username - name: SECRET_PASSWORD valueFrom: secretKeyRef: name: mysecret key: password restartPolicy: NeverEOF kubectl create -f mypod2.yaml# pod/mypod2 createdkubectl get pods | grep mypod# mypod1 1/1 Running 0 4m39s# mypod2 0/1 ContainerCreating 0 6s# 等 mypod2 running 之后在进入容器kubectl exec -it mypod2 /bin/bash## 查看环境变量root@mypod2:/data# env | grep -E &quot;USERNAME|PASSWORD&quot;SECRET_USERNAME=adminSECRET_PASSWORD=123456 1.2.1 ConfigMapConfigMap 作用是存储不加密的数据到 etcd 中1、应用场景配置文件 2、创建 1）yaml 文件方式创建 命令行方式创建 1.yaml 文件方式创建 1234567891011cat &gt; configmap-test01.yaml &lt;&lt; EOFapiVersion: v1kind: ConfigMapmetadata: name: cm-test01data: appconf01: value01 appconf02: value02EOFkubectl create -f configmap-test01.yaml 2.命令行方式创建读取文件方式（也可以是目录）通过–from-file参数从文件中读取。可以指定 key 的名称，若不指定，则默认使用文件名为 key 1234567cat &gt; test.properties &lt;&lt; EOFkey01:value01key02:value02conf01: value03EOFkubectl create cm cm-test-file --from-file=test.properties 3、查询 12345678910# 查看 configmap 列表kubectl get configmap# 查看 configmap 详情kubectl describe configmap cm-test01kubectl describe configmap cm-test-filekubectl describe cm cm-test-literal# 查看 yaml 输出kubectl get cm cm-test01 -o yamlkubectl get configmap cm-test-file -o yamlkubectl get cm cm-test-literal -o yaml 4、更新 123456# 方式一：editkubectl edit cm cm-test01# 查看更新是否生效kubectl describe cm cm-test01# 方式二：applykubectl apply -f configmap-test01.yaml 5、删除 1234# 方式一：通过 yaml 文件删除kubectl delete -f configmap-test01.yaml# 方式二：直接删除资源kubectl delete cm cm-test-file 6、使用 【yaml 文件有误，以下四种方式无误】容器应用对 ConfigMap 的使用主要是两种： 通过环境变量获取 ConfigMap 的内容：spec.env和spec.envFrom 通过卷 volume 挂载的方式将 ConfigMap 的内容挂载到容器内部的文件或目录：spec.volumes （1）spec.env 【环境变量】 1234567891011121314151617181920212223242526vim pod-test01.yamlapiVersion: v1kind: Podmetadata: name: cm-pod-test001spec: containers: - name: cm-test image: tomcat:8 command: [ &quot;/bin/sh&quot;, &quot;-c&quot;, &quot;env | grep APP&quot;] env: - name: APPCONF01 # 定义环境变量的名称 valueFrom: # key “appconf01”的值获取 configMapKeyRef: name: cm-test01 # 环境变量的值来自于 configmap cm-test01 key: appconf01 # configmap 中的配置 key 为 appconf01 - name: APPCONF02 # 定义环境变量的名称 valueFrom: # key “appconf02”的值获取 configMapKeyRef: name: cm-test01 # 环境变量的值来自于 configmap cm-test01 key: appconf02 # configmap 中的配置 key 为 appconf02 restartPolicy: Never # 重启策略：从不。kubectl create -f pod-test01.yamlkubectl get pods | grep cmkubectl logs cm-pod-test001 2）spec.envFrom 【环境变量】 1234567891011121314151617vim pod-test02.yamlapiVersion: v1kind: Podmetadata: name: cm-pod-test002spec: containers: - name: cm-test2 image: tomcat:8 command: [ &quot;/bin/sh&quot;, &quot;-c&quot;, &quot;env&quot;] envFrom: - configMapRef: name: cm-test01 # 根据 ConfigMap cm-test01 资源自动生成环境变量 restartPolicy: Neverkubectl create -f pod-test02.yamlkubectl get po （3）指定 items【卷挂载方式】 1234567891011121314151617181920212223vim pod-test03.yamlapiVersion: v1kind: Podmetadata: name: cm-pod-test003spec: containers: - name: cm-test3 image: tomcat:8 volumeMounts: - name: vm-01-1 mountPath: /conf volumes: - name: vm-01-1 configMap: name: cm-test-file items: - key: key-testproperties path: test.properties restartPolicy: Neverkubectl create -f pod-test03.yamlkubectl get po (4）不指定 items【卷挂载方式】 123456789101112131415161718192021222324vim pod-test04.yamlapiVersion: v1kind: Podmetadata: name: cm-pod-test004spec: containers: - name: cm-test4 image: tomcat:8 volumeMounts: - name: vm-02-2 mountPath: /conf volumes: - name: vm-02-2 configMap: name: cm-test-file restartPolicy: Neverkubectl create -f pod-test04.yamlkubectl get po# 进入容器查看kubectl exec -it cm-pod-test004 -c cm-test4 -- bashroot@cm-pod-test004:/usr/local/tomcat# ls /conf","categories":[{"name":"Kubernetes","slug":"Kubernetes","permalink":"https://hqd8080.github.io/categories/Kubernetes/"}],"tags":[{"name":"kubernetes","slug":"kubernetes","permalink":"https://hqd8080.github.io/tags/kubernetes/"},{"name":"k8s","slug":"k8s","permalink":"https://hqd8080.github.io/tags/k8s/"}]},{"title":"Kubernetes 核心概念","slug":"kubernetes/0003","date":"2021-03-02T13:02:10.000Z","updated":"2023-01-03T12:51:35.647Z","comments":true,"path":"2021/03/02/kubernetes/0003/","link":"","permalink":"https://hqd8080.github.io/2021/03/02/kubernetes/0003/","excerpt":"","text":"Kubernetes 核心概念1.1 kubernetes 集群命令行工具 kubectl1.1.1 kubectl 概述kubectl 是 Kubernetes 集群的命令行工具，通过 kubectl 能够对集群本身进行管理，并能够在集群上进行容器化应用的安装和部署 1.1.2 kubectl 命令格式1kubectl [command] [type] [name] [flags] command：指定要对资源执行的操作，例如 create、get、describe、delete type：指定资源类型，资源类型是大小写敏感的，开发者能够以单数 、复数 和 缩略的形式 name：指定资源的名称，名称也是大小写敏感的，如果省略名称，则会显示所有的资源，例如1kubectl get pods flags：指定可选的参数，例如，可用 -s 或者 -server 参数指定 Kubernetes API server 的地址和端口 1.1.3 kubectl 帮助命令123456# 获取 kubectl 的命令kubectl --help# 获取某个命令的介绍和使用kubectl get --helpkubectl create --help 1.1.4 kubectl 基础命令 命令 介绍 create 通过文件名或标准输入创建资源 expose 将一个资源公开为一个新的 Service run 在集群中运行一个特定的镜像 set 在对象上设置特定的功能 get 显示一个或多个资源 explain 文档参考资料 edit 使用默认的编辑器编辑一个资源 delete 通过文件名，标准输入，资源名称或标签来删除资源 1.1.5 kubectl 部署命令 命令 介绍 rollout 管理资源的发布 rolling-update 对给定的复制控制器滚动更新 scale 扩容或缩容 Pod 数量，Deployment、ReplicaSet、RC 或 Job autoscale 创建一个自动选择扩容或缩容并设置 Pod 数量 1.1.6 kubectl 集群管理命令 命令 介绍 certificate 修改证书资源 cluster-info 显示集群信息 top 显示资源 (CPU/M) cordon 标记节点不可调度 uncordon 标记节点可被调度 drain 驱逐节点上的应用，准备下线维护 taint 修改节点 taint 标记 1.1.7 kubectl 故障和调试命令 命令 介绍 describe 显示特定资源或资源组的详细信息 logs 在一个 Pod 中打印一个容器日志，如果 Pod 只有一个容器，容器名称是可选的 attach 附加到一个运行的容器 exec 执行命令到容器 port-forward 转发一个或多个端口 proxy 运行一个 proxy 到 Kubernetes API Server cp 拷贝文件或目录到容器中 auth 检查授权 1.1.8 kubectl 其它命令 命令 介绍 apply 通过文件名或标准输入对资源应用配置 patch 使用补丁修改、更新资源的字段 replace 通过文件名或标准输入替换一个资源 convert 不同的 API 版本之间转换配置文件 label 更新资源上的标签 annotate 更新资源上的注释 completion 用于实现 kubectl 工具自动补全 api-versions 打印受支持的 API 版本 config 修改 kubeconfig 文件（用于访问 API，比如配置认证信息） help 所有命令帮助 plugin 运行一个命令行插件 version 打印客户端和服务版本信息 1.2 Kubernetes 集群 YAML 文件详解1.2.1 YAML 概述 YAML 文件 : 就是资源清单文件，用于资源编排。 YAML : 仍是一种标记语言。为了强调这种语言以数据做为中心，而不是以标记语言为重点。 YAML : 是一个可读性高，用来表达数据序列的格式。 1.2.2 YAML 基本语法 使用空格做为缩进 缩进的空格数目不重要，只要相同层级的元素左侧对齐即可 低版本缩进时不允许使用 Tab 键，只允许使用空格 使用#标识注释，从这个字符一直到行尾，都会被解释器忽略 使用 — 表示新的 yaml 文件开始 1.2.3 YAML 数据结构对象：键值对的集合，又称为映射 (mapping) / 哈希（hashes） / 字典（dictionary） 123456# 对象类型：对象的一组键值对，使用冒号结构表示name: hqd8080age: 18# yaml 也允许另一种写法，将所有键值对写成一个行内对象hash: &#123;name: hqd8080, age: 18&#125; 数组： 1234567# 数组类型：一组连词线开头的行，构成一个数组People- hqd8080- Jack# 数组也可以采用行内表示法People: [hqd8080, Jack] 1.2.4 YAML 组成部分主要分为了两部分，一个是控制器的定义 和 被控制的对象。 在一个 YAML 文件的控制器定义中，有很多属性名称 属性名称 介绍 apiVersion API 版本 kind 资源类型 metadata 资源元数据 spec 资源规格 replicas 副本数量 selector 标签选择器 template Pod 模板 metadat Pod 元数据 spec Pod 规格 containers 容器配置 1.2.5 YAML 快速编写一般来说，我们很少自己手写 YAML 文件，因为这里面涉及到了很多内容，我们一般都会借助工具来创建 1、使用 kubectl create 命令这种方式一般用于资源没有部署的时候，我们可以直接创建一个 YAML 配置文件 12# 尝试运行，并不会真正的创建镜像kubectl create deployment web --image=nginx -o yaml --dry-run 或者我们可以输出到一个文件中 1kubectl create deployment web --image=nginx -o yaml --dry-run &gt; nginx.yaml 然后我们就在文件中直接修改即可 2、使用 kubectl get 命令导出 yaml 文件 可以首先查看一个目前已经部署的镜像 1kubectl get deploy 然后我们导出 nginx 的配置 1kubectl get deploy nginx -o=yaml --export &gt; nginx.yaml 然后会生成一个 nginx.yaml 的配置文件 1.3 Pod1.3.1 Pod 概述1、Pod 基本概念 最小部署的单元、Pod 里面是由一个或多个容器组成【一组容器的集合】 一个 pod 中的容器是共享网络命名空间 Pod 是短暂的 每个 Pod 包含一个或多个紧密相关的用户业务容器 2、Pod 存在的意义 创建容器使用 docker，一个 docker 对应一个容器，一个容器运行一个应用进程 Pod 是多进程设计，运用多个应用程序，也就是一个 Pod 里面有多个容器，而一个容器里面运行一个应用程序 Pod 的存在是为了亲密性应用 两个应用之间进行交互 、网络之间的调用【通过 127.0.0.1 或 socket】、两个应用之间需要频繁调用 3、k8s 业务类型Pod 是 K8S 集群中所有业务类型的基础，可以把 Pod 看作运行在 K8S 集群上的小机器人，不同类型的业务就需要不同类型的小机器人去执行。目前 K8S 的业务主要可以分为以下几种 长期伺服型：long-running 批处理型：batch 节点后台支撑型：node-daemon 有状态应用型：stateful application 上述的几种类型，分别对应的小机器人控制器为：Deployment、Job、DaemonSet 和 StatefulSet （后面将介绍控制器） 1.3.2 Pod 实现机制 Pod 主要有以下两大机制：共享网络 和 共享存储 1、共享网络【容器通过 namespace 和 group 进行隔离】Pod 中容器通信 过程： 同一个 namespace 下 在 Pod 中创建一个根容器： pause 容器 在 Pod 中创建业务容器 【nginx，redis 等】【创建时会添加到 info 容器 中】 在 info 容器 中会独立出 ip 地址，mac 地址，port 等信息，然后实现网络的共享 2、共享存储【Pod 持久化数据，专门存储到某个地方中，使用 Volumn 数据卷进行共享存储】1.3.3 Pod 镜像拉取策略我们以具体实例来说，拉取策略就是 imagePullPolicy、拉取策略主要分为了以下几种： IfNotPresent：默认值，镜像在宿主机上不存在才拉取 Always：每次创建 Pod 都会重新拉取一次镜像 Never：Pod 永远不会主动拉取这个镜像 1.3.4 Pod 资源限制 也就是我们 Pod 在进行调度的时候，可以对调度的资源进行限制，例如我们限制 Pod 调度是使用的资源是 2C4G，那么在调度对应的 node 节点时，只会占用对应的资源，对于不满足资源的节点，将不会进行调度 这里分了两个部分： request：表示调度所需的资源 limits：表示最大所占用的资源 1.3.5 Pod 重启机制 因为 Pod 中包含了很多个容器，假设某个容器出现问题了，那么就会触发 Pod 重启机制 重启策略主要分为以下三种： Always：当容器终止退出后，总是重启容器，默认策略 【nginx 等，需要不断提供服务】 OnFailure：当容器异常退出（退出状态码非 0）时，才重启容器 Never：当容器终止退出，从不重启容器 【批量任务】 1.3.6 Pod 健康检查1、通过容器检查： 1kubectl get pod 2、通过应用检查： 但是有的时候，程序可能出现了 Java 堆内存溢出，程序还在运行，但是不能对外提供服务了，这个时候就不能通过容器检查来判断服务是否可用了。需要通过应用检查 12345# 存活检查，如果检查失败，将杀死容器，根据 Pod 的 restartPolicy【重启策略】来操作livenessProbe# 就绪检查，如果检查失败，Kubernetes 会把 Pod 从 Service endpoints 中剔除readinessProbe Probe 支持以下三种检查方式 http Get：发送 HTTP 请求，返回 200 - 400 范围状态码为成功 exec：执行 Shell 命令返回状态码是 0 为成功 tcpSocket：发起 TCP Socket 建立成功 1.3.7 Pod 调度策略 首先创建一个 pod，然后创建一个 API Server 和 Etcd【把创建出来的信息存储在 etcd 中】 然后创建 Scheduler，监控 API Server 是否有新的 Pod，如果有的话，会通过调度算法，把 pod 调度某个 node 上 在 node 节点，会通过 kubelet – apiserver 读取 etcd 拿到分配在当前 node 节点上的 pod，然后通过 docker 创建容器 1.4 Controller1.4.1 Controller 内容简介 什么是 Controler Pod 和 Controller 的关系 Deployment 控制器应用场景 yaml 文件字段说明 Deployment 控制器部署应用 升级回滚 弹性收缩 1.4.2 Controller 概述Controller 是集群上管理和运行容器的对象 Controller 是实际存在的 Pod 是虚拟机的 1.4.3 Pod 和 Controller 的关系Pod 是通过 Controller 实现应用的运维，比如弹性收缩，滚动升级 Pod 和 Controller 之间是通过 label 标签建立关系，同时 Controller 又被称为控制器工作负载 Controller【控制器】【工作负载】selector: app:nginx Pod【容器】labels: app:nginx 1.4.4 Deployment 控制器应用Deployment 表示用户对 K8S 集群的一次更新操作 Deployment 控制器可以部署无状态应用 管理 Pod 和 ReplicaSet 部署，滚动升级等功能 应用场景：web 服务，微服务 1.4.5 Deployment 部署应用之前，使用 deployment 部署应用，代码如下：【缺点：代码不好复用】 1kubectrl create deployment web --image=nginx 现在，使用 YAML 文件进行配置：【快速编写 YAML 文件】 1kubectl create deployment web --image=nginx -o yaml --dry-run &gt; nginx.yaml nginx.yaml 文件内容如下：【selector 和 label 就是我们 Pod 和 Controller 之间建立关系的桥梁】 1234567891011121314151617181920212223242526apiVersion: apps/v1kind: Deploymentmetadata: creationTimestamp: null # Pod labels: app: web name: webspec: replicas: 1 # Controller selector: matchLabels: app: web strategy: &#123;&#125; template: metadata: creationTimestamp: null labels: app: web spec: containers: - image: nginx name: nginx resources: &#123;&#125;status: &#123;&#125; 现在，使用nginx.yaml文件创建镜像： 1kubectl apply -f nginx.yaml 然后，对外暴露端口： 1234567kubectl expose deployment web --port=80 --type=NodePort --target-port=80 --name=web1# 参数说明# --port：就是我们内部的端口号# --target-port：就是暴露外面访问的端口号# --name：名称# --type：类型 同理，导出配置文件： 1kubectl expose deployment web --port=80 --type=NodePort --target-port=80 --name=web1 -o yaml &gt; web1.yaml 查看端口： 123456789kubectl get pods,svc# 输出结果NAME READY STATUS RESTARTS AGEpod/web-5dcb957ccc-d89v9 1/1 Running 0 8m35sNAME TYPE CLUSTER-IP EXTERNAL-IP PORT(S) AGEservice/kubernetes ClusterIP 10.96.0.1 &lt;none&gt; 443/TCP 2d5hservice/web1 NodePort 10.111.61.143 &lt;none&gt; 80:30344/TCP 6s 然后我们访问对应的 url，即可看到 nginx 了 http://192.168.60.151:30344/ 1.4.6 升级回滚和弹性收缩 升级： 假设从版本为 1.14 升级到 1.15 ，这就叫应用的升级【升级可以保证服务不中断】 回滚：从版本 1.15 变成 1.14，这就叫应用的回滚 弹性伸缩：我们根据不同的业务场景，来改变 Pod 的数量对外提供服务，这就是弹性伸缩 1、创建一个 1.14 版本的 pod12345678910111213141516171819202122232425apiVersion: apps/v1kind: Deploymentmetadata: creationTimestamp: null labels: app: web name: webspec: replicas: 1 selector: matchLabels: app: web strategy: &#123;&#125; template: metadata: creationTimestamp: null labels: app: web spec: containers: # 修改 nginx 版本 1.14 - image: nginx:1.14 name: nginx resources: &#123;&#125;status: &#123;&#125; 1kubectl apply -f nginx.yaml 2、应用升级1kubectl set image deployment web nginx=nginx:1.15 升级过程： 12345678910111213141516171819[root@master ~]# kubectl set image deployment web nginx=nginx:1.15deployment.apps/web image updated# 首先是开始的 nginx 1.14 版本的 Pod 在运行，然后 1.15 版本的在创建[root@master ~]# kubectl get podNAME READY STATUS RESTARTS AGEweb-66bf4959f5-qhzsd 1/1 Running 0 52sweb-bbcf684cb-bbmqv 0/1 ContainerCreating 0 3s# 然后在 1.15 版本创建完成后，就会暂停 1.14 版本[root@master ~]# kubectl get podNAME READY STATUS RESTARTS AGEweb-66bf4959f5-qhzsd 1/1 Terminating 0 67sweb-bbcf684cb-bbmqv 1/1 Running 0 18s# 最后把 1.14 版本的 Pod 移除，完成我们的升级[root@master ~]# kubectl get podNAME READY STATUS RESTARTS AGEweb-bbcf684cb-bbmqv 1/1 Running 0 33s 我们在下载 1.15 版本，容器就处于 ContainerCreating 状态，然后下载完成后，就用 1.15 版本去替换 1.14 版本了，这么做的好处就是：升级可以保证服务不中断 3、查看升级状态1kubectl rollout status deployment web 4、查看历史版本1kubectl rollout history deployment web 5、应用回滚12345# 回滚到上一版本kubectl rollout undo deployment web# 回滚到指定版本kubectl rollout undo deployment web --to-revision=2 6、弹性伸缩1234567891011121314151617# 通过命令创建多个副本kubectl scale deployment web --replicas=10# 输出结果，等一会就会全部 Running[root@master ~]# kubectl scale deployment web --replicas=10 deployment.apps/web scaled[root@master ~]# kubectl get podNAME READY STATUS RESTARTS AGEweb-bbcf684cb-2f2zl 0/1 ContainerCreating 0 4sweb-bbcf684cb-72pzr 0/1 ContainerCreating 0 4sweb-bbcf684cb-bbmqv 1/1 Running 0 3m9sweb-bbcf684cb-fgpgh 0/1 ContainerCreating 0 4sweb-bbcf684cb-fpk8d 0/1 ContainerCreating 0 4sweb-bbcf684cb-hqp4z 0/1 ContainerCreating 0 4sweb-bbcf684cb-htq2d 0/1 ContainerCreating 0 4sweb-bbcf684cb-lnkwx 0/1 ContainerCreating 0 4sweb-bbcf684cb-vmwb9 0/1 ContainerCreating 0 4sweb-bbcf684cb-vnk5w 0/1 ContainerCreating 0 4s","categories":[{"name":"Kubernetes","slug":"Kubernetes","permalink":"https://hqd8080.github.io/categories/Kubernetes/"}],"tags":[{"name":"kubernetes","slug":"kubernetes","permalink":"https://hqd8080.github.io/tags/kubernetes/"},{"name":"k8s","slug":"k8s","permalink":"https://hqd8080.github.io/tags/k8s/"}]},{"title":"从零开始搭建 K8s 集群","slug":"kubernetes/0002","date":"2021-03-01T13:10:10.000Z","updated":"2023-01-02T14:52:15.827Z","comments":true,"path":"2021/03/01/kubernetes/0002/","link":"","permalink":"https://hqd8080.github.io/2021/03/01/kubernetes/0002/","excerpt":"","text":"从零开始搭建 K8s 集群1.1 基于客户端工具 kubeadmkubeadm 是官方社区推出的一个用于快速部署 kubernetes 集群的工具这个工具能通过两条指令完成一个 kubernetes 集群的部署： 12345# 创建一个 Master 节点kubeadm init# 将一个 Worker node 节点加入到当前集群中kubeadm join &lt;Master 节点的 IP 和端口 &gt; 1.1.1 安装步骤使用 kubeadm 方式搭建 Kubernetes 集群主要分为以下几步：1.【环境准备】准备三台虚拟机，并安装操作系统 CentOS 7.x2.【系统初始化】对三个刚安装好的操作系统进行初始化操作3.【安装工具】在三个节点安装 docker kubelet kubeadm kubectl4.【集群部署-master】在 master 节点执行kubeadm init命令初始化5.【集群部署-node】在 node 节点上执行 kubeadm join命令，把 node 节点添加到当前集群6.【安装网络插件】配置 CNI 网络插件，用于节点之间的连通7.【测试集群】通过拉取一个 nginx 进行测试，能否进行外网测试 1.1.2 安装要求在开始之前，部署 Kubernetes 集群机器需要满足以下几个条件： 一台或多台机器，操作系统 CentOS7.x-86_x64 硬件配置：2GB 或更多 RAM，2 个 CPU 或更多 CPU，硬盘 30GB 或更多【注意】【注意】【注意】【master 需要两核】 可以访问外网，需要拉取镜像，如果服务器不能上网，需要提前下载镜像并导入节点 禁止 swap 分区 1.1.3 准备环境 角色 IP 配置 操作 master1 192.168.60.151 2C 2G init docker kubelet kubeadm kubectl kubeadm init cni node1 192.168.60.152 2C 2G init docker kubelet kubeadm kubectl kubeadm join node2 192.168.60.153 2C 2G init docker kubelet kubeadm kubectl kubeadm join 1.1.4 系统初始化【在每台机器上】执行下面的命令： 123456789101112131415161718192021222324252627282930313233343536373839404142# 关闭防火墙systemctl stop firewalld# 禁用 firewalld 服务systemctl disable firewalld# 关闭 selinux# 临时关闭【立即生效】告警，不启用，Permissive，查看使用 getenforce 命令setenforce 0 # 永久关闭【重启生效】sed -i &#x27;s/SELINUX=enforcing/\\SELINUX=disabled/&#x27; /etc/selinux/config # 关闭 swap# 临时关闭【立即生效】查看使用 free 命令swapoff -a # 永久关闭【重启生效】sed -ri &#x27;s/.*swap.*/#&amp;/&#x27; /etc/fstab# 在主机名静态查询表中添加 3 台主机cat &gt;&gt; /etc/hosts &lt;&lt; EOF192.168.60.151 master192.168.60.152 node1192.168.60.153 node2EOF# 将桥接的 IPv4 流量传递到 iptables 的链cat &gt; /etc/sysctl.d/k8s.conf &lt;&lt; EOFnet.bridge.bridge-nf-call-ip6tables = 1net.bridge.bridge-nf-call-iptables = 1EOF# 使 k8s 配置生效sysctl --system # 时间同步yum install ntpdate -yntpdate time.windows.com# 根据规划设置主机名【master1 节点上操作】hostnamectl set-hostname master1# 根据规划设置主机名【node1 节点上操作】hostnamectl set-hostname node1# 根据规划设置主机名【node2 节点操作】hostnamectl set-hostname node2 1.1.5 安装组件【所有节点】需要安装以下组件 ，Kubernetes 默认 CRI（容器运行时）为 Docker，因此先安装 Docker Docker kubeadm kubelet kubectl 1.安装 Docker1234567891011121314151617181920212223242526# 配置一下 Docker 的 yum 源【阿里云】cat &gt;/etc/yum.repos.d/docker.repo&lt;&lt;EOF[docker-ce-edge]name=Docker CE Edge - \\$basearchbaseurl=https://mirrors.aliyun.com/docker-ce/linux/centos/7/\\$basearch/edgeenabled=1gpgcheck=1gpgkey=https://mirrors.aliyun.com/docker-ce/linux/centos/gpgEOF# 然后 yum 方式安装 dockeryum -y install docker-ce# 查看 docker 版本docker --version# 配置 docker 的镜像源【阿里云】cat &gt;&gt; /etc/docker/daemon.json &lt;&lt; EOF&#123; &quot;registry-mirrors&quot;: [&quot;https://b9pmyelo.mirror.aliyuncs.com&quot;]&#125;EOF# 启动 dockersystemctl enable dockersystemctl start dockersystemctl status docker 2.安装 kubeadm，kubelet 和 kubectl123456789101112131415# 配置 k8s 的 yum 源【阿里云】cat &gt; /etc/yum.repos.d/kubernetes.repo &lt;&lt; EOF[kubernetes]name=Kubernetesbaseurl=https://mirrors.aliyun.com/kubernetes/yum/repos/kubernetes-el7-x86_64enabled=1gpgcheck=0repo_gpgcheck=0gpgkey=https://mirrors.aliyun.com/kubernetes/yum/doc/yum-key.gpg https://mirrors.aliyun.com/kubernetes/yum/doc/rpm-package-key.gpgEOF# 安装 kubelet、kubeadm、kubectl，同时指定版本yum install -y kubelet-1.18.0 kubeadm-1.18.0 kubectl-1.18.0# 设置开机自启【这里暂时先不启动 kubelet】systemctl enable kubelet 1.1.6 集群部署【master 节点】在 192.168.60.151 上执行【集群初始化命令】，也就是master1节点 12345kubeadm init --apiserver-advertise-address=192.168.60.151 \\--image-repository registry.aliyuncs.com/google_containers \\--kubernetes-version v1.18.0 \\--service-cidr=10.96.0.0/12 \\--pod-network-cidr=10.244.0.0/16 部署成功后，【系统提示】运行以下命令使用 kubectl 123mkdir -p $HOME/.kubesudo cp -i /etc/kubernetes/admin.conf $HOME/.kube/configsudo chown $(id -u):$(id -g) $HOME/.kube/config 执行完成后，我们使用下面命令，查看我们正在运行的节点 1kubectl get nodes 1.1.7 集群部署【node 节点】下面我们需要到 node1 和 node2 服务器，执行下面的代码向集群添加新节点执行在 kubeadm init 输出的kubeadm join命令： 注意，以下的命令是在 master1 初始化完成后给出的 12kubeadm join 192.168.60.151:6443 --token dsedrf.ajsdhkjahsdjjfhkjahkkhj \\--discovery-token-ca-cert-hash sha256:xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx 默认 token 有效期为 24 小时，当过期之后，该 token 就不可用了。这时就需要重新创建 token，操作如下： 1kubeadm token create --print-join-command 当我们把两个节点都加入进来后，我们就可以去 master1 节点下 执行下面命令查看情况 1kubectl get nodes 1.1.8 部署 CNI 网络插件上面的状态还是 NotReady，下面我们需要网络插件，来进行联网访问 12345678# 下载网络插件配置wget https://raw.githubusercontent.com/coreos/flannel/master/Documentation/kube-flannel.yml# 添加kubectl apply -f kube-flannel.yml# 等一会！# ......# 查看状态 【kube-system 是 k8s 中的最小单元】kubectl get pods -n kube-system 运行后的结果为 Ready 状态 【提示】如果上述操作完成后，还存在某个节点处于 NotReady 状态，可以在 Master 将该节点删除 123456789# 将 node1 节点删除【在 master1 节点上操作】 kubectl delete node node1# 将 node1 节点进行重置【在 node1 节点上操作】kubeadm reset# 将 node1 节点加入集群【在 node1 节点上操作】kubeadm join 192.168.60.151:6443 --token dsedrf.ajsdhkjahsdjjfhkjahkkhj \\--discovery-token-ca-cert-hash sha256:xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx 1.1.9 测试 kubernetes 集群我们都知道 K8S 是容器化技术，它可以联网去下载镜像，用容器的方式进行启动在 Kubernetes 集群中创建一个 pod，验证是否正常运行： 1234# 下载 nginx 【会联网拉取 nginx 镜像】kubectl create deployment nginx --image=nginx# 查看状态kubectl get pod 如果我们出现 Running 状态的时候，表示已经成功运行了下面我们就需要将端口暴露出去，让其它外界能够访问 1234# 暴露端口kubectl expose deployment nginx --port=80 --type=NodePort# 查看一下对外的端口kubectl get pod,svc 我这里，已经成功暴露了 80 端口 到 30529 上我们到我们的宿主机浏览器上，访问如下地址 1http://192.168.60.151:30529/ 发现我们的 nginx 已经成功启动了 1.1.10 错误汇总错误一在执行 Kubernetes init 方法的时候，出现这个问题 12error execution phase preflight: [preflight] Some fatal errors occurred: [ERROR NumCPU]: the number of available CPUs 1 is less than the required 2 是因为 VMware 设置的核数为 1，而 K8S 需要的最低核数应该是 2，调整核数重启系统即可 错误二我们在给 node1 节点使用 kubernetes join 命令的时候，出现以下错误 12error execution phase preflight: [preflight] Some fatal errors occurred: [ERROR Swap]: running with swap on is not supported. Please disable swap 错误原因是我们需要关闭 swap【可能是永久关闭 swap 时没有重启生效】 12345# 关闭 swap# 临时关闭【立即生效】swapoff -a # 永久关闭【重启生效】sed -ri &#x27;s/.*swap.*/#&amp;/&#x27; /etc/fstab 错误三在给 node1 节点使用 kubernetes join 命令的时候，出现以下错误 1The HTTP call equal to &#x27;curl -sSL http://localhost:10248/healthz&#x27; failed with error: Get http://localhost:10248/healthz: dial tcp [::1]:10248: connect: connection refused 解决方法，首先需要到 master1 节点，创建一个文件 1234567891011# 创建文件夹mkdir /etc/systemd/system/kubelet.service.d# 创建文件vim /etc/systemd/system/kubelet.service.d/10-kubeadm.conf# 添加如下内容Environment=&quot;KUBELET_SYSTEM_PODS_ARGS=--pod-manifest-path=/etc/kubernetes/manifests --allow-privileged=true --fail-swap-on=false&quot;# 重置kubeadm reset 然后删除刚刚创建的配置目录 1rm -rf $HOME/.kube 然后 在 master1 重新初始化 1234kubeadm init --apiserver-advertise-address=92.168.60.151:6443 \\--image-repository registry.aliyuncs.com/google_containers \\--kubernetes-version v1.18.0 --service-cidr=10.96.0.0/12 \\--pod-network-cidr=10.244.0.0/16 初始完成后，我们再到 node1 节点，执行 kubeadm join 命令，加入到 master1【下面这条命令是 master1 初始化后自动生成的】 12kubeadm join 192.168.60.151:6443 --token c7a7ou.z00fzlb01d76r37s \\ --discovery-token-ca-cert-hash sha256:9c3f3cc3f726c6ff8bdff14e46b1a856e3b8a4cbbe30cab185f6c5ee453aeea5 添加完成后，我们使用下面命令，查看节点是否成功添加 1kubectl get nodes 错误四我们再执行查看节点的时候， kubectl get nodes 会出现问题 1Unable to connect to the server: x509: certificate signed by unknown authority (possibly because of &quot;crypto/rsa: verification error&quot; while trying to verify candidate authority certificate &quot;kubernetes&quot;) 这是因为我们之前创建的配置文件还存在，也就是这些配置 123mkdir -p $HOME/.kubesudo cp -i /etc/kubernetes/admin.conf $HOME/.kube/configsudo chown $(id -u):$(id -g) $HOME/.kube/config 我们需要做的就是把配置文件删除，然后重新执行一下 1rm -rf $HOME/.kube 然后再次创建一下即可 123mkdir -p $HOME/.kubesudo cp -i /etc/kubernetes/admin.conf $HOME/.kube/configsudo chown $(id -u):$(id -g) $HOME/.kube/config 这个问题主要是因为我们在执行 kubeadm reset 的时候，没有把 $HOME/.kube 给移除掉，再次创建时就会出现问题了 错误五安装的时候，出现以下错误 1Another app is currently holding the yum lock; waiting for it to exit... 是因为 yum 上锁占用，解决方法 1yum -y install docker-ce 错误六在使用下面命令，添加 k8snode1 节点到集群上的时候 1kubeadm join 192.168.60.151:6443 --token jkcz0t.3c40t0bqqz5g8wsb --discovery-token-ca-cert-hash sha256:bc494eeab6b7bac64c0861da16084504626e5a95ba7ede7b9c2dc7571ca4c9e5 然后出现了这个错误 12345678[root@master1 ~]# kubeadm join 192.168.60.151:6443 --token jkcz0t.3c40t0bqqz5g8wsb --discovery-token-ca-cert-hash sha256:bc494eeab6b7bac64c0861da16084504626e5a95ba7ede7b9c2dc7571ca4c9e5W1117 06:55:11.220907 11230 join.go:346] [preflight] WARNING: JoinControlPane.controlPlane settings will be ignored when control-plane flag is not set.[preflight] Running pre-flight checks [WARNING IsDockerSystemdCheck]: detected &quot;cgroupfs&quot; as the Docker cgroup driver. The recommended driver is &quot;systemd&quot;. Please follow the guide at https://kubernetes.io/docs/setup/cri/error execution phase preflight: [preflight] Some fatal errors occurred: [ERROR FileContent--proc-sys-net-ipv4-ip_forward]: /proc/sys/net/ipv4/ip_forward contents are not set to 1[preflight] If you know what you are doing, you can make a check non-fatal with `--ignore-preflight-errors=...`To see the stack trace of this error execute with --v=5 or higher 出于安全考虑，Linux 系统默认是禁止数据包转发的。所谓转发即当主机拥有多于一块的网卡时，其中一块收到数据包，根据数据包的目的 ip 地址将包发往本机另一网卡，该网卡根据路由表继续发送数据包。这通常就是路由器所要实现的功能。也就是说 /proc/sys/net/ipv4/ip_forward 文件的值不支持转发 0：禁止 1：转发 所以我们需要将值修改成 1 即可 1echo &quot;1&quot; &gt; /proc/sys/net/ipv4/ip_forward 修改完成后，重新执行命令即可","categories":[{"name":"Kubernetes","slug":"Kubernetes","permalink":"https://hqd8080.github.io/categories/Kubernetes/"}],"tags":[{"name":"kubernetes","slug":"kubernetes","permalink":"https://hqd8080.github.io/tags/kubernetes/"},{"name":"k8s","slug":"k8s","permalink":"https://hqd8080.github.io/tags/k8s/"}]},{"title":"Kubernetes 概述和架构","slug":"kubernetes/0001","date":"2021-03-01T11:10:10.000Z","updated":"2023-01-02T14:04:13.486Z","comments":true,"path":"2021/03/01/kubernetes/0001/","link":"","permalink":"https://hqd8080.github.io/2021/03/01/kubernetes/0001/","excerpt":"","text":"Kubernetes 概述和架构1.1 Kubernetes 简介Kubernetes，首字母 K，尾字母 s，中间 8 个字母，简称 K8s 1.2 Kubernetes 功能1.自动装箱 （基于容器对应用运行环境的资源配置要求自动部署应用容器） 2.自我修复 （当容器失败时，会对容器进行重启） （当所部署的 Node 节点有问题时，会对容器进行重新部署和重新调度） （当容器未通过监控检查时，会关闭此容器直到容器正常运行时，才会对外提供服务） 3.水平扩展 （通过简单的命令、用户 UI 界面或基于 CPU 等资源使用情况，对应用容器进行规模扩大或规模剪裁） （当我们有大量的请求来临时，我们可以增加副本数量，从而达到水平扩展的效果） 4.服务发现 （用户不需使用额外的服务发现机制，就能够基于 Kubernetes 自身能力实现服务发现和负载均衡） 5.滚动更新 （可以根据应用的变化，对应用容器运行的应用，进行一次性或批量式更新） 6.版本回退 （可以根据应用部署情况，对应用容器运行的应用，进行历史版本即时回退） 7.密钥和配置管理 （在不需要重新构建镜像的情况下，可以部署和更新密钥和应用配置，类似热部署） 8.存储编排 （自动实现存储系统挂载及应用，特别对有状态应用实现数据持久化非常重要） （存储系统可以来自于本地目录、网络存储 (NFS、Gluster、Ceph 等）、公共云存储服务） 9.批处理 （提供一次性任务，定时任务；满足批量数据处理和分析的场景） 1.3 Kubernetes 架构组件 Kubernetes 架构主要包含两部分：Master（主控节点）和 Work node（工作节点） Kubernetes 组件 Master：主控节点 API Server：集群统一入口，以 restful 风格进行操作，同时交给 etcd 存储,提供认证、授权、访问控制、API 注册和发现等机制 scheduler：节点的调度，选择 node 节点应用部署 controller-manager：处理集群中常规后台任务，一个资源对应一个控制器 etcd：存储系统，用于保存集群中的相关数据 Worker node：工作节点 Kubelet：master 派到 node 节点代表，管理本机容器 一个集群中每个节点上运行的代理，它保证容器都运行在 Pod 中 负责维护容器的生命周期，同时也负责 Volume(CSI) 和 网络 (CNI) 的管理 kube-proxy：提供网络代理，负载均衡等操作 容器运行环境【Container Runtime】 容器运行环境是负责运行容器的软件 Kubernetes 支持多个容器运行环境：Docker、containerd、cri-o、rktlet 以及任何实现 Kubernetes CRI （容器运行环境接口） 的软件。 fluentd：是一个守护进程，它有助于提升集群层面日志1.4 Kubernetes 核心概念1.Pod Pod 是 K8s 中最小的单元 一组容器的集合 共享网络【一个 Pod 中的所有容器共享同一网络】 生命周期是短暂的（服务器重启后，就找不到了） 2.Volume 声明在 Pod 容器中可访问的文件目录 可以被挂载到 Pod 中一个或多个容器指定路径下 支持多种后端存储抽象【本地存储、分布式存储、云存储】 3.Controller 确保预期的 pod 副本数量【ReplicaSet】 无状态应用部署【Deployment】 (无状态就是指，不需要依赖于网络或者 ip) 有状态应用部署【StatefulSet】 (有状态需要特定的条件) 确保所有的 node 运行同一个 pod 【DaemonSet】 一次性任务和定时任务【Job 和 CronJob】 4.Deployment 定义一组 Pod 副本数目，版本等 通过控制器【Controller】维持 Pod 数目【自动回复失败的 Pod】 通过控制器以指定的策略控制版本【滚动升级、回滚等】 5.Service 定义一组 pod 的访问规则 Pod 的负载均衡，提供一个或多个 Pod 的稳定访问地址 支持多种方式【ClusterIP、NodePort、LoadBalancer】 6.Label label：标签，用于对象资源查询，筛选 7.Namespace 命名空间，逻辑隔离 一个集群内部的逻辑隔离机制【鉴权、资源】 每个资源都属于一个 namespace 同一个 namespace 所有资源不能重复 不同 namespace 可以资源名重复 8.API 我们通过 Kubernetes 的 API 来操作整个集群 同时我们可以通过 kubectl 、ui、curl 最终发送 http + json/yaml 方式的请求给 API Server，然后控制整个 K8S 集群，K8S 中所有的资源对象都可以采用 yaml 或 json 格式的文件定义或描述","categories":[{"name":"Kubernetes","slug":"Kubernetes","permalink":"https://hqd8080.github.io/categories/Kubernetes/"}],"tags":[{"name":"kubernetes","slug":"kubernetes","permalink":"https://hqd8080.github.io/tags/kubernetes/"},{"name":"k8s","slug":"k8s","permalink":"https://hqd8080.github.io/tags/k8s/"}]},{"title":"Go语言的协程泄漏","slug":"golang/go-leakage","date":"2020-06-04T12:40:28.000Z","updated":"2023-10-07T11:35:00.857Z","comments":true,"path":"2020/06/04/golang/go-leakage/","link":"","permalink":"https://hqd8080.github.io/2020/06/04/golang/go-leakage/","excerpt":"","text":"Go语言协程泄漏协程泄漏是指由于某种原因，在协程执行后并未正确结束；而是处于阻塞状态。那么此时垃圾回收机制也无法回收这些协程占用的资源；这就导致无法释放的协程数量越来越多，于是发生泄漏 发生协程泄露的场景协程发生泄漏一般是通道chan使用不当；或者锁同步机制使用错误所导致；通道发送不接收；接收不发送；都会导致协程泄漏","categories":[{"name":"Go语言","slug":"Go语言","permalink":"https://hqd8080.github.io/categories/Go%E8%AF%AD%E8%A8%80/"}],"tags":[{"name":"golang","slug":"golang","permalink":"https://hqd8080.github.io/tags/golang/"}]},{"title":"Go语言使用WebSocket协议","slug":"golang/websocket","date":"2020-06-04T12:40:28.000Z","updated":"2023-10-07T11:37:47.080Z","comments":true,"path":"2020/06/04/golang/websocket/","link":"","permalink":"https://hqd8080.github.io/2020/06/04/golang/websocket/","excerpt":"","text":"WebSocket协议原理在WebSocket中，客户端（浏览器）和服务器只需要完成一次握手，在二者之间就能创建持久性的连接（长连接），而后进行双向的数据传输。WebSocket能更好的节省服务器资源和带宽，并且能够更实时的进行通信。一旦建立WebSocket连接，无论是服务器还是客户端，任意一方都可以直接向对方发送数据。 客户端为了和服务端建立一个WebSocket连接，首先要向服务器发起一个HTTP请求，这个请求和普通的请求不一样；会包含一些附加头信息，比如：Upgrade：WebSocket，服务器会解析这些附加头信息。WebSocket协议为了兼容现有浏览器，所以在握手阶段使用了HTTP协议；WebSocket是类似TCP长连接的通信模式；WebSocket协议建立在TCP协议之上","categories":[{"name":"Go语言","slug":"Go语言","permalink":"https://hqd8080.github.io/categories/Go%E8%AF%AD%E8%A8%80/"}],"tags":[{"name":"golang","slug":"golang","permalink":"https://hqd8080.github.io/tags/golang/"},{"name":"WebSocket","slug":"WebSocket","permalink":"https://hqd8080.github.io/tags/WebSocket/"}]},{"title":"GoLand文件注释模板配置 IDE","slug":"golang/go-file-and-template","date":"2020-06-03T06:22:50.000Z","updated":"2024-02-04T06:54:28.909Z","comments":true,"path":"2020/06/03/golang/go-file-and-template/","link":"","permalink":"https://hqd8080.github.io/2020/06/03/golang/go-file-and-template/","excerpt":"","text":"File / Setting / Editor / File and Template 12345678// @package : $&#123;GO_PACKAGE_NAME&#125;// @file : $&#123;FILE_NAME&#125;// @author : $&#123;USER&#125;// @contact : hanquanding@163.com// @time : $&#123;DATE&#125;// @description: $&#123;NAME&#125;package $&#123;GO_PACKAGE_NAME&#125; 123456789/** * @Author: $&#123;USER&#125; * @Description: * @File: $&#123;NAME&#125; * @Version: 1.0.0 * @Date: $&#123;DATE&#125; $&#123;TIME&#125; */package $&#123;GO_PACKAGE_NAME&#125; 1234567/** * @Author: $&#123;USER&#125; * @Date: $&#123;DATE&#125; $&#123;TIME&#125; * @Description: */package $&#123;GO_PACKAGE_NAME&#125;","categories":[{"name":"Go语言","slug":"Go语言","permalink":"https://hqd8080.github.io/categories/Go%E8%AF%AD%E8%A8%80/"}],"tags":[{"name":"golang","slug":"golang","permalink":"https://hqd8080.github.io/tags/golang/"}]},{"title":"Go保证并发程序的数据安全性","slug":"golang/go-concurrent-safe","date":"2020-06-02T03:24:02.000Z","updated":"2023-10-07T11:33:18.950Z","comments":true,"path":"2020/06/02/golang/go-concurrent-safe/","link":"","permalink":"https://hqd8080.github.io/2020/06/02/golang/go-concurrent-safe/","excerpt":"","text":"并发安全 1.使用chan 2.使用原子性函数atomic函数 3.使用互斥锁sync.mutex 4.使用等待组sync.waitgroup 5.使用context系列函数超时退出","categories":[{"name":"Go语言","slug":"Go语言","permalink":"https://hqd8080.github.io/categories/Go%E8%AF%AD%E8%A8%80/"}],"tags":[{"name":"golang","slug":"golang","permalink":"https://hqd8080.github.io/tags/golang/"}]},{"title":"Dockerfile文件常用指令","slug":"docker/docker-dockerfile","date":"2020-05-26T08:58:17.000Z","updated":"2022-11-08T07:22:50.092Z","comments":true,"path":"2020/05/26/docker/docker-dockerfile/","link":"","permalink":"https://hqd8080.github.io/2020/05/26/docker/docker-dockerfile/","excerpt":"","text":"Dockerfile文件常用指令说明 FROM:指定所创建镜像的基础镜像，任何Dockerfile中第一条指令必须为FROM指令 12# 基础镜像FROM ubuntu:18.04 LABEL:指定镜像添加元数据标签信息，用来补助过滤特定镜像 12# 维护者 LABEL maintainer hqd8080&lt;github.com/hqd8080&gt; EXPOSE:声明镜像内服务监听的端口 12# 开放端口EXPOSE 22 ENV:指定环境变量，在镜像生成过程中被后续RUN指令使用 12ENV APP_VERSION=1.0ENV APP_HOME=/usr/local/app ENTRYPOINT:指定镜像的默认入口命令，启动容器时作为根命令执行，每个Dockerfile文件只能有一个ENTRYPOINT VOLUME:创建一个数据卷挂载点 WORKDIR:配置工作目录；为后续的RUN，CMD，ENTRYPOINT指令配置工作目录","categories":[{"name":"Docker","slug":"Docker","permalink":"https://hqd8080.github.io/categories/Docker/"}],"tags":[{"name":"docker","slug":"docker","permalink":"https://hqd8080.github.io/tags/docker/"}]},{"title":"Docker镜像SSH服务","slug":"docker/docker-ssh","date":"2020-05-26T03:22:56.000Z","updated":"2022-11-08T07:22:49.804Z","comments":true,"path":"2020/05/26/docker/docker-ssh/","link":"","permalink":"https://hqd8080.github.io/2020/05/26/docker/docker-ssh/","excerpt":"","text":"创建目录和文件123mkdir sshd_buildercd sshd_buildertouch Dockerfile run.sh 编写run.sh脚本和authorized_keys文件123#run.sh#!/bin/bash/usr/sbin/sshd -D 1cat ~/.ssh/id_rsa.pub &gt;authorized_keys 编写Dockerfile文件12345678910111213141516171819202122232425262728293031323334353637383940# 基础镜像FROM ubuntu:18.04# 维护者 LABEL maintainer hqd8080&lt;github.com/hqd8080&gt;# 更换为163源码RUN echo &quot;deb http://mirrors.163.com/ubuntu/ bionic main restricted universe multiverse&quot; &gt; /etc/apt/sources.listRUN echo &quot;deb http://mirrors.163.com/ubuntu/ bionic-security main restricted universe multiverse&quot; &gt;&gt; /etc/apt/sources.listRUN echo &quot;deb http://mirrors.163.com/ubuntu/ bionic-updates main restricted universe multiverse&quot; &gt;&gt; /etc/apt/sources.listRUN echo &quot;deb http://mirrors.163.com/ubuntu/ bionic-proposed main restricted universe multiverse&quot; &gt;&gt; /etc/apt/sources.listRUN echo &quot;deb http://mirrors.163.com/ubuntu/ bionic-backports main restricted universe multiverse&quot; &gt;&gt; /etc/apt/sources.listRUN echo &quot;deb-src http://mirrors.163.com/ubuntu/ bionic main restricted universe multiverse&quot; &gt;&gt; /etc/apt/sources.listRUN echo &quot;deb-src http://mirrors.163.com/ubuntu/ bionic-security main restricted universe multiverse&quot; &gt;&gt; /etc/apt/sources.listRUN echo &quot;deb-src http://mirrors.163.com/ubuntu/ bionic-updates main restricted universe multiverse&quot; &gt;&gt; /etc/apt/sources.listRUN echo &quot;deb-src http://mirrors.163.com/ubuntu/ bionic-proposed main restricted universe multiverse&quot; &gt;&gt; /etc/apt/sources.listRUN echo &quot;deb-src http://mirrors.163.com/ubuntu/ bionic-backports main restricted universe multiverse&quot; &gt;&gt; /etc/apt/sources.listRUN apt-get update # 安装ssh服务RUN apt-get install -y openssh-serverRUN mkdir -p /var/run/sshdRUN mkdir -p /root/.ssh# 取消pam限制RUN sed -ri &#x27;s/session required pam_loginuid.so/#session required pam_loginuid.so/g&#x27; /etc/pam.d/sshd# 复制文件到容器ADD authorized_keys /root/.ssh/authorized_keysADD run.sh /run.sh# 修改执行权限RUN chmod 755 /run.sh# 开放端口EXPOSE 22# 设置自启动命令CMD [ &quot;/run.sh&quot; ] 创建镜像12cd sshd_builderdocker build -t sshd_ubuntu:v1 . 运行容器1docker run -d -p 2222:22 sshd_ubuntu 连接容器1ssh 192.168.0.200 -p 2222 github地址https://github.com/hqd8080/sshd_builder","categories":[{"name":"Docker","slug":"Docker","permalink":"https://hqd8080.github.io/categories/Docker/"}],"tags":[{"name":"docker","slug":"docker","permalink":"https://hqd8080.github.io/tags/docker/"}]},{"title":"Git常用命令整理","slug":"git/git-command","date":"2020-05-24T10:40:28.000Z","updated":"2022-11-08T07:22:50.518Z","comments":true,"path":"2020/05/24/git/git-command/","link":"","permalink":"https://hqd8080.github.io/2020/05/24/git/git-command/","excerpt":"","text":"Git常用命令整理初始化设置123git config --global user.name &quot;&lt;用户名&gt;&quot; #设置用户名git config --global user.email &quot;&lt;电子邮件&gt;&quot; #设置电子邮件 本地操作12345git add [-i] #保存更新，-i为逐个确认git status #检查更新git commit [-a] -m &quot;&lt;更新说明&gt;&quot; #提交更新，-a为(all)包含内容修改和增删，-m为说明信息，也可以使用 -am 远端操作123456789101112131415161718192021git clone #克隆项目到本地git fetch #远端抓取git merge #与本地当前分支合并git pull [&lt;远端别名&gt;] [&lt;远端branch&gt;] #抓取并合并,相当于第2、3步git push [-f] [&lt;远端别名&gt;] [&lt;远端branch&gt;] #推送到远端，-f为强制覆盖git remote add &lt;别名&gt; #设置远端别名git remote [-v] #列出远端，-v为详细信息git remote show &lt;远端别名&gt; #查看远端信息git remote rename &lt;远端别名&gt; &lt;新远端别名&gt; #重命名远端git remote rm &lt;远端别名&gt; #删除远端git remote update [&lt;远端别名&gt;] #更新分支列表 分支相关12345678910111213git branch [-r] [-a] #列出分支，-r远端 ,-a全部git branch &lt;分支名&gt; #新建分支git branch -b &lt;分支名&gt; #新建并切换分支git branch -d &lt;分支名&gt; #删除分支git checkout &lt;分支名&gt; #切换到分支git checkout -b &lt;本地branch&gt; [-t &lt;远端别名&gt;/&lt;远端分支&gt;] #-b新建本地分支并切换到分支, -t绑定远端分支git merge &lt;分支名&gt; #合并某分支到当前分支 Git使用例子1234workspace:本地的工作目录（记作A）index:缓存区域，临时保存本地改动（记作B）local repository:本地仓库，只想最后一次提交HEAD（记作C）remote repository:远程仓库（记作D） 初始化1234567git init #项目初始化git clone /path/to/repository #检出，可重命名git config --global user.email &quot;you@163.com&quot; #配置emailgit config --global user.name &quot;hqd8080&quot; #配置用户名 操作1234567891011121314151617181920git add # 文件添加，A → Bgit add . # 所有文件添加，A → Bgit commit -m &quot;代码提交信息&quot; # 文件提交，B → Cgit commit --amend # 与上次commit合并, *B → Cgit push origin master # 推送至master分支, C → Dgit pull # 更新本地仓库至最新改动， D → Agit fetch # 抓取远程仓库更新， D → Cgit log # 查看提交记录,git log -5git status # 查看修改状态git diff # 查看详细修改内容git show # 显示某次提交的内容 撤销操作1234567891011git reset # 某个文件索引会回滚到最后一次提交， C → Bgit reset # 索引会回滚到最后一次提交， C → Bgit reset --hard # 索引会回滚到最后一次提交， C → B → Agit checkout # 从index复制到workspace， B → Agit checkout -- files # 文件从index复制到workspace， B → Agit checkout HEAD -- files # 文件从local repository复制到workspace， C → A 分支相关1234567891011git checkout -b branch_name # 创建名叫“branch_name”的分支，并切换过去git checkout master # 切换回主分支git branch -d branch_name # 删除名叫“branch_name”的分支git push origin branch_name # 推送分支到远端仓库git merge branch_name # 合并分支branch_name到当前分支(如master)git rebase # 衍合，线性化的自动， D → A 冲突处理1234567git diff # 对比workspace与indexgit diff HEAD # 对于workspace与最后一次commitgit diff # 对比差异git add # 修改完冲突，需要add以标记合并成功 其他1234567gitk # 开灯图形化gitgit config color.ui true # 彩色的 git 输出git config format.pretty oneline # 显示历史记录时，每个提交的信息只显示一行git add -i # 交互式添加文件到暂存区","categories":[{"name":"Git","slug":"Git","permalink":"https://hqd8080.github.io/categories/Git/"}],"tags":[{"name":"git","slug":"git","permalink":"https://hqd8080.github.io/tags/git/"}]},{"title":"Docker常用命令说明（总结）","slug":"docker/docker-summary","date":"2020-05-24T09:01:26.000Z","updated":"2021-08-31T08:34:15.000Z","comments":true,"path":"2020/05/24/docker/docker-summary/","link":"","permalink":"https://hqd8080.github.io/2020/05/24/docker/docker-summary/","excerpt":"","text":"获取镜像： 1234sudo docker pull ubuntu #(ubuntu:latest,获取最新版本的镜像)sudo docker pull ubuntu:14.04 #(指定标签来下载指定版本的镜像)sudo docker pull registory.hub.docker.com/ubutu:latest #(相当于以上两个命令的组合)sudo docker pull dl.dockerpoll.com:5000/ubuntu #从dl.dockerpoll.com下载镜像 利用镜像创建容器，在其中运行bash: 1sudo docker run -t -i ubuntu /bin/bash 查看本地已有镜像： 12sudo docker imagessudo docker images -a 创建新的标签: ＃（使用docker tag创建新的标签d.dockerpoll.com:5000/ubuntu:latest） 123sudo docker tag d.dockerpoll.com:5000/ubuntu:latest ubuntu:latestsudo docker inspect image id #查看镜像的详细信息,json格式sudo docker inspect -f &#123;&#123;.Architecture&#125;&#125; 550 #查看其中的一项信息 搜索镜像： 12sudo docker search #搜索远端仓库中共享的镜像，默认搜索docker Hub官方仓库的镜像sudo docker search mysql 删除镜像： 123sudo docker rmi IMAGEsudo docker rmi dl.dockerpool.com:20000/ubuntusudo docker rmi -f ubuntu #强制删除镜像（有容器在运行时和存在要删除的镜像容器一般删除不了） 不推荐强制删除镜像，正确的做法是，先删除镜像的容器然后在删除镜像 1sudo docker ps -a #查看本机上存在的所有容器 创建镜像：（３种） #1.基于已有镜像的容器创建 基于本地模板导入#2.基于Dockerfile创建#3.基于已有镜像的容器创建： 1sudo docker run -ti ubuntu:14.04 /bin/bash #(基于ubuntu14.04创建) 记住容器ID xxxxx 1sudo docker commit -m&quot;Added a new file&quot; -a &quot;docker newbee&quot; xxxxx test #test是tag 基于本地模板导入： 1sudo cat ubuntu-14.04-x86_64-minimal.tar.gz | docker import - ubuntu:14.04 存入和载入镜像 12存入镜像：sudo docker save -o ubuntu_14.04.tar ubuntu:14.04载入镜像：sudo docker load -input ubuntu_14.04.tar 或者 sudo docker load &lt; ubuntu_14.04.tar 上传镜像： 12sudo docker tar test:latest user/test:latestsudo docker push user/test:latest 新建容器 12345sudo docker create -it ubuntu:latestsudo docker ps -asudo docker startsudo docker run ubuntu /bin/echo &#x27;hello world&#x27;sudo docker run -t -i ubuntu:14.04 /bin/bash (启动一个bash终端,允许用户进行交互)，-t: 让docker分配一个伪终端,并绑定到容器的标准输入上-i：让容器的标准输入保持打开 终止容器： 1234sudo docker stop ce5sudo docker ps -a -q#查看终止状态的容器ID信息sudo docker start ce5#启动终止状态的容器sudo docker restart ce5#启动终止状态的容器 进入容器： 1sudo docker exec -ti 容器ID /bin/bash 删除容器： 123sudo docker ps -asudo docker rm 容器IDsudo docker rm -f 容器ID 导入和导出容器： 12sudo docker export ce5&gt;test_for_run_tarcat test_for_run_tar | sudo docker import - test/ubuntu:v1.0","categories":[{"name":"Docker","slug":"Docker","permalink":"https://hqd8080.github.io/categories/Docker/"}],"tags":[{"name":"docker","slug":"docker","permalink":"https://hqd8080.github.io/tags/docker/"}]},{"title":"理解Docker容器container","slug":"docker/docker-container","date":"2020-05-24T08:59:56.000Z","updated":"2021-09-01T09:14:26.000Z","comments":true,"path":"2020/05/24/docker/docker-container/","link":"","permalink":"https://hqd8080.github.io/2020/05/24/docker/docker-container/","excerpt":"","text":"Docker容器容器是镜像的一个运行实例，所不同的是，镜像是静态的只读文件，而容器带有运行时需要的可写文件层1234docker create -it ubuntu:latest //(处于停止状态,docker start启动)docker ps -a //查看所有的容器docker start 容器id //启动docker stop 容器id //停止 创建容器并启动容器123456docker run ubuntu /bin/echo &#x27;hello world&#x27;(自动终止)docker run -it ubuntu:18.04 /bin/bash#(启动一个bash终端,允许用户进行交互)#-t: 让docker分配一个伪终端,并绑定到容器的标准输入上#-i：让容器的标准输入保持打开 守护态运行1234567docker run -d ubuntu /bin/sh -c &quot;test&quot;#终止容器docker stop ce5docker ps -a -q #查看终止状态的容器ID信息docker start ce5 #启动终止状态的容器docker restart ce5 #启动终止状态的容器 查看某个容器的输出日志1docker logs ce554267d7a4 进入容器（最为推荐的方式）1docker exec -it 容器ID /bin/bash 删除容器（只能删除处于终止状态或退出状态的容器，不能删除运行状态的容器）123456sudo docker ps -asudo docker rm 容器IDsudo docker rm -f 容器ID#查看正在运行的容器docker ps 导入和导出容器：123docker export ce5&gt;test_for_run_tarcat test_for_run_tar | docker import - test/ubuntu:v1.0","categories":[{"name":"Docker","slug":"Docker","permalink":"https://hqd8080.github.io/categories/Docker/"}],"tags":[{"name":"docker","slug":"docker","permalink":"https://hqd8080.github.io/tags/docker/"}]},{"title":"理解Docker的镜像image","slug":"docker/docker-image","date":"2020-05-24T08:58:48.000Z","updated":"2022-11-08T07:22:49.564Z","comments":true,"path":"2020/05/24/docker/docker-image/","link":"","permalink":"https://hqd8080.github.io/2020/05/24/docker/docker-image/","excerpt":"","text":"Docker通过容器来打包应用，（环境和代码）Docker的三大核心概念： 1.镜像（image） 2.容器（container） 3.仓库（repository） 镜像：类似于虚拟机环境，只读的模板，镜像是创建容器的基础 容器：从镜像创建的应用运行实例，盒子，沙箱，互不可见，隔离 仓库：docker集中存放镜像的场所，类似代码仓库 Docker仓库和仓库注册服务器的关系仓库注册服务器是存放仓库的地方，每个仓库集中存放某一类镜像，通过不同的tag来区分(类似git管理) 注册服务器 --&gt; 创库 --&gt; 各种仓库的不同tag版本 将当前用户加入安装中自带的Docker组1sudo usermod -aG docker hqd8080 获取镜像123docker pull name:tag //(名称+标签)docker pull ubuntu:18.04 //默认从官方拉取docker pull ubuntu //下载最新的镜像,默认是(ubuntu:latest) 从网易丰巢下载镜像1docker pull hub.c.163.com/public/ubuntu:18.04 通过镜像创建容器1docker run -it ubuntu:18.04 bash 查看镜像信息12docker imagesdocker images -a 使用tag给已经存在的镜像打标签1docker tag ubuntu:18.04 myubuntu:latest 使用history查看镜像历史,列出各层的创建信息123docker history ubuntu:18.04#详细信息(不截断)docker history ubuntu:18.04 --no-trunc 搜索镜像（远端仓库共享镜像|官方）1docker search ubuntu 删除镜像1234567891011docker rmi myubuntu:latestdocker images -a#使用镜像ID删除镜像的相关注意事项#有容器正在运行无法通过ID直接删除镜像，必须先删除依赖的容器，或者用-f强制删除docker run ubuntu:18.04 echo &#x27;hello hqd8080&#x27;docker ps -adocker rmi ubuntu:18.04docker rmi -f ubuntu:18.04docker rm a5212cvvbdgfsh // 使用镜像ID删除镜像 创建镜像的三种方法：1.基于已有的镜像的容器创建 123sudo docker run -ti ubuntu:18.04 /bin/bash #(基于ubuntu18.04创建)#记住容器ID xxxxxsudo docker commit -m&quot;Added a new file&quot; -a &quot;docker newbee&quot; xxxxx test #test是tag 2.基于本地模版导入创建 1sudo cat ubuntu-18.04-x86_64-minimal.tar.gz | docker import - ubuntu:18.04 3.基于dockerfile创建 存入和载入镜像12345#存入镜像sudo docker save -o ubuntu_18.04.tar ubuntu:18.04#载入镜像sudo docker load —input ubuntu_18.04.tar 或者 sudo docker load &lt; ubuntu_18.04.tar","categories":[{"name":"Docker","slug":"Docker","permalink":"https://hqd8080.github.io/categories/Docker/"}],"tags":[{"name":"docker","slug":"docker","permalink":"https://hqd8080.github.io/tags/docker/"}]},{"title":"理解Docker的仓库","slug":"docker/docker-warehouse","date":"2020-05-24T08:58:17.000Z","updated":"2021-09-01T09:26:03.000Z","comments":true,"path":"2020/05/24/docker/docker-warehouse/","link":"","permalink":"https://hqd8080.github.io/2020/05/24/docker/docker-warehouse/","excerpt":"","text":"Docker仓库仓库是集中存放镜像的地方，可分为公共仓库和私有仓库 注册服务器是存放仓库的具体服务器，一个注册服务器可以有多个仓库，而每个仓库下面可以有多个镜像 private-docker.com/ubuntu:（private-docker.com是注册服务器ubuntu是仓库名） docker hub公共镜像市场 https://hub.docker.com/ 搜索官方镜像，并下载 123sudo docker search -s 5 centossudo docker pull cenros Docker数据管理容器数据管理的两种方式 数据卷：容器内数据直接映射到本地主机环境 数据卷容器：使用特定容器维护数据卷 数据卷：一个可以供容器使用的特殊目录，它将主机操作系统目录直接映射进容器 在容器内创建数据卷挂载一个主机目录作为数据卷 1docker run -d -P --name web -v /src/webapp:/opt/webapp training/webapp python app.py 加载主机目录/src/webapp到容器/opt/webapp使用training/webapp创建一个容器web 数据卷容器操作例子创建一个数据卷容器dbdata1docker run -it -v /dbdata --name dbdata ubuntu ok之后在其他容器中使用--volumes-from来挂载dbdata容器中的数据卷，例如db1,db2两个容器，并从dbdata容器挂载数据卷 docker run -it --volumes-from dbdata --name db1 ubuntu docker run -it --volumes-from dbdata --name db2 ubuntu 这样三个容器都能共享数据 端口映射和容器互联容器互联的使用 创建数据库容器 1docker run -d --name db training/postgres 创建一个新的web容器，并将它连接db容器 1docker run -d -P --name web --link db:db training/webapp python app.py 使用Dockerfile创建镜像 Dockerfile文本格式的配置文件 run命令：对镜像执行命令，每一个run指令，镜像就添加新的一层 cmd命令：对容器执行命令 指令说明： from：指定创建镜像的基础镜像 run：运行命令 cmd：指定启动容器时默认执行的指令 add：从主机复制文件到容器 copy：复制主机路径下的内容到容器，目标路径不存在时，会自动创建 创建镜像docker build .","categories":[{"name":"Docker","slug":"Docker","permalink":"https://hqd8080.github.io/categories/Docker/"}],"tags":[{"name":"docker","slug":"docker","permalink":"https://hqd8080.github.io/tags/docker/"}]},{"title":"Ubuntu16.04LTS安装docker","slug":"docker/docker-install-ubuntu1604","date":"2020-05-24T07:29:05.000Z","updated":"2021-09-01T08:28:56.000Z","comments":true,"path":"2020/05/24/docker/docker-install-ubuntu1604/","link":"","permalink":"https://hqd8080.github.io/2020/05/24/docker/docker-install-ubuntu1604/","excerpt":"","text":"查看系统版本信息1cat /etc/issue Ubuntu 16.04.2 LTS \\n \\l 在ubuntu上简单的安装方法12sudo apt-get updatesudo apt-get install docker 搞定!（这种安装方法的缺点是安装的docker版本不是最新的版本）下面介绍推荐的安装docker方式 注意(Docker需要64的操作系统,此外你的kernel内核至少要在3.10版本之上)官方的参考文档： https://docs.docker.com/engine/installation/linux/ubuntulinux/ 12sudo apt-get updatesudo apt-get install apt-transport-https ca-certificates 导入gpg密钥123sudo apt-key adv \\ —keyserver hkp://ha.pool.sks-keyservers.net:80 \\ —recv-keys 58118E89F3A912897C070ADBF76221572C52609D 添加docker源，其它版本添加请参照官方文档，官方只提供LTS版本的源找到对应版本的源地址，16.04对应到源地址为: 1deb https://apt.dockerproject.org/repo ubuntu-xenial main 执行命令添加源1echo &quot;deb https://apt.dockerproject.org/repo ubuntu-xenial main&quot; | sudo tee /etc/apt/sources.list.d/docker.list 更新源1sudo apt-get update 查看可安装列表(这步可以略过)1apt-cache policy docker-engine 安装 默认安装最近的版本1sudo apt-get install docker-engine 启动1sudo service docker start 运行hello world1sudo docker run hello-world 结果:123456789101112131415Hello from Docker!This message shows that your installation appears to be working correctly.To generate this message, Docker took the following steps: The Docker client contacted the Docker daemon. The Docker daemon pulled the “hello-world” image from the Docker Hub. The Docker daemon created a new container from that image which runs theexecutable that produces the output you are currently reading. The Docker daemon streamed that output to the Docker client, which sent itto your terminal.To try something more ambitious, you can run an Ubuntu container with:$ docker run -it ubuntu bashShare images, automate workflows, and more with a free Docker Hub account:https://hub.docker.comFor more examples and ideas, visit:https://docs.docker.com/engine/userguide/ 如果出现网络问题无法下载，就先从网易蜂巢的镜像市场到hello-world运行docker run hub.c.163.com/library/hello-world 或者先pull后run1docker pull hub.c.163.com/library/hello-world:latest 以非管理员权限运行（每次运行要加sudo也不是事，对吧）创建docker用户组(默认已经创建)1sudo groupadd docker 将当前用户加到这个组里(不用改$USER这几个字，$USER这个环境变量就是指当前用户名) 1sudo usermod -aG docker $USER 再尝试运行1docker run hello-world 如果运行出现Cannot connect to the Docker daemon. Is the docker daemon running on this host? 官方文档提示你设置环境变量，其实没什么用，从网上看到很多结果都是无意中突然好了~ 事实上是因为加入用户组这个东西必须注销或重启才能生效，你注销或者重启一下马上就好了 常用命令1234docker version #查看版本docker images #查看镜像列表docker images -a #查看镜像列表docker rmi -f [镜像id] #删除指定镜像","categories":[{"name":"Docker","slug":"Docker","permalink":"https://hqd8080.github.io/categories/Docker/"}],"tags":[{"name":"docker","slug":"docker","permalink":"https://hqd8080.github.io/tags/docker/"}]},{"title":"Dockerfile实战构建自己的基础镜像","slug":"docker/docker-create-base-img","date":"2020-05-24T07:14:39.000Z","updated":"2022-11-08T07:22:49.486Z","comments":true,"path":"2020/05/24/docker/docker-create-base-img/","link":"","permalink":"https://hqd8080.github.io/2020/05/24/docker/docker-create-base-img/","excerpt":"","text":"以下是docker Hub上下载官方仓库的ubuntu14.04镜像(188M)，用它来构建合适自己的ubuntu基础镜像 12345678910111213141516171819202122#this dockerfile uses the ubuntu image使用docker Hub官方的ubuntu14.04镜像构建version 0.1author: hqd8080指定所创建镜像的基础镜像FROM ubuntu:14.04#维护者信息MAINTAINER github.com/hqd8080#指定镜像生成的元数据标签信息LABEL version=&quot;0.1&quot;LABEL description=&quot;ubuntu14.04 base image&quot;#将复制指定的文件到容器中#格式:ADD #例子:ADD *.c /code/ADD sources.list /etc/apt/#CMD用来启动容器时默认执行的命令CMD [&quot;/bin/bash&quot;] 构建sudo docker build -t=&quot;hqd8080/my_ubuntu:14.04_base_images&quot; . 123sudo docker build中-t表示容器的名字hqd8080/my_ubuntu中navas表示仓库名（不允许大写）,my_ubuntu表示镜像名my_ubuntu:14.04_base_images后的14.04_base_images是标签,如果没有指定,默认的是latest 1234#hqd8080$ tree.├── Dockerfile├── README.md└── sources.list(从我当前的系统复制过来) 12Successfully built 1a00f5985fdcSuccessfully tagged navas/my_ubuntu:14.04_base_images 查看镜像sudo docker images -a","categories":[{"name":"Docker","slug":"Docker","permalink":"https://hqd8080.github.io/categories/Docker/"}],"tags":[{"name":"docker","slug":"docker","permalink":"https://hqd8080.github.io/tags/docker/"}]},{"title":"Ubuntu安装docker-compose","slug":"docker/docker-install-decker-compose","date":"2020-05-24T06:52:29.000Z","updated":"2021-09-01T08:29:29.000Z","comments":true,"path":"2020/05/24/docker/docker-install-decker-compose/","link":"","permalink":"https://hqd8080.github.io/2020/05/24/docker/docker-install-decker-compose/","excerpt":"","text":"docker-compose的下载地址为:https://github.com/docker/compose/releases 以下以docker-compose1.16.1版本安装为例子：1curl -L https://github.com/docker/compose/releases/download/1.16.1/docker-compose-`uname -s`-`uname -m` &gt; /usr/local/bin/docker-compose 1chmod +x /usr/local/bin/docker-compose 如果报错：bash: /usr/local/bin/docker-compose: 权限不够 请切换超级管理员sudo -i 然后再执行chmod +x /usr/local/bin/docker-compose 安装成功查看信息:docker-compose --version docker-compose version 1.16.1, build 6d1ac21","categories":[{"name":"Docker","slug":"Docker","permalink":"https://hqd8080.github.io/categories/Docker/"}],"tags":[{"name":"docker","slug":"docker","permalink":"https://hqd8080.github.io/tags/docker/"}]},{"title":"Ubuntu系统docker解决sudo权限问题","slug":"docker/docker-power","date":"2020-05-24T06:41:02.000Z","updated":"2021-09-01T08:29:45.000Z","comments":true,"path":"2020/05/24/docker/docker-power/","link":"","permalink":"https://hqd8080.github.io/2020/05/24/docker/docker-power/","excerpt":"","text":"如果还没有 docker group 就添加一个：1sudo groupadd docker 将用户加入该 group 内,然后退出并重新登录就生效1sudo gpasswd -a $&#123;USER&#125; docker 重启 docker 服务1systemctl restart docker 切换当前会话到新 group 或者重启 X 会话1newgrp - docker 注意:最后一步是必须的，否则因为 groups 命令获取到的是缓存的组信息，刚添加的组信息未能生效所以 docker images 执行时同样有错","categories":[{"name":"Docker","slug":"Docker","permalink":"https://hqd8080.github.io/categories/Docker/"}],"tags":[{"name":"docker","slug":"docker","permalink":"https://hqd8080.github.io/tags/docker/"}]},{"title":"Docker安装MySQL8.0","slug":"docker/docker-install-mysql","date":"2020-05-24T06:15:24.000Z","updated":"2021-08-31T08:34:15.000Z","comments":true,"path":"2020/05/24/docker/docker-install-mysql/","link":"","permalink":"https://hqd8080.github.io/2020/05/24/docker/docker-install-mysql/","excerpt":"","text":"Docker安装MySQL8.0拉取最新版mysql镜像docker pull mysql 查看镜像docker images -a 运行容器docker run -p 3306:3306 --name mysql -e MYSQL_ROOT_PASSWORD=123456 -d mysql:latest 123–name： 容器名，此处命名为mysql-e： 配置信息，此处配置mysql的root用户的登录密码-p： 端口映射，此处映射 主机3306端口 到 容器的3306端口 如果要建立目录映射 1234567docker run -p 3306:3306 --name mysql \\-v /usr/local/docker/mysql/conf:/etc/mysql \\-v /usr/local/docker/mysql/logs:/var/log/mysql \\-v /usr/local/docker/mysql/data:/var/lib/mysql \\-e MYSQL_ROOT_PASSWORD=123456 \\-d mysql:latest-v：主机和容器的目录映射关系，&quot;:&quot;前为主机目录，之后为容器目录 检查容器是否正确运行docker container ls | docker ps -a 进入容器 12docker exec -it mysql bashmysql -uroot -p123456 宿主机链接容器的mysql（远程连接mysql）我们在创建容器的时候已经将容器的3306端口和主机的3306端口映射到一起，所以我们应该访问： 1234host: 127.0.0.1port: 3306user: rootpassword: 123456 如果你的容器运行正常，但是无法访问到MySQL，一般有以下几个可能的原因： caching_sha2_password问题为了提供更安全的密码加密MySQL8.0的首选默认认证插件是，caching_sha2_password而不是mysql_native_password 123456789101112131415mysql&gt; use mysql;mysql&gt; select host, user, plugin from user;+-----------+------------------+-----------------------+| host | user | plugin |+-----------+------------------+-----------------------+| % | root | mysql_native_password || localhost | mysql.infoschema | caching_sha2_password || localhost | mysql.session | caching_sha2_password || localhost | mysql.sys | caching_sha2_password || localhost | root | mysql_native_password |+-----------+------------------+-----------------------+ALTER USER &#x27;root&#x27;@&#x27;%&#x27; IDENTIFIED WITH mysql_native_password BY &#x27;123456&#x27;;ALTER USER &#x27;root&#x27;@&#x27;localhost&#x27; IDENTIFIED WITH mysql_native_password BY &#x27;123456&#x27;;flush privileges; 或者 1234567docker exec -it mysql bashmysql -uroot -p123456配置 mysql.cnf 配置默认身份验证插件/etc/mysql/ [mysqld]default_authentication_plugin = mysql_native_password 防火墙阻拦 开放端口：systemctl status firewalldfirewall-cmd --zone=public --add-port=3306/tcp -permanentfirewall-cmd --reload 关闭防火墙：systemctl stop firewalld 需要进入docker本地客户端设置远程访问账号 1234docker exec -it mysql bashmysql -uroot -p123456grant all privileges on *.* to root@&#x27;%&#x27; identified by &quot;password&quot;; mysql使用mysql数据库中的user表来管理权限，修改user表就可以修改权限（只有root账号可以修改） 1234567891011121314151617use mysql;select host, user, plugin from user;+-----------+------------------+-----------------------+| host | user | plugin |+-----------+------------------+-----------------------+| % | root | mysql_native_password || localhost | mysql.infoschema | caching_sha2_password || localhost | mysql.session | caching_sha2_password || localhost | mysql.sys | caching_sha2_password || localhost | root | mysql_native_password |+-----------+------------------+-----------------------+grant all privileges on *.* to root@&#x27;%&#x27; identified by &quot;password&quot;;flush privileges;","categories":[{"name":"Docker","slug":"Docker","permalink":"https://hqd8080.github.io/categories/Docker/"}],"tags":[{"name":"docker","slug":"docker","permalink":"https://hqd8080.github.io/tags/docker/"}]},{"title":"Git清除项目版本控制信息","slug":"git/git-clear","date":"2020-05-23T12:40:28.000Z","updated":"2024-04-08T13:26:15.275Z","comments":true,"path":"2020/05/23/git/git-clear/","link":"","permalink":"https://hqd8080.github.io/2020/05/23/git/git-clear/","excerpt":"","text":"首先进入项目目录下: cd project 然后执行: find . -name &quot;.git&quot; | xargs rm -rf","categories":[{"name":"Git","slug":"Git","permalink":"https://hqd8080.github.io/categories/Git/"}],"tags":[{"name":"git","slug":"git","permalink":"https://hqd8080.github.io/tags/git/"}]},{"title":"分布式系统中的CAP原理（二）","slug":"microservice/microservice-cap","date":"2020-05-22T15:40:28.000Z","updated":"2024-03-17T14:21:40.267Z","comments":true,"path":"2020/05/22/microservice/microservice-cap/","link":"","permalink":"https://hqd8080.github.io/2020/05/22/microservice/microservice-cap/","excerpt":"","text":"分布式系统中的CAP原理CAP：描述分布式系统下，节点数据同步的基本定理 1231.一致性2.可用性3.分区容忍性 以上三个指标不可能同时满足，分布式系统分区容忍性是必须要满足的","categories":[{"name":"微服务架构","slug":"微服务架构","permalink":"https://hqd8080.github.io/categories/%E5%BE%AE%E6%9C%8D%E5%8A%A1%E6%9E%B6%E6%9E%84/"}],"tags":[{"name":"微服务","slug":"微服务","permalink":"https://hqd8080.github.io/tags/%E5%BE%AE%E6%9C%8D%E5%8A%A1/"},{"name":"microservice","slug":"microservice","permalink":"https://hqd8080.github.io/tags/microservice/"}]},{"title":"微服务学习笔记（一）","slug":"microservice/microservice","date":"2020-05-22T15:40:28.000Z","updated":"2024-03-17T14:21:35.165Z","comments":true,"path":"2020/05/22/microservice/microservice/","link":"","permalink":"https://hqd8080.github.io/2020/05/22/microservice/microservice/","excerpt":"","text":"微服务学习微服务核心组件：1234567- 1.服务注册与发现- 2.远程过程调用RPC- 3.分布式配置中心- 4.微服务网关- 5.微服务的容错处理与负载均衡- 6.统一认证与授权- 7.分布式链式追踪 微服务设计的6大原则：123456- 1.高内聚，低耦合- 2.高度自治- 3.以业务为中心- 4.弹性设计- 5.日志与监控- 6.自动化 微服务架构：将单体应用转化为多个可以；独立开发；独立部署；独立运行；和独立维护的服务或者应用的集合； 微服务的理解：是指将大型复杂软件应用拆分成多个简单应用；每个应用描述着一个小业务；系统中的应用可被独立部署；每个微服务仅关注于完成一个业务；单一原则、分而治之、模块化； 微服务的特点：1234- 1.独立开发；独立部署；独立运行- 2.微服务之间采用RESTful API或者RPC等协议通信- 3.微服务遵循单一原则- 4.微服务一般使用容器部署 微服务的缺点：123- 1.服务拆分过多；服务治理成本较高；不利于系统维护；- 2.服务之间相互依赖；有可能形成复杂的依赖链条；出现服务雪崩效应；- 3.服务实例之间交互需要处理分布式事务，调用幂等和重试等问题； SOA和微服务的区别：1- SOA注重的是系统集成；而微服务关注的是完全分离； Go语言的微服务框架：1go-kit 应用程序架构由三部分组成：传输层；接口层；服务层； 12go-micro插件化的RPC微服务框架；提供了（服务发现）；（负载均衡）；（同步传输）；（异步通信）；（事件驱动）； 组件化的微服务框架；组件是分层的；上层基于下层功能继续向上提供服务； go-micro框架中的组件介绍（7个）可插拔的架构设计理念：1234567- Registry：服务发现组件（提供服务发现机制；解析服务名称至服务地址；目前支持的注册中心；etcd；consul；zookeeper）- Selector：基于Registry的客户端负载均衡组件；client组件使用selector组件从Registry返回的服务列表中进行负载均衡选择；- Broker：发布和订阅组件；服务之间基于消息中间件的异步通信方式；kafka；rabbitMQ等；- Transport：服务之间同步通信方式- Codec：服务之间的编码和解码组件- Server：服务主体，对外提供 统一的服务请求入口- Client：提供访问微服务的客户端； go-kit和go-micro的区别：12go-kit 是一个微服务的标准库；go-kit提供了独立的包；通过这些包开发者可以组件自己的应用程序；go-micro 是一个面向微服务的可插拔RPC框架；它尝试使用组件的方式简化分布式系统之间的通信； 微服务设计的6大原则123456- 1.（高内聚，低耦合）单一职责；轻量级通信；服务之间的契约- 2.（高度自治）能独立开发；部署；发布；进程隔离；独立的代码库；流水线；- 3.（以业务为中心）每个微服务代表了特定的业务逻辑；能更快的响应业务变化；- 4.（弹性设计）容错；服务降级；- 5.（日志与容错）日志集合；监控和警告；- 6.（自动化）持续集成；持续交付； 领域驱动设计（DDD）领域驱动设计是一种思想；一种方法论；对软件系统进行合理拆分；最终的目标还是，高内聚，低耦合；领域驱动设计分层 （微服务的划分粒度）1234- 1.用户界面（表现层或接口层） User interface- 2.应用层 Application- 3.领域层 Domain - 4.基础实施层 Infrastructure","categories":[{"name":"微服务架构","slug":"微服务架构","permalink":"https://hqd8080.github.io/categories/%E5%BE%AE%E6%9C%8D%E5%8A%A1%E6%9E%B6%E6%9E%84/"}],"tags":[{"name":"微服务","slug":"微服务","permalink":"https://hqd8080.github.io/tags/%E5%BE%AE%E6%9C%8D%E5%8A%A1/"},{"name":"microservice","slug":"microservice","permalink":"https://hqd8080.github.io/tags/microservice/"}]},{"title":"Git flow","slug":"git/git-flow","date":"2020-05-22T12:40:28.000Z","updated":"2022-03-04T02:34:39.000Z","comments":true,"path":"2020/05/22/git/git-flow/","link":"","permalink":"https://hqd8080.github.io/2020/05/22/git/git-flow/","excerpt":"","text":"git flow 1.master主分支，存放稳定的项目版本，这个分支主要是从别的分支合并过来，不会直接在这个分支上提交 2.develop开发分支，当要新增新功能时，所有的feature分支都是从这个分支划分出去的，而feature分支功能完成后也会合并回develop分支 3.hotfix分支，当线上发生紧急问题时，从master分支划分出hotfix进行紧急问题修复，修复完成合并回master，同时合并回develop分支 4.release分支，发布线上分支，develop分支足够成熟可合并到release分支 5.feature分支，新增功能的分支，从develop分支划出，完成后合并回develop分支 新建新分支1git branch new-branch 新建分支并且切换至新分支1git checkout -b new-branch 查看分支123git branch 当前分支git branch -a 所有分支git branch -r 远程分支 修改分支名称，development改成develop1git branch -m development develop 删除分支1git branch -d develop 强制删除，还没合并的分支也能删除1git branch -D dev 查看提交记录1git log --oneline git切换分支做的事情 1.更新暂存区和工作目录 2.变更HEAD的位置","categories":[{"name":"Git","slug":"Git","permalink":"https://hqd8080.github.io/categories/Git/"}],"tags":[{"name":"git","slug":"git","permalink":"https://hqd8080.github.io/tags/git/"}]},{"title":"Go启动10个goroutine处理任务的例子","slug":"golang/go-chan","date":"2020-05-22T12:40:28.000Z","updated":"2023-10-24T06:05:43.749Z","comments":true,"path":"2020/05/22/golang/go-chan/","link":"","permalink":"https://hqd8080.github.io/2020/05/22/golang/go-chan/","excerpt":"","text":"Go语言启动10个goroutine处理任务的例子 1234567891011121314151617181920212223242526package mainimport ( &quot;fmt&quot; &quot;time&quot;)func main() &#123; channels := make([]chan int, 10) for i := 0; i &lt; 10; i++ &#123; channels[i] = make(chan int) go process(channels[i]) &#125; for i, ch := range channels &#123; &lt;-ch fmt.Println(&quot;routine:&quot;, i, &quot;quit&quot;) &#125;&#125;func process(ch chan int) &#123; // 模拟处理任务 time.Sleep(time.Second) ch &lt;- 1&#125; 输出 12345678910routine: 0 quitroutine: 1 quitroutine: 2 quitroutine: 3 quitroutine: 4 quitroutine: 5 quitroutine: 6 quitroutine: 7 quitroutine: 8 quitroutine: 9 quit","categories":[{"name":"Go语言","slug":"Go语言","permalink":"https://hqd8080.github.io/categories/Go%E8%AF%AD%E8%A8%80/"}],"tags":[{"name":"golang","slug":"golang","permalink":"https://hqd8080.github.io/tags/golang/"}]},{"title":"Go的字符串和整型转换","slug":"golang/go-data-type-convert","date":"2020-05-22T12:40:28.000Z","updated":"2023-10-07T11:33:29.341Z","comments":true,"path":"2020/05/22/golang/go-data-type-convert/","link":"","permalink":"https://hqd8080.github.io/2020/05/22/golang/go-data-type-convert/","excerpt":"","text":"Go语言的字符串和整型转换 字符串转数字 12345// string to int int, err := strconv.Atoi(string)// string to int64int64, err := strconv.ParseInt(string, 10, 64) 数字转字符串 12345// int to string string := strconv.Itoa(int)// int64 to string string := strconv.FormatInt(int64, 10)","categories":[{"name":"Go语言","slug":"Go语言","permalink":"https://hqd8080.github.io/categories/Go%E8%AF%AD%E8%A8%80/"}],"tags":[{"name":"golang","slug":"golang","permalink":"https://hqd8080.github.io/tags/golang/"}]},{"title":"Go语言GPM并发模型","slug":"golang/go-gmp","date":"2020-05-22T12:40:28.000Z","updated":"2023-10-07T11:33:55.096Z","comments":true,"path":"2020/05/22/golang/go-gmp/","link":"","permalink":"https://hqd8080.github.io/2020/05/22/golang/go-gmp/","excerpt":"","text":"Go语言的G-P-M模型G：goroutine,表示一个协程对象，用go关键字加函数调用即可创建一个G对象，它是对并发执行任务的封装，也可以看作是一种特殊的协程，G属于用户级资源，对操作系统透明，非常轻量级，可以大量创建，且上下文切换成本比较低 M：machine的简称，可以看作是利用系统调用创建出来的操作系统上的线程实体，M的作用就是执行G中封装的并发任务，M属于操作系统资源，可创建的数量受限于操作系统， 一般来说G的数量都多于M的数量 P：processor的简称，表示逻辑处理器，每个P都有一个G队列，主要用于管理G对象，并为G在M上的运行提供本地化资源 M与P是一对一的关系，M会从P的本地队列中弹出一个可运行状态的G来执行，如果P中的本地队列为空，就会执行窃取 进程，线程，协程的概念进程：process，进程是操作系统进行资源分配和调度的基本单位，是操作系统结构的基础，每个进程都有自己的独立内存空间，不同进程通过；进程间的通信机制来通信，进程间上下文的切换开销比较大，但相对比较稳定，安全。从理论上来讲，进程是对正在运行的程序过程的抽象 线程：thread，线程是进程中的一个实体，拥有自己独立的栈和共享堆，线程的切换一般是由操作系统调度，进程和线程是一对多的关系；一个进程由多个线程构成，而一个线程必属于一个进程 协程：goroutine，又称为轻量级的线程，协程是一种用户态的轻量级线程，调度完全由用户控制，协程拥有自己的寄存器上下文和栈，上下文的切换非常快，一个线程可以由多个协程组成 线程和协程的主要区别线程的调度方式是抢占式的，如果一个线程的执行时间超过了分配给它的时间片，那么它就会被其他可执行的线程抢占；协程的调度是协同式的，在协同式调度中没有时间片的概念，为了并发执行协程，调度器会在以下几种时间点对其进行切换： 1通道channel接收或者发送会造成阻塞的消息 2垃圾回收 3文件和网络操作","categories":[{"name":"Go语言","slug":"Go语言","permalink":"https://hqd8080.github.io/categories/Go%E8%AF%AD%E8%A8%80/"}],"tags":[{"name":"golang","slug":"golang","permalink":"https://hqd8080.github.io/tags/golang/"}]},{"title":"Go语言使用反射获取结构体中的Tag信息","slug":"golang/go-reflect","date":"2020-05-22T12:40:28.000Z","updated":"2023-10-24T06:04:36.799Z","comments":true,"path":"2020/05/22/golang/go-reflect/","link":"","permalink":"https://hqd8080.github.io/2020/05/22/golang/go-reflect/","excerpt":"","text":"Go语言使用反射获取结构体中的Tag信息 1234567891011121314151617181920212223242526272829303132package mainimport ( &quot;fmt&quot; &quot;reflect&quot;)type Cat struct &#123; Name string Attr string `json:&quot;attr&quot; id:&quot;222&quot;`&#125;func main() &#123; ins := Cat&#123; Name: &quot;BBA&quot;, Attr: &quot;BNW&quot;, &#125; t := reflect.TypeOf(ins) for i := 0; i &lt; t.NumField(); i++ &#123; field := t.Field(i) fmt.Println(field.Name) fmt.Println(field.Type) fmt.Println(field.Tag) &#125; fmt.Println(&quot;--------------------------&quot;) if f, ok := t.FieldByName(&quot;Attr&quot;); ok &#123; fmt.Println(f.Tag.Get(&quot;json&quot;)) fmt.Println(f.Tag.Get(&quot;id&quot;)) &#125;&#125; 12345678910NamestringAttrstringjson:&quot;attr&quot; id:&quot;222&quot;--------------------------attr222","categories":[{"name":"Go语言","slug":"Go语言","permalink":"https://hqd8080.github.io/categories/Go%E8%AF%AD%E8%A8%80/"}],"tags":[{"name":"golang","slug":"golang","permalink":"https://hqd8080.github.io/tags/golang/"}]},{"title":"Go语言启动4个协程处理10个任务的例子","slug":"golang/go-work","date":"2020-05-22T12:40:28.000Z","updated":"2023-10-24T06:03:45.081Z","comments":true,"path":"2020/05/22/golang/go-work/","link":"","permalink":"https://hqd8080.github.io/2020/05/22/golang/go-work/","excerpt":"","text":"Go语言启动4个协程处理10个任务的例子 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748package mainimport ( &quot;fmt&quot; &quot;math/rand&quot; &quot;sync&quot; &quot;time&quot;)const ( numberGoroutines = 4 taskLoad = 10)var wg sync.WaitGroupfunc init() &#123; rand.Seed(time.Now().Unix())&#125;func main() &#123; tasks := make(chan string, taskLoad) wg.Add(numberGoroutines) for i := 1; i &lt;= numberGoroutines; i++ &#123; go work(tasks, i) &#125; for post := 1; post &lt;= taskLoad; post++ &#123; tasks &lt;- fmt.Sprintf(&quot;Task:%d&quot;, post) &#125; close(tasks) wg.Wait()&#125;func work(tasks chan string, worker int) &#123; defer wg.Done() for &#123; task, ok := &lt;-tasks if !ok &#123; fmt.Printf(&quot;worker:%d shutting down(关闭)\\n&quot;, worker) return &#125; fmt.Printf(&quot;Worker:%d started %s\\n&quot;, worker, task) sleep := rand.Int63n(100) time.Sleep(time.Duration(sleep) * time.Millisecond) fmt.Printf(&quot;Worker:%d completed %s\\n&quot;, worker, task) &#125;&#125; 输出： 123456789101112131415161718192021222324Worker:4 started Task:1Worker:2 started Task:2Worker:1 started Task:4Worker:3 started Task:3Worker:4 completed Task:1Worker:4 started Task:5Worker:3 completed Task:3Worker:3 started Task:6Worker:3 completed Task:6Worker:3 started Task:7Worker:1 completed Task:4Worker:1 started Task:8Worker:2 completed Task:2Worker:2 started Task:9Worker:2 completed Task:9Worker:2 started Task:10Worker:3 completed Task:7worker:3 shutting down(关闭)Worker:4 completed Task:5worker:4 shutting down(关闭)Worker:1 completed Task:8worker:1 shutting down(关闭)Worker:2 completed Task:10worker:2 shutting down(关闭)","categories":[{"name":"Go语言","slug":"Go语言","permalink":"https://hqd8080.github.io/categories/Go%E8%AF%AD%E8%A8%80/"}],"tags":[{"name":"golang","slug":"golang","permalink":"https://hqd8080.github.io/tags/golang/"}]},{"title":"Redis（七）数据持久化","slug":"redis/redis-rdb-aof","date":"2020-05-22T12:40:28.000Z","updated":"2024-04-08T13:25:04.657Z","comments":true,"path":"2020/05/22/redis/redis-rdb-aof/","link":"","permalink":"https://hqd8080.github.io/2020/05/22/redis/redis-rdb-aof/","excerpt":"","text":"Redis的持久化 redis有两种数据持久化类型：RDB和AOF RDB可以看做是某个时间点上的快照，非常适合于备份和灾难恢复（仅包含某个时间点上的redis数据快照）AOF（append-only file）则是一个写入操作的日志，将在服务器启动时被重放（只记录redis写入的追加式日志文件，因为每个写入命令都会被追加到文件中，所以AOF的数据一致性比RDB更高） 在一个正在运行的redis实例上启用AOF持久化 1127.0.0.1:6379&gt; config set appendonly yes 在配置文件中开启 1cat conf/redis.conf |grep &quot;^appendonly yes&quot;","categories":[{"name":"Redis","slug":"Redis","permalink":"https://hqd8080.github.io/categories/Redis/"}],"tags":[{"name":"redis","slug":"redis","permalink":"https://hqd8080.github.io/tags/redis/"}]},{"title":"Redis（六）类型（HyperLogLog）的使用","slug":"redis/redis-hyperLogLog","date":"2020-05-22T12:20:20.000Z","updated":"2024-04-08T13:25:17.897Z","comments":true,"path":"2020/05/22/redis/redis-hyperLogLog/","link":"","permalink":"https://hqd8080.github.io/2020/05/22/redis/redis-hyperLogLog/","excerpt":"","text":"Redis类型HyperLogLog的使用 唯一计数 HyperLogLog 123456// 根据uid统计访问次数，去重127.0.0.1:6379&gt; pfadd &quot;count&quot; 12343127.0.0.1:6379&gt; pfadd &quot;count&quot; 2127.0.0.1:6379&gt; pfcount count // 2 位图节约存储空间，底层数据类型是字符串 设置键的过期时间原理：设置键的过期时间会被存储为一个绝对的UNIX时间戳；即使redis服务器宕机了一段时间；这个时间戳也会被持久化到RDB文件中；当redis再次启动时这个用来判断是否过期的时间戳并不会发生变化，一旦当前的时间戳超过这个保存的时间戳，键就过期了 被动过期：在一个键过期后，当试图访问已经过期的键时；redis会立即从内存中删除","categories":[{"name":"Redis","slug":"Redis","permalink":"https://hqd8080.github.io/categories/Redis/"}],"tags":[{"name":"redis","slug":"redis","permalink":"https://hqd8080.github.io/tags/redis/"}]},{"title":"Redis（五）有序集合类型（zset）的使用","slug":"redis/redis-zset","date":"2020-05-22T11:50:20.000Z","updated":"2024-04-08T13:24:10.073Z","comments":true,"path":"2020/05/22/redis/redis-zset/","link":"","permalink":"https://hqd8080.github.io/2020/05/22/redis/redis-zset/","excerpt":"","text":"Redis有序集合类型（zset）的使用 12// 添加进有序集合127.0.0.1:6379&gt; zadd develop:language 100 &quot;Go&quot; 88 &quot;PHP&quot; 80 &quot;Python&quot; 60 &quot;Java&quot; 55 &quot;C++&quot; 123456789101112// 获取排名，从大到小，zrevrange127.0.0.1:6379&gt; zrevrange develop:language 0 -1 withscores1) &quot;Go&quot;2) &quot;100&quot;3) &quot;PHP&quot;4) &quot;88&quot;5) &quot;Python&quot;6) &quot;80&quot;7) &quot;Java&quot;8) &quot;60&quot;9) &quot;C++&quot;10) &quot;55&quot; 12// 集合的元素scores操作加1127.0.0.1:6379&gt; zincrby develop:language 1 &quot;Go&quot; 12// 只查看某个有序集合的元素排名，zrevrange127.0.0.1:6379&gt; zrevrange develop:language &quot;Go&quot; 12// 只查看某个有序集合的数值, zscore127.0.0.1:6379&gt; zscore develop:language &quot;Go&quot; 1234567891011121314151617181920212223242526272829303132// 添加新的有序集合成员127.0.0.1:6379&gt; zadd develop:language nx 50 &quot;Rust&quot;// 有序集合，递减排列，从大到小127.0.0.1:6379&gt; zrevrange develop:language 0 -1 withscores1) &quot;Go&quot;2) &quot;101&quot;3) &quot;PHP&quot;4) &quot;88&quot;5) &quot;Python&quot;6) &quot;80&quot;7) &quot;Java&quot;8) &quot;60&quot;9) &quot;C++&quot;10) &quot;55&quot;11) &quot;Rust&quot;12) &quot;50&quot;// 有序集合，递增排列，从小到大127.0.0.1:6379&gt; zrange develop:language 0 -1 WITHSCORES 1) &quot;Rust&quot; 2) &quot;50&quot; 3) &quot;C++&quot; 4) &quot;55&quot; 5) &quot;Java&quot; 6) &quot;60&quot; 7) &quot;Python&quot; 8) &quot;80&quot; 9) &quot;PHP&quot;10) &quot;88&quot;11) &quot;Go&quot;12) &quot;101&quot;","categories":[{"name":"Redis","slug":"Redis","permalink":"https://hqd8080.github.io/categories/Redis/"}],"tags":[{"name":"redis","slug":"redis","permalink":"https://hqd8080.github.io/tags/redis/"}]},{"title":"Redis（四）集合类型（set）的使用","slug":"redis/redis-set","date":"2020-05-22T11:45:20.000Z","updated":"2024-04-08T13:25:04.661Z","comments":true,"path":"2020/05/22/redis/redis-set/","link":"","permalink":"https://hqd8080.github.io/2020/05/22/redis/redis-set/","excerpt":"","text":"Redis集合类型（set）的使用 集合类型，唯一，无序对象，应用场景：求差集，交集，并集 12// 添加进集合，sadd127.0.0.1:6379&gt; sadd &quot;develop_language&quot; &quot;Go&quot; &quot;PHP&quot; &quot;Python&quot; &quot;Java&quot; &quot;C++&quot; 12// 集合中成员数量，scard127.0.0.1:6379&gt; scard develop_language 12// 测试元素是不是在集合中，sismember127.0.0.1:6379&gt; sismember develop_language &quot;Go&quot; 12// 删除集合的一个元素,srem127.0.0.1:6379&gt; srem develop_language &quot;C++&quot; 123456// 列出集合中的所有元素，smembers127.0.0.1:6379&gt; smembers develop_language1) &quot;Python&quot;2) &quot;PHP&quot;3) &quot;Go&quot;4) &quot;Java&quot; 1234// 计算两个集合的并集，sunion（只返回结果），sunionstort（将结果存储到一个指定的键中）// 计算交集127.0.0.1:6379&gt; sinter &quot;集合1&quot; &quot;集合2&quot;127.0.0.1:6379&gt; sinterstore &quot;集合1&quot; &quot;集合2&quot;","categories":[{"name":"Redis","slug":"Redis","permalink":"https://hqd8080.github.io/categories/Redis/"}],"tags":[{"name":"redis","slug":"redis","permalink":"https://hqd8080.github.io/tags/redis/"}]},{"title":"Redis（三）哈希类型（hash）的使用","slug":"redis/redis-hash","date":"2020-05-22T10:50:20.000Z","updated":"2024-04-08T13:25:24.224Z","comments":true,"path":"2020/05/22/redis/redis-hash/","link":"","permalink":"https://hqd8080.github.io/2020/05/22/redis/redis-hash/","excerpt":"","text":"Redis哈希类型（hash）的使用 哈希表示字段和值之间的映射关系、类似对象和对象的属性之间的关系适合使用哈希类型 12345// 一次性设置和获取多个哈希属性键值127.0.0.1:6379&gt; hmset &quot;hqd8080&quot; &quot;phone&quot; &quot;18111111111&quot; &quot;address&quot; &quot;shanghai china&quot;127.0.0.1:6379&gt; hmget &quot;hqd8080&quot; &quot;phone&quot; &quot;address&quot;1) &quot;18111111111&quot;2) &quot;shanghai china&quot; 12// 获取哈希的一个属性hget127.0.0.1:6379&gt; hget hqd8080 address // &quot;shanghai china&quot; 12// 测试哈希中是否存在某个字段、属性，hexists127.0.0.1:6379&gt; hexists hqd8080 &quot;phone&quot; // (integer) 1 123456// 获取哈希中的所有字段 hgetall127.0.0.1:6379&gt; hgetall hqd80801) &quot;phone&quot;2) &quot;18111111111&quot;3) &quot;address&quot;4) &quot;shanghai china&quot; 12345// 删除哈希中的摸个字段，hdel127.0.0.1:6379&gt; hdel hqd8080 &quot;phone&quot;127.0.0.1:6379&gt; hgetall hqd80801) &quot;address&quot;2) &quot;shanghai china&quot; 12// 仅当哈希字段不存在时才创建，避免hmset的覆盖字段行为127.0.0.1:6379&gt; hsetnx &quot;hqd8080&quot; &quot;phone&quot; &quot;11111111111&quot; 1234567// 哈希字段非常多建议使用hscan，是一种指针迭代器，不会造成服务器阻塞，适合非常大的哈希127.0.0.1:6379&gt; hscan hqd8080 0 match &quot;*a*&quot;1) &quot;0&quot; // 服务器返回的新游标，用来进行一次新的迭代，0代表哈希遍历完成2) 1) &quot;address&quot;2) &quot;shanghai china&quot;127.0.0.1:6379&gt; hscan hqd8080 新游标 match &quot;*a*&quot;","categories":[{"name":"Redis","slug":"Redis","permalink":"https://hqd8080.github.io/categories/Redis/"}],"tags":[{"name":"redis","slug":"redis","permalink":"https://hqd8080.github.io/tags/redis/"}]},{"title":"Redis（二）列表类型（list）的使用","slug":"redis/redis-list","date":"2020-05-22T10:40:10.000Z","updated":"2024-04-08T13:25:10.977Z","comments":true,"path":"2020/05/22/redis/redis-list/","link":"","permalink":"https://hqd8080.github.io/2020/05/22/redis/redis-list/","excerpt":"","text":"Redis列表类型（list）的使用 列表能存储一组对象，所以也能被用作栈或者队列使用 12// 从左边插入列表127.0.0.1:6379&gt; lpush shanghai &quot;长宁区&quot; &quot;徐汇区&quot; &quot;静安区&quot; &quot;浦东区&quot; &quot;黄浦区&quot; &quot;普陀区&quot; 12// 列表打印127.0.0.1:6379&gt; lrange shanghai 0 -1 12// 从右边插入列表127.0.0.1:6379&gt; rpush shanghai &quot;松江区&quot; 12// &quot;松江区&quot;之后插入&quot;嘉定区&quot;127.0.0.1:6379&gt; linsert shanghai after &quot;松江区&quot; &quot;嘉定区&quot; 123// 使用索引获取值127.0.0.1:6379&gt; lindex shanghai 6&quot;松江区&quot; 12// 仅在列表存在时才插入列表 lpushx rpushx,列表不存在返回(empty array)127.0.0.1:6379&gt; lpushx shanghai &quot;test&quot; 12345// lpop，rpop移除列表的元素127.0.0.1:6379&gt; lpop shanghai // 从左边移除一个元素127.0.0.1:6379&gt; lrange shanghai 0 -1127.0.0.1:6379&gt; rpop shanghai // 从右边移除一个元素127.0.0.1:6379&gt; lrange shanghai 0 -1 12// 阻塞版本blpop，brpop 阻塞版本会将客户端阻塞，当设置超时时间为0时表示永久等待127.0.0.1:6379&gt; brpop job_queue 0","categories":[{"name":"Redis","slug":"Redis","permalink":"https://hqd8080.github.io/categories/Redis/"}],"tags":[{"name":"redis","slug":"redis","permalink":"https://hqd8080.github.io/tags/redis/"}]},{"title":"Redis（一）字符串类型（string）的使用","slug":"redis/redis-string","date":"2020-05-22T10:30:28.000Z","updated":"2024-04-08T13:24:35.754Z","comments":true,"path":"2020/05/22/redis/redis-string/","link":"","permalink":"https://hqd8080.github.io/2020/05/22/redis/redis-string/","excerpt":"","text":"Redis字符串类型（string）的使用 123// 设置key，value127.0.0.1:6379&gt; set address &quot;shanghai china&quot; 12// 获取key对应的value127.0.0.1:6379&gt; get address // &quot;shanghai china&quot; 12// 返回字符串长度，key不存在返回0127.0.0.1:6379&gt; strlen address // (integer) 14 12// 字符串追加，拼接127.0.0.1:6379&gt; append address &quot; chang ning&quot; // &quot;shanghai china chang ning&quot; 12// 仅在key不存在时，才设置键的值，键已经存在返回0127.0.0.1:6379&gt; setnx city &quot;shanghai china&quot; // &quot;shanghai china&quot; 1234567// mset，mget原子性的一次性设置多个键值127.0.0.1:6379&gt; mset &quot;pudong&quot; &quot;001&quot; &quot;changning&quot; &quot;002&quot; &quot;xuhui&quot; &quot;003&quot;127.0.0.1:6379&gt; mget &quot;pudong&quot; &quot;changning&quot; &quot;xuhui&quot;1) &quot;001&quot;2) &quot;002&quot;3) &quot;003&quot; 123// 检查给定key是否存在，若key存在返回 1 ，否则返回 0127.0.0.1:6379&gt; exists city(integer) 1","categories":[{"name":"Redis","slug":"Redis","permalink":"https://hqd8080.github.io/categories/Redis/"}],"tags":[{"name":"redis","slug":"redis","permalink":"https://hqd8080.github.io/tags/redis/"}]},{"title":"Go语言解析复杂格式json数据（simplejson包）","slug":"golang/go-simplejson","date":"2020-05-14T13:03:20.000Z","updated":"2023-10-07T11:35:57.217Z","comments":true,"path":"2020/05/14/golang/go-simplejson/","link":"","permalink":"https://hqd8080.github.io/2020/05/14/golang/go-simplejson/","excerpt":"","text":"Go语言使用第三方包simplejson包，解析复杂结构的json数据实例123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250251252253254255256257258259260261262263264265266267268269270271272273274275276277278279280281282283284285286287288289290291292293294295296297298299300301302303304305306307308309310311312313314315316317318319320321322323324325326327328329330331332333334335336337338339340341342343344345346347348349350351352353354355356357358359360361362363364365366367368369370371372373374375376377378379380381382383384385386387388389390391392393394395396397398399400401402403404405406407408409410411412413414415416417418419420421422423424425426427428429430431432433434435436437438439440441442443444445446447448449450451452453454455456457458459460461462463464465466467468469470471472473474475476477478479480481482483484485486487488489490491492493494495496497498499500501502503504505506507508509510511512513514515516517518519520521522523524525526527528529530531532533534535536537538539540541542543544545546547548549550551552553554555556557558559560561562563564565566567568569570571572573574575576577578579580581582583584585586587588589590591592593594595596597598599600601602603604605606607608609610611612613614615616617618619620621622623624625626627628629630631632633634635636637638639640641642643644645646647648649650651652653654655656657658659660661662663664665666667668669670671672673674675676677678679680681682683684685686687688689690691692693694695696697698699700701702703704705706707708709710711712713714715716717718719720721722723724725726727728729730731732733734735736737738739740741742743744745746747748749750751752753754755756757758759760761762763764765766767768769770771772773774775776777778779780781782783784785786787788789790791792793794795796797798799800801802803804805806807808809810811812813814815816817818819820821822823824825826827828829830831832833834835836837838839840841842843844845846847848849850851852853854855856857858859860861862863864865866867868869870871872873874875876877878879880881882883884885886887888889890891892893894895896897898899900901902903904905906907908909910911912913914915916917918919920921922923924925926927928929930931932933934935936937938939940941942#request.json&#123; &quot;requestType&quot;: &quot;services.UserLoginRequest&quot;, &quot;requestStream&quot;: false, &quot;messageTypes&quot;: &#123; &quot;google.protobuf.Timestamp&quot;: [&#123; &quot;name&quot;: &quot;seconds&quot;, &quot;protoName&quot;: &quot;seconds&quot;, &quot;type&quot;: &quot;int64&quot;, &quot;oneOfFields&quot;: null, &quot;isMessage&quot;: false, &quot;isEnum&quot;: false, &quot;isArray&quot;: false, &quot;isMap&quot;: false, &quot;isRequired&quot;: false, &quot;defaultVal&quot;: &quot;0&quot; &#125;, &#123; &quot;name&quot;: &quot;nanos&quot;, &quot;protoName&quot;: &quot;nanos&quot;, &quot;type&quot;: &quot;int32&quot;, &quot;oneOfFields&quot;: null, &quot;isMessage&quot;: false, &quot;isEnum&quot;: false, &quot;isArray&quot;: false, &quot;isMap&quot;: false, &quot;isRequired&quot;: false, &quot;defaultVal&quot;: 0 &#125;], &quot;services.UserLoginRequest&quot;: [&#123; &quot;name&quot;: &quot;userId&quot;, &quot;protoName&quot;: &quot;user_id&quot;, &quot;type&quot;: &quot;int64&quot;, &quot;oneOfFields&quot;: null, &quot;isMessage&quot;: false, &quot;isEnum&quot;: false, &quot;isArray&quot;: false, &quot;isMap&quot;: false, &quot;isRequired&quot;: false, &quot;defaultVal&quot;: &quot;100&quot;, &quot;isExpand&quot;: false, &quot;children&quot;: [], &quot;level&quot;: 1, &quot;operator&quot;: &quot;&quot;, &quot;bLeft&quot;: 34, &quot;id&quot;: 16947 &#125;, &#123; &quot;name&quot;: &quot;userName&quot;, &quot;protoName&quot;: &quot;user_name&quot;, &quot;type&quot;: &quot;string&quot;, &quot;oneOfFields&quot;: null, &quot;isMessage&quot;: false, &quot;isEnum&quot;: false, &quot;isArray&quot;: false, &quot;isMap&quot;: false, &quot;isRequired&quot;: false, &quot;defaultVal&quot;: &quot;zhangsan&quot;, &quot;isExpand&quot;: false, &quot;children&quot;: [], &quot;level&quot;: 1, &quot;operator&quot;: &quot;&quot;, &quot;bLeft&quot;: 34, &quot;id&quot;: 14965 &#125;, &#123; &quot;name&quot;: &quot;userNickname&quot;, &quot;protoName&quot;: &quot;user_nickname&quot;, &quot;type&quot;: &quot;string&quot;, &quot;oneOfFields&quot;: null, &quot;isMessage&quot;: false, &quot;isEnum&quot;: false, &quot;isArray&quot;: false, &quot;isMap&quot;: false, &quot;isRequired&quot;: false, &quot;defaultVal&quot;: &quot;xiaoming&quot;, &quot;isExpand&quot;: false, &quot;children&quot;: [], &quot;level&quot;: 1, &quot;operator&quot;: &quot;&quot;, &quot;bLeft&quot;: 34, &quot;id&quot;: 15598 &#125;, &#123; &quot;name&quot;: &quot;userCountry&quot;, &quot;protoName&quot;: &quot;user_country&quot;, &quot;type&quot;: &quot;string&quot;, &quot;oneOfFields&quot;: null, &quot;isMessage&quot;: false, &quot;isEnum&quot;: false, &quot;isArray&quot;: false, &quot;isMap&quot;: false, &quot;isRequired&quot;: false, &quot;defaultVal&quot;: &quot;china&quot;, &quot;isExpand&quot;: false, &quot;children&quot;: [], &quot;level&quot;: 1, &quot;operator&quot;: &quot;&quot;, &quot;bLeft&quot;: 34, &quot;id&quot;: 48380 &#125;, &#123; &quot;name&quot;: &quot;userGender&quot;, &quot;protoName&quot;: &quot;user_gender&quot;, &quot;type&quot;: &quot;int32&quot;, &quot;oneOfFields&quot;: null, &quot;isMessage&quot;: false, &quot;isEnum&quot;: false, &quot;isArray&quot;: false, &quot;isMap&quot;: false, &quot;isRequired&quot;: false, &quot;defaultVal&quot;: &quot;1&quot;, &quot;isExpand&quot;: false, &quot;children&quot;: [], &quot;level&quot;: 1, &quot;operator&quot;: &quot;&quot;, &quot;bLeft&quot;: 34, &quot;id&quot;: 67007 &#125;, &#123; &quot;name&quot;: &quot;userCredits&quot;, &quot;protoName&quot;: &quot;user_credits&quot;, &quot;type&quot;: &quot;double&quot;, &quot;oneOfFields&quot;: null, &quot;isMessage&quot;: false, &quot;isEnum&quot;: false, &quot;isArray&quot;: false, &quot;isMap&quot;: false, &quot;isRequired&quot;: false, &quot;defaultVal&quot;: &quot;100.0&quot;, &quot;isExpand&quot;: false, &quot;children&quot;: [], &quot;level&quot;: 1, &quot;operator&quot;: &quot;&quot;, &quot;bLeft&quot;: 34, &quot;id&quot;: 91280 &#125;, &#123; &quot;name&quot;: &quot;isAdmin&quot;, &quot;protoName&quot;: &quot;is_admin&quot;, &quot;type&quot;: &quot;bool&quot;, &quot;oneOfFields&quot;: null, &quot;isMessage&quot;: false, &quot;isEnum&quot;: false, &quot;isArray&quot;: false, &quot;isMap&quot;: false, &quot;isRequired&quot;: false, &quot;defaultVal&quot;: true, &quot;isExpand&quot;: false, &quot;children&quot;: [], &quot;level&quot;: 1, &quot;operator&quot;: &quot;&quot;, &quot;bLeft&quot;: 34, &quot;id&quot;: 85770 &#125;, &#123; &quot;name&quot;: &quot;authCode&quot;, &quot;protoName&quot;: &quot;auth_code&quot;, &quot;type&quot;: &quot;bytes&quot;, &quot;oneOfFields&quot;: null, &quot;isMessage&quot;: false, &quot;isEnum&quot;: false, &quot;isArray&quot;: false, &quot;isMap&quot;: false, &quot;isRequired&quot;: false, &quot;defaultVal&quot;: &quot;123&quot;, &quot;isExpand&quot;: false, &quot;children&quot;: [], &quot;level&quot;: 1, &quot;operator&quot;: &quot;&quot;, &quot;bLeft&quot;: 34, &quot;id&quot;: 36294 &#125;, &#123; &quot;name&quot;: &quot;userBalance&quot;, &quot;protoName&quot;: &quot;user_balance&quot;, &quot;type&quot;: &quot;float&quot;, &quot;oneOfFields&quot;: null, &quot;isMessage&quot;: false, &quot;isEnum&quot;: false, &quot;isArray&quot;: false, &quot;isMap&quot;: false, &quot;isRequired&quot;: false, &quot;defaultVal&quot;: &quot;200.00&quot;, &quot;isExpand&quot;: false, &quot;children&quot;: [], &quot;level&quot;: 1, &quot;operator&quot;: &quot;&quot;, &quot;bLeft&quot;: 34, &quot;id&quot;: 94647 &#125;, &#123; &quot;name&quot;: &quot;userHobby&quot;, &quot;protoName&quot;: &quot;user_hobby&quot;, &quot;type&quot;: &quot;services.UserLoginRequest.Hobby&quot;, &quot;oneOfFields&quot;: null, &quot;isMessage&quot;: false, &quot;isEnum&quot;: true, &quot;isArray&quot;: false, &quot;isMap&quot;: false, &quot;isRequired&quot;: false, &quot;defaultVal&quot;: &quot;music&quot;, &quot;isExpand&quot;: false, &quot;children&quot;: [], &quot;level&quot;: 1, &quot;operator&quot;: &quot;&quot;, &quot;bLeft&quot;: 34, &quot;id&quot;: 91930 &#125;, &#123; &quot;name&quot;: &quot;luckyNumbers&quot;, &quot;protoName&quot;: &quot;lucky_numbers&quot;, &quot;type&quot;: &quot;int32&quot;, &quot;oneOfFields&quot;: null, &quot;isMessage&quot;: false, &quot;isEnum&quot;: false, &quot;isArray&quot;: true, &quot;isMap&quot;: false, &quot;isRequired&quot;: false, &quot;defaultVal&quot;: &quot;2&quot;, &quot;isExpand&quot;: true, &quot;children&quot;: [&#123; &quot;type&quot;: &quot;int32&quot;, &quot;oneOfFields&quot;: null, &quot;isMessage&quot;: false, &quot;isEnum&quot;: false, &quot;isArray&quot;: false, &quot;isMap&quot;: false, &quot;isRequired&quot;: false, &quot;defaultVal&quot;: &quot;4&quot;, &quot;value&quot;: 1, &quot;parentType&quot;: &quot;int32&quot;, &quot;id&quot;: 77877, &quot;isExpand&quot;: true, &quot;children&quot;: [], &quot;level&quot;: 2, &quot;operator&quot;: &quot;&quot;, &quot;bLeft&quot;: 34 &#125;, &#123; &quot;type&quot;: &quot;int32&quot;, &quot;oneOfFields&quot;: null, &quot;isMessage&quot;: false, &quot;isEnum&quot;: false, &quot;isArray&quot;: false, &quot;isMap&quot;: false, &quot;isRequired&quot;: false, &quot;defaultVal&quot;: &quot;6&quot;, &quot;value&quot;: 1, &quot;parentType&quot;: &quot;int32&quot;, &quot;id&quot;: 21349, &quot;isExpand&quot;: true, &quot;children&quot;: [], &quot;level&quot;: 2, &quot;operator&quot;: &quot;&quot;, &quot;bLeft&quot;: 34 &#125;], &quot;level&quot;: 1, &quot;operator&quot;: &quot;&quot;, &quot;bLeft&quot;: 34, &quot;id&quot;: 51439 &#125;, &#123; &quot;name&quot;: &quot;userEmail&quot;, &quot;protoName&quot;: &quot;user_email&quot;, &quot;type&quot;: &quot;services.UserLoginRequest.UserEmailEntry&quot;, &quot;oneOfFields&quot;: null, &quot;isMessage&quot;: true, &quot;isEnum&quot;: false, &quot;isArray&quot;: false, &quot;isMap&quot;: true, &quot;isRequired&quot;: false, &quot;defaultVal&quot;: &#123;&#125;, &quot;isExpand&quot;: true, &quot;children&quot;: [&#123; &quot;id&quot;: 1600416010481, &quot;name&quot;: &quot;userEmail-0&quot;, &quot;parentType&quot;: &quot;object&quot;, &quot;flag&quot;: &quot;append&quot;, &quot;parentName&quot;: &quot;userEmail&quot;, &quot;children&quot;: [&#123; &quot;name&quot;: &quot;key&quot;, &quot;protoName&quot;: &quot;key&quot;, &quot;type&quot;: &quot;string&quot;, &quot;oneOfFields&quot;: null, &quot;isMessage&quot;: false, &quot;isEnum&quot;: false, &quot;isArray&quot;: false, &quot;isMap&quot;: false, &quot;isRequired&quot;: false, &quot;defaultVal&quot;: &quot;email001&quot;, &quot;value&quot;: &quot;&quot;, &quot;id&quot;: 35094, &quot;parentName&quot;: &quot;userEmail&quot;, &quot;isExpand&quot;: true, &quot;children&quot;: [], &quot;level&quot;: 3, &quot;bLeft&quot;: 50, &quot;operator&quot;: &quot;&quot; &#125;, &#123; &quot;name&quot;: &quot;value&quot;, &quot;protoName&quot;: &quot;value&quot;, &quot;type&quot;: &quot;string&quot;, &quot;oneOfFields&quot;: null, &quot;isMessage&quot;: false, &quot;isEnum&quot;: false, &quot;isArray&quot;: false, &quot;isMap&quot;: false, &quot;isRequired&quot;: false, &quot;defaultVal&quot;: &quot;001&quot;, &quot;value&quot;: &quot;&quot;, &quot;id&quot;: 11786, &quot;parentName&quot;: &quot;userEmail&quot;, &quot;isExpand&quot;: true, &quot;children&quot;: [], &quot;level&quot;: 3, &quot;bLeft&quot;: 50, &quot;operator&quot;: &quot;&quot; &#125;], &quot;isExpand&quot;: true, &quot;level&quot;: 2, &quot;operator&quot;: &quot;&quot;, &quot;bLeft&quot;: 34 &#125;, &#123; &quot;id&quot;: 1600416021145, &quot;name&quot;: &quot;userEmail-1&quot;, &quot;parentType&quot;: &quot;object&quot;, &quot;flag&quot;: &quot;append&quot;, &quot;parentName&quot;: &quot;userEmail&quot;, &quot;children&quot;: [&#123; &quot;name&quot;: &quot;key&quot;, &quot;protoName&quot;: &quot;key&quot;, &quot;type&quot;: &quot;string&quot;, &quot;oneOfFields&quot;: null, &quot;isMessage&quot;: false, &quot;isEnum&quot;: false, &quot;isArray&quot;: false, &quot;isMap&quot;: false, &quot;isRequired&quot;: false, &quot;defaultVal&quot;: &quot;email002&quot;, &quot;value&quot;: &quot;&quot;, &quot;id&quot;: 49850, &quot;parentName&quot;: &quot;userEmail&quot;, &quot;isExpand&quot;: true, &quot;children&quot;: [], &quot;level&quot;: 3, &quot;bLeft&quot;: 50, &quot;operator&quot;: &quot;&quot; &#125;, &#123; &quot;name&quot;: &quot;value&quot;, &quot;protoName&quot;: &quot;value&quot;, &quot;type&quot;: &quot;string&quot;, &quot;oneOfFields&quot;: null, &quot;isMessage&quot;: false, &quot;isEnum&quot;: false, &quot;isArray&quot;: false, &quot;isMap&quot;: false, &quot;isRequired&quot;: false, &quot;defaultVal&quot;: &quot;002&quot;, &quot;value&quot;: &quot;&quot;, &quot;id&quot;: 82232, &quot;parentName&quot;: &quot;userEmail&quot;, &quot;isExpand&quot;: true, &quot;children&quot;: [], &quot;level&quot;: 3, &quot;bLeft&quot;: 50, &quot;operator&quot;: &quot;&quot; &#125;], &quot;isExpand&quot;: true, &quot;level&quot;: 2, &quot;operator&quot;: &quot;&quot;, &quot;bLeft&quot;: 34 &#125;], &quot;level&quot;: 1, &quot;operator&quot;: &quot;&quot;, &quot;bLeft&quot;: 34, &quot;id&quot;: 49491 &#125;, &#123; &quot;name&quot;: &quot;userWeight&quot;, &quot;protoName&quot;: &quot;user_weight&quot;, &quot;type&quot;: &quot;services.UserLoginRequest.UserWeightEntry&quot;, &quot;oneOfFields&quot;: null, &quot;isMessage&quot;: true, &quot;isEnum&quot;: false, &quot;isArray&quot;: false, &quot;isMap&quot;: true, &quot;isRequired&quot;: false, &quot;defaultVal&quot;: &#123;&#125;, &quot;isExpand&quot;: true, &quot;children&quot;: [&#123; &quot;id&quot;: 1600416029666, &quot;name&quot;: &quot;userWeight-0&quot;, &quot;parentType&quot;: &quot;object&quot;, &quot;flag&quot;: &quot;append&quot;, &quot;parentName&quot;: &quot;userWeight&quot;, &quot;children&quot;: [&#123; &quot;name&quot;: &quot;key&quot;, &quot;protoName&quot;: &quot;key&quot;, &quot;type&quot;: &quot;string&quot;, &quot;oneOfFields&quot;: null, &quot;isMessage&quot;: false, &quot;isEnum&quot;: false, &quot;isArray&quot;: false, &quot;isMap&quot;: false, &quot;isRequired&quot;: false, &quot;defaultVal&quot;: &quot;weight1&quot;, &quot;value&quot;: &quot;&quot;, &quot;id&quot;: 1295, &quot;parentName&quot;: &quot;userWeight&quot;, &quot;isExpand&quot;: true, &quot;children&quot;: [], &quot;level&quot;: 3, &quot;bLeft&quot;: 50, &quot;operator&quot;: &quot;&quot; &#125;, &#123; &quot;name&quot;: &quot;value&quot;, &quot;protoName&quot;: &quot;value&quot;, &quot;type&quot;: &quot;int32&quot;, &quot;oneOfFields&quot;: null, &quot;isMessage&quot;: false, &quot;isEnum&quot;: false, &quot;isArray&quot;: false, &quot;isMap&quot;: false, &quot;isRequired&quot;: false, &quot;defaultVal&quot;: &quot;10&quot;, &quot;value&quot;: 0, &quot;id&quot;: 3455, &quot;parentName&quot;: &quot;userWeight&quot;, &quot;isExpand&quot;: true, &quot;children&quot;: [], &quot;level&quot;: 3, &quot;bLeft&quot;: 50, &quot;operator&quot;: &quot;&quot; &#125;], &quot;isExpand&quot;: true, &quot;level&quot;: 2, &quot;operator&quot;: &quot;&quot;, &quot;bLeft&quot;: 34 &#125;, &#123; &quot;id&quot;: 1600416048040, &quot;name&quot;: &quot;userWeight-1&quot;, &quot;parentType&quot;: &quot;object&quot;, &quot;flag&quot;: &quot;append&quot;, &quot;parentName&quot;: &quot;userWeight&quot;, &quot;children&quot;: [&#123; &quot;name&quot;: &quot;key&quot;, &quot;protoName&quot;: &quot;key&quot;, &quot;type&quot;: &quot;string&quot;, &quot;oneOfFields&quot;: null, &quot;isMessage&quot;: false, &quot;isEnum&quot;: false, &quot;isArray&quot;: false, &quot;isMap&quot;: false, &quot;isRequired&quot;: false, &quot;defaultVal&quot;: &quot;weight2&quot;, &quot;value&quot;: &quot;&quot;, &quot;id&quot;: 86596, &quot;parentName&quot;: &quot;userWeight&quot;, &quot;isExpand&quot;: true, &quot;children&quot;: [], &quot;level&quot;: 3, &quot;bLeft&quot;: 50, &quot;operator&quot;: &quot;&quot; &#125;, &#123; &quot;name&quot;: &quot;value&quot;, &quot;protoName&quot;: &quot;value&quot;, &quot;type&quot;: &quot;int32&quot;, &quot;oneOfFields&quot;: null, &quot;isMessage&quot;: false, &quot;isEnum&quot;: false, &quot;isArray&quot;: false, &quot;isMap&quot;: false, &quot;isRequired&quot;: false, &quot;defaultVal&quot;: &quot;10&quot;, &quot;value&quot;: 0, &quot;id&quot;: 77749, &quot;parentName&quot;: &quot;userWeight&quot;, &quot;isExpand&quot;: true, &quot;children&quot;: [], &quot;level&quot;: 3, &quot;bLeft&quot;: 50, &quot;operator&quot;: &quot;&quot; &#125;], &quot;isExpand&quot;: true, &quot;level&quot;: 2, &quot;operator&quot;: &quot;&quot;, &quot;bLeft&quot;: 34 &#125;], &quot;level&quot;: 1, &quot;operator&quot;: &quot;&quot;, &quot;bLeft&quot;: 34, &quot;id&quot;: 32487 &#125;, &#123; &quot;name&quot;: &quot;userNum&quot;, &quot;protoName&quot;: &quot;user_num&quot;, &quot;type&quot;: &quot;services.UserLoginRequest.UserNumEntry&quot;, &quot;oneOfFields&quot;: null, &quot;isMessage&quot;: true, &quot;isEnum&quot;: false, &quot;isArray&quot;: false, &quot;isMap&quot;: true, &quot;isRequired&quot;: false, &quot;defaultVal&quot;: &#123;&#125;, &quot;isExpand&quot;: true, &quot;children&quot;: [&#123; &quot;id&quot;: 1600416067640, &quot;name&quot;: &quot;userNum-0&quot;, &quot;parentType&quot;: &quot;object&quot;, &quot;flag&quot;: &quot;append&quot;, &quot;parentName&quot;: &quot;userNum&quot;, &quot;children&quot;: [&#123; &quot;name&quot;: &quot;key&quot;, &quot;protoName&quot;: &quot;key&quot;, &quot;type&quot;: &quot;string&quot;, &quot;oneOfFields&quot;: null, &quot;isMessage&quot;: false, &quot;isEnum&quot;: false, &quot;isArray&quot;: false, &quot;isMap&quot;: false, &quot;isRequired&quot;: false, &quot;defaultVal&quot;: &quot;1001&quot;, &quot;value&quot;: &quot;&quot;, &quot;id&quot;: 26160, &quot;parentName&quot;: &quot;userNum&quot;, &quot;isExpand&quot;: true, &quot;children&quot;: [], &quot;level&quot;: 3, &quot;bLeft&quot;: 50, &quot;operator&quot;: &quot;&quot; &#125;, &#123; &quot;name&quot;: &quot;phoneNumber&quot;, &quot;protoName&quot;: &quot;phone_number&quot;, &quot;type&quot;: &quot;string&quot;, &quot;oneOfFields&quot;: null, &quot;isMessage&quot;: false, &quot;isEnum&quot;: false, &quot;isArray&quot;: false, &quot;isMap&quot;: false, &quot;isRequired&quot;: false, &quot;defaultVal&quot;: &quot;1001001&quot;, &quot;id&quot;: 63268, &quot;parentName&quot;: &quot;userNum&quot;, &quot;isExpand&quot;: true, &quot;children&quot;: [], &quot;level&quot;: 3, &quot;bLeft&quot;: 50, &quot;operator&quot;: &quot;&quot; &#125;, &#123; &quot;name&quot;: &quot;phoneType&quot;, &quot;protoName&quot;: &quot;phone_type&quot;, &quot;type&quot;: &quot;services.UserLoginRequest.PhoneType&quot;, &quot;oneOfFields&quot;: null, &quot;isMessage&quot;: false, &quot;isEnum&quot;: true, &quot;isArray&quot;: false, &quot;isMap&quot;: false, &quot;isRequired&quot;: false, &quot;defaultVal&quot;: &quot;mobile&quot;, &quot;id&quot;: 15049, &quot;parentName&quot;: &quot;userNum&quot;, &quot;isExpand&quot;: true, &quot;children&quot;: [], &quot;level&quot;: 3, &quot;bLeft&quot;: 50, &quot;operator&quot;: &quot;&quot; &#125;], &quot;isExpand&quot;: true, &quot;level&quot;: 2, &quot;operator&quot;: &quot;&quot;, &quot;bLeft&quot;: 34 &#125;, &#123; &quot;id&quot;: 1600416072968, &quot;name&quot;: &quot;userNum-1&quot;, &quot;parentType&quot;: &quot;object&quot;, &quot;flag&quot;: &quot;append&quot;, &quot;parentName&quot;: &quot;userNum&quot;, &quot;children&quot;: [&#123; &quot;name&quot;: &quot;key&quot;, &quot;protoName&quot;: &quot;key&quot;, &quot;type&quot;: &quot;string&quot;, &quot;oneOfFields&quot;: null, &quot;isMessage&quot;: false, &quot;isEnum&quot;: false, &quot;isArray&quot;: false, &quot;isMap&quot;: false, &quot;isRequired&quot;: false, &quot;defaultVal&quot;: &quot;1002&quot;, &quot;value&quot;: &quot;&quot;, &quot;id&quot;: 4560, &quot;parentName&quot;: &quot;userNum&quot;, &quot;isExpand&quot;: true, &quot;children&quot;: [], &quot;level&quot;: 3, &quot;bLeft&quot;: 50, &quot;operator&quot;: &quot;&quot; &#125;, &#123; &quot;name&quot;: &quot;phoneNumber&quot;, &quot;protoName&quot;: &quot;phone_number&quot;, &quot;type&quot;: &quot;string&quot;, &quot;oneOfFields&quot;: null, &quot;isMessage&quot;: false, &quot;isEnum&quot;: false, &quot;isArray&quot;: false, &quot;isMap&quot;: false, &quot;isRequired&quot;: false, &quot;defaultVal&quot;: &quot;1002002&quot;, &quot;id&quot;: 97300, &quot;parentName&quot;: &quot;userNum&quot;, &quot;isExpand&quot;: true, &quot;children&quot;: [], &quot;level&quot;: 3, &quot;bLeft&quot;: 50, &quot;operator&quot;: &quot;&quot; &#125;, &#123; &quot;name&quot;: &quot;phoneType&quot;, &quot;protoName&quot;: &quot;phone_type&quot;, &quot;type&quot;: &quot;services.UserLoginRequest.PhoneType&quot;, &quot;oneOfFields&quot;: null, &quot;isMessage&quot;: false, &quot;isEnum&quot;: true, &quot;isArray&quot;: false, &quot;isMap&quot;: false, &quot;isRequired&quot;: false, &quot;defaultVal&quot;: &quot;mobile&quot;, &quot;id&quot;: 52444, &quot;parentName&quot;: &quot;userNum&quot;, &quot;isExpand&quot;: true, &quot;children&quot;: [], &quot;level&quot;: 3, &quot;bLeft&quot;: 50, &quot;operator&quot;: &quot;&quot; &#125;], &quot;isExpand&quot;: true, &quot;level&quot;: 2, &quot;operator&quot;: &quot;&quot;, &quot;bLeft&quot;: 34 &#125;], &quot;level&quot;: 1, &quot;operator&quot;: &quot;&quot;, &quot;bLeft&quot;: 34, &quot;id&quot;: 91376 &#125;, &#123; &quot;name&quot;: &quot;loginStatus&quot;, &quot;protoName&quot;: &quot;login_status&quot;, &quot;type&quot;: &quot;services.LoginStatus&quot;, &quot;oneOfFields&quot;: null, &quot;isMessage&quot;: false, &quot;isEnum&quot;: true, &quot;isArray&quot;: false, &quot;isMap&quot;: false, &quot;isRequired&quot;: false, &quot;defaultVal&quot;: &quot;success&quot;, &quot;isExpand&quot;: false, &quot;children&quot;: [], &quot;level&quot;: 1, &quot;operator&quot;: &quot;&quot;, &quot;bLeft&quot;: 34, &quot;id&quot;: 43622 &#125;, &#123; &quot;name&quot;: &quot;phones&quot;, &quot;protoName&quot;: &quot;phones&quot;, &quot;type&quot;: &quot;services.UserLoginRequest.PhoneNumber&quot;, &quot;oneOfFields&quot;: null, &quot;isMessage&quot;: true, &quot;isEnum&quot;: false, &quot;isArray&quot;: true, &quot;isMap&quot;: false, &quot;isRequired&quot;: false, &quot;defaultVal&quot;: null, &quot;isExpand&quot;: true, &quot;children&quot;: [&#123; &quot;id&quot;: 1600416104944, &quot;name&quot;: &quot;phones-0&quot;, &quot;parentType&quot;: &quot;array&quot;, &quot;flag&quot;: &quot;append&quot;, &quot;parentName&quot;: &quot;phones&quot;, &quot;children&quot;: [&#123; &quot;name&quot;: &quot;phoneNumber&quot;, &quot;protoName&quot;: &quot;phone_number&quot;, &quot;type&quot;: &quot;string&quot;, &quot;oneOfFields&quot;: null, &quot;isMessage&quot;: false, &quot;isEnum&quot;: false, &quot;isArray&quot;: false, &quot;isMap&quot;: false, &quot;isRequired&quot;: false, &quot;defaultVal&quot;: &quot;12345678900&quot;, &quot;value&quot;: &quot;&quot;, &quot;id&quot;: 68179, &quot;parentName&quot;: &quot;phones&quot;, &quot;isExpand&quot;: true, &quot;children&quot;: [], &quot;level&quot;: 3, &quot;bLeft&quot;: 50, &quot;operator&quot;: &quot;&quot; &#125;, &#123; &quot;name&quot;: &quot;phoneType&quot;, &quot;protoName&quot;: &quot;phone_type&quot;, &quot;type&quot;: &quot;services.UserLoginRequest.PhoneType&quot;, &quot;oneOfFields&quot;: null, &quot;isMessage&quot;: false, &quot;isEnum&quot;: true, &quot;isArray&quot;: false, &quot;isMap&quot;: false, &quot;isRequired&quot;: false, &quot;defaultVal&quot;: &quot;mobile&quot;, &quot;value&quot;: &quot;mobile&quot;, &quot;id&quot;: 49819, &quot;parentName&quot;: &quot;phones&quot;, &quot;isExpand&quot;: true, &quot;children&quot;: [], &quot;level&quot;: 3, &quot;bLeft&quot;: 50, &quot;operator&quot;: &quot;&quot; &#125;], &quot;isExpand&quot;: true, &quot;level&quot;: 2, &quot;operator&quot;: &quot;&quot;, &quot;bLeft&quot;: 34 &#125;, &#123; &quot;id&quot;: 1600416117567, &quot;name&quot;: &quot;phones-1&quot;, &quot;parentType&quot;: &quot;array&quot;, &quot;flag&quot;: &quot;append&quot;, &quot;parentName&quot;: &quot;phones&quot;, &quot;children&quot;: [&#123; &quot;name&quot;: &quot;phoneNumber&quot;, &quot;protoName&quot;: &quot;phone_number&quot;, &quot;type&quot;: &quot;string&quot;, &quot;oneOfFields&quot;: null, &quot;isMessage&quot;: false, &quot;isEnum&quot;: false, &quot;isArray&quot;: false, &quot;isMap&quot;: false, &quot;isRequired&quot;: false, &quot;defaultVal&quot;: &quot;12345678911&quot;, &quot;value&quot;: &quot;&quot;, &quot;id&quot;: 4276, &quot;parentName&quot;: &quot;phones&quot;, &quot;isExpand&quot;: true, &quot;children&quot;: [], &quot;level&quot;: 3, &quot;bLeft&quot;: 50, &quot;operator&quot;: &quot;&quot; &#125;, &#123; &quot;name&quot;: &quot;phoneType&quot;, &quot;protoName&quot;: &quot;phone_type&quot;, &quot;type&quot;: &quot;services.UserLoginRequest.PhoneType&quot;, &quot;oneOfFields&quot;: null, &quot;isMessage&quot;: false, &quot;isEnum&quot;: true, &quot;isArray&quot;: false, &quot;isMap&quot;: false, &quot;isRequired&quot;: false, &quot;defaultVal&quot;: &quot;mobile&quot;, &quot;value&quot;: &quot;mobile&quot;, &quot;id&quot;: 62179, &quot;parentName&quot;: &quot;phones&quot;, &quot;isExpand&quot;: true, &quot;children&quot;: [], &quot;level&quot;: 3, &quot;bLeft&quot;: 50, &quot;operator&quot;: &quot;&quot; &#125;], &quot;isExpand&quot;: true, &quot;level&quot;: 2, &quot;operator&quot;: &quot;&quot;, &quot;bLeft&quot;: 34 &#125;], &quot;level&quot;: 1, &quot;operator&quot;: &quot;&quot;, &quot;bLeft&quot;: 34, &quot;id&quot;: 16793 &#125;, &#123; &quot;name&quot;: &quot;lastUpdateDate&quot;, &quot;protoName&quot;: &quot;last_update_date&quot;, &quot;type&quot;: &quot;google.protobuf.Timestamp&quot;, &quot;oneOfFields&quot;: null, &quot;isMessage&quot;: true, &quot;isEnum&quot;: false, &quot;isArray&quot;: false, &quot;isMap&quot;: false, &quot;isRequired&quot;: false, &quot;defaultVal&quot;: null, &quot;isExpand&quot;: true, &quot;children&quot;: [&#123; &quot;name&quot;: &quot;seconds&quot;, &quot;protoName&quot;: &quot;seconds&quot;, &quot;type&quot;: &quot;int64&quot;, &quot;oneOfFields&quot;: null, &quot;isMessage&quot;: false, &quot;isEnum&quot;: false, &quot;isArray&quot;: false, &quot;isMap&quot;: false, &quot;isRequired&quot;: false, &quot;defaultVal&quot;: &quot;123&quot;, &quot;value&quot;: &quot;0&quot;, &quot;id&quot;: 32046, &quot;parentName&quot;: &quot;lastUpdateDate&quot;, &quot;isExpand&quot;: true, &quot;children&quot;: [], &quot;level&quot;: 2, &quot;bLeft&quot;: 34, &quot;operator&quot;: &quot;&quot; &#125;, &#123; &quot;name&quot;: &quot;nanos&quot;, &quot;protoName&quot;: &quot;nanos&quot;, &quot;type&quot;: &quot;int32&quot;, &quot;oneOfFields&quot;: null, &quot;isMessage&quot;: false, &quot;isEnum&quot;: false, &quot;isArray&quot;: false, &quot;isMap&quot;: false, &quot;isRequired&quot;: false, &quot;defaultVal&quot;: &quot;222&quot;, &quot;value&quot;: 0, &quot;id&quot;: 27909, &quot;parentName&quot;: &quot;lastUpdateDate&quot;, &quot;isExpand&quot;: true, &quot;children&quot;: [], &quot;level&quot;: 2, &quot;bLeft&quot;: 34, &quot;operator&quot;: &quot;&quot; &#125;], &quot;level&quot;: 1, &quot;operator&quot;: &quot;&quot;, &quot;bLeft&quot;: 34, &quot;id&quot;: 60223 &#125;], &quot;services.UserLoginRequest.PhoneNumber&quot;: [&#123; &quot;name&quot;: &quot;phoneNumber&quot;, &quot;protoName&quot;: &quot;phone_number&quot;, &quot;type&quot;: &quot;string&quot;, &quot;oneOfFields&quot;: null, &quot;isMessage&quot;: false, &quot;isEnum&quot;: false, &quot;isArray&quot;: false, &quot;isMap&quot;: false, &quot;isRequired&quot;: false, &quot;defaultVal&quot;: &quot;&quot; &#125;, &#123; &quot;name&quot;: &quot;phoneType&quot;, &quot;protoName&quot;: &quot;phone_type&quot;, &quot;type&quot;: &quot;services.UserLoginRequest.PhoneType&quot;, &quot;oneOfFields&quot;: null, &quot;isMessage&quot;: false, &quot;isEnum&quot;: true, &quot;isArray&quot;: false, &quot;isMap&quot;: false, &quot;isRequired&quot;: false, &quot;defaultVal&quot;: &quot;mobile&quot; &#125;], &quot;services.UserLoginRequest.UserEmailEntry&quot;: [&#123; &quot;name&quot;: &quot;key&quot;, &quot;protoName&quot;: &quot;key&quot;, &quot;type&quot;: &quot;string&quot;, &quot;oneOfFields&quot;: null, &quot;isMessage&quot;: false, &quot;isEnum&quot;: false, &quot;isArray&quot;: false, &quot;isMap&quot;: false, &quot;isRequired&quot;: false, &quot;defaultVal&quot;: &quot;&quot; &#125;, &#123; &quot;name&quot;: &quot;value&quot;, &quot;protoName&quot;: &quot;value&quot;, &quot;type&quot;: &quot;string&quot;, &quot;oneOfFields&quot;: null, &quot;isMessage&quot;: false, &quot;isEnum&quot;: false, &quot;isArray&quot;: false, &quot;isMap&quot;: false, &quot;isRequired&quot;: false, &quot;defaultVal&quot;: &quot;&quot; &#125;], &quot;services.UserLoginRequest.UserNumEntry&quot;: [&#123; &quot;name&quot;: &quot;key&quot;, &quot;protoName&quot;: &quot;key&quot;, &quot;type&quot;: &quot;string&quot;, &quot;oneOfFields&quot;: null, &quot;isMessage&quot;: false, &quot;isEnum&quot;: false, &quot;isArray&quot;: false, &quot;isMap&quot;: false, &quot;isRequired&quot;: false, &quot;defaultVal&quot;: &quot;&quot; &#125;, &#123; &quot;name&quot;: &quot;value&quot;, &quot;protoName&quot;: &quot;value&quot;, &quot;type&quot;: &quot;services.UserLoginRequest.PhoneNumber&quot;, &quot;oneOfFields&quot;: null, &quot;isMessage&quot;: true, &quot;isEnum&quot;: false, &quot;isArray&quot;: false, &quot;isMap&quot;: false, &quot;isRequired&quot;: false, &quot;defaultVal&quot;: null &#125;], &quot;services.UserLoginRequest.UserWeightEntry&quot;: [&#123; &quot;name&quot;: &quot;key&quot;, &quot;protoName&quot;: &quot;key&quot;, &quot;type&quot;: &quot;string&quot;, &quot;oneOfFields&quot;: null, &quot;isMessage&quot;: false, &quot;isEnum&quot;: false, &quot;isArray&quot;: false, &quot;isMap&quot;: false, &quot;isRequired&quot;: false, &quot;defaultVal&quot;: &quot;&quot; &#125;, &#123; &quot;name&quot;: &quot;value&quot;, &quot;protoName&quot;: &quot;value&quot;, &quot;type&quot;: &quot;int32&quot;, &quot;oneOfFields&quot;: null, &quot;isMessage&quot;: false, &quot;isEnum&quot;: false, &quot;isArray&quot;: false, &quot;isMap&quot;: false, &quot;isRequired&quot;: false, &quot;defaultVal&quot;: 0 &#125;] &#125;, &quot;enumTypes&quot;: &#123; &quot;services.LoginStatus&quot;: [&#123; &quot;num&quot;: 0, &quot;name&quot;: &quot;success&quot; &#125;, &#123; &quot;num&quot;: 1, &quot;name&quot;: &quot;failed&quot; &#125;, &#123; &quot;num&quot;: 2, &quot;name&quot;: &quot;error&quot; &#125;], &quot;services.UserLoginRequest.Hobby&quot;: [&#123; &quot;num&quot;: 0, &quot;name&quot;: &quot;music&quot; &#125;, &#123; &quot;num&quot;: 1, &quot;name&quot;: &quot;basketball&quot; &#125;, &#123; &quot;num&quot;: 2, &quot;name&quot;: &quot;tour&quot; &#125;], &quot;services.UserLoginRequest.PhoneType&quot;: [&#123; &quot;num&quot;: 0, &quot;name&quot;: &quot;mobile&quot; &#125;, &#123; &quot;num&quot;: 1, &quot;name&quot;: &quot;home&quot; &#125;, &#123; &quot;num&quot;: 2, &quot;name&quot;: &quot;work&quot; &#125;] &#125;&#125; parse_test.go123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146/*** @author : hqd8080* @description : json转换* @date : 2021-05-15 21:56 */package testimport ( &quot;io/ioutil&quot; &quot;strconv&quot; &quot;testing&quot; &quot;time&quot; &quot;github.com/bitly/go-simplejson&quot;)func TestParseJSON(t *testing.T) &#123; data, err := ioutil.ReadFile(&quot;./request.json&quot;) if err != nil &#123; t.Log(err) &#125; js, err := simplejson.NewJson(data) requestType := js.Get(&quot;requestType&quot;).MustString() messageType := js.Get(&quot;messageTypes&quot;).Get(requestType) t.Log(&quot;count:&quot;, len(messageType.MustArray())) result := parseJSON(t, messageType) ret, err := result.EncodePretty() if err != nil &#123; t.Log(err) &#125; t.Log(string(ret))&#125;func parseJSON(t *testing.T, sourceJson *simplejson.Json) *simplejson.Json &#123; resultJson := simplejson.New() if len(sourceJson.MustArray()) &gt; 0 &#123; for i := 0; i &lt; len(sourceJson.MustArray()); i++ &#123; item := sourceJson.GetIndex(i) if len(item.Get(&quot;children&quot;).MustArray()) &gt; 0 &#123; if item.Get(&quot;isMap&quot;).MustBool() == true &#123; // t.Log(&quot;is map&quot;, item.Get(&quot;name&quot;).MustString()) data := parseJSON(t, item.Get(&quot;children&quot;)) dataMap, _ := data.Map() newMap := make(map[string]interface&#123;&#125;) for _, m := range dataMap &#123; mm, ok := m.(map[string]interface&#123;&#125;) if ok &#123; if len(mm) &gt; 2 &#123; nn := make(map[string]interface&#123;&#125;) for k, v := range mm &#123; if k == &quot;key&quot; &#123; continue &#125; nn[k] = v &#125; newMap[mm[&quot;key&quot;].(string)] = nn &#125; else &#123; newMap[mm[&quot;key&quot;].(string)] = mm[&quot;value&quot;] &#125; &#125; &#125; resultJson.Set(item.Get(&quot;name&quot;).MustString(), newMap) &#125; else if item.Get(&quot;isArray&quot;).MustBool() == true &#123; // t.Log(&quot;isArray:&quot;, item.Get(&quot;name&quot;).MustString()) data := parseJSON(t, item.Get(&quot;children&quot;)) dataMap, _ := data.Map() newMap := make([]interface&#123;&#125;, 0) for _, m := range dataMap &#123; arr, ok := m.([]interface&#123;&#125;) if ok &#123; for _, v := range arr &#123; newMap = append(newMap, v) &#125; &#125; mm, ok := m.(map[string]interface&#123;&#125;) if ok &#123; newMap = append(newMap, mm) &#125; &#125; resultJson.Set(item.Get(&quot;name&quot;).MustString(), newMap) &#125; else &#123; data := parseJSON(t, item.Get(&quot;children&quot;)) dataMap, _ := data.Map() resultJson.Set(item.Get(&quot;name&quot;).MustString(), dataMap) if item.Get(&quot;type&quot;).MustString() == &quot;google.protobuf.Timestamp&quot; &#123; // t.Log(item.Get(&quot;name&quot;).MustString()) var seconds, nanos int64 for _, t := range item.Get(&quot;children&quot;).MustArray() &#123; if row, ok := t.(map[string]interface&#123;&#125;); ok &#123; if field, ok := row[&quot;name&quot;].(string); ok &#123; switch field &#123; case &quot;seconds&quot;: seconds, _ = strconv.ParseInt(row[&quot;defaultVal&quot;].(string), 10, 64) case &quot;nanos&quot;: nanos, _ = strconv.ParseInt(row[&quot;defaultVal&quot;].(string), 10, 64) &#125; &#125; &#125; &#125; resultJson.Set(item.Get(&quot;name&quot;).MustString(), time.Unix(seconds, nanos).UTC().String()) &#125; &#125; &#125; else &#123; // t.Log(item.Get(&quot;name&quot;).MustString()) var defaultVal interface&#123;&#125; if item.Get(&quot;type&quot;).MustString() == &quot;bool&quot; &#123; defaultVal = item.Get(&quot;defaultVal&quot;).MustBool() &#125; else &#123; defaultVal = convertDefaultVal(item.Get(&quot;type&quot;).MustString(), item.Get(&quot;defaultVal&quot;).MustString()) &#125; if item.Get(&quot;name&quot;).MustString() == &quot;&quot; &#123; array := resultJson.Get(&quot;array&quot;).MustArray() array = append(array, defaultVal) resultJson.Set(&quot;array&quot;, array) &#125; else &#123; resultJson.Set(item.Get(&quot;name&quot;).MustString(), defaultVal) &#125; &#125; &#125; &#125; return resultJson&#125;func convertDefaultVal(t string, v string) interface&#123;&#125; &#123; switch t &#123; case &quot;int32&quot;, &quot;int64&quot;: i, _ := strconv.Atoi(v) return i case &quot;string&quot;: return v case &quot;bytes&quot;: return []byte(v) case &quot;float&quot;, &quot;double&quot;: f, _ := strconv.ParseFloat(v, 32) return f default: return v &#125;&#125;","categories":[{"name":"Go语言","slug":"Go语言","permalink":"https://hqd8080.github.io/categories/Go%E8%AF%AD%E8%A8%80/"}],"tags":[{"name":"golang","slug":"golang","permalink":"https://hqd8080.github.io/tags/golang/"}]},{"title":"gRPC学习笔记（一）","slug":"grpc/grpc","date":"2020-05-14T12:59:30.000Z","updated":"2024-03-17T14:20:19.278Z","comments":true,"path":"2020/05/14/grpc/grpc/","link":"","permalink":"https://hqd8080.github.io/2020/05/14/grpc/grpc/","excerpt":"","text":"gRPC学习笔记gRPC是一个高性能，开源，通用的RPC框架；由google开发；基于HTTP/2协议设计开发；采用protobuf数据序列化协议； 特点： 1.gRPC使用protobuf来定义服务，接口，和数据类型； 2.gRPC基于HTTP/2标准设计；高性能：双向流；头部压缩；多路复用等；对移动设备友好；节省带宽；降低TCP连接次数；提高CPU利用率； gRPC可以定义4种类型的服务接口： 1.一元RPC 2.服务端流RPC 3.客户端流式RPC 4.双向流式RPC 生成Go客户端和服务端代码： 1protoc --go_out=plugins=grpc:. pb/user.proto 使用流式编程的特点：向客户端或者服务器发送批量的数据。可以不用等待所有的消息全部接收后才开始响应；而是接收到第一条消息的时候及时响应;从而减少服务的延迟； 服务端采用流式响应：send客户端采用流式调用：recv 双向流RPC调用和客户端流RPC调用的区别：双向流：客户端发送一个请求数据后；立马就可以获取对应的服务端响应客户端流：会先将客户端的请求以流的形式发送完毕，再获取服务端的响应 HTTP/2（4大新特性） 1.二进制传输HTTP/2传输数据量的大幅减少,主要有两个原因：以二进制方式传输和Header压缩HTTP/2将请求和响应数据分割为更小的帧，并且它们采用二进制编码； 2.Header压缩(头部压缩) 3.多路复用在HTTP/2中引入了多路复用的技术。多路复用很好的解决了浏览器限制同一个域名下的请求数量的问题，同时也更容易实现全速传输，毕竟新开一个 TCP 连接都需要慢慢提升传输速度 4.Server Push（服务器推送）HTTP/2还在一定程度上改变了传统的“请求-应答”工作模式，服务器不再是完全被动地响应请求，也可以新建“流”主动向客户端发送消息。比如，在浏览器刚请求HTML的时候就提前把可能会用到的JS、CSS文件发给客户端，减少等待的延迟，这被称为”服务器推送”（ Server Push，也叫 Cache push） 例子：hello.proto 123456789101112131415161718192021syntax = &quot;proto3&quot;;package services;message HelloRequest &#123; string name = 1;&#125;message HelloReply &#123; string message = 1;&#125;service HelloService &#123; rpc SayHello(HelloRequest) returns (HelloReply);&#125;// client.gogrpc.Dial(*addr, grpc.WithInsecure())// server.gol, err := net.Listen(&quot;tcp&quot;, *addr)srv := grpc.NewServer() gRPC是基于HTTP/2协议设计开发（长连接），减少网络延迟，服务器维护连接状态，不用频繁的创建连接带来的开销。HTTP2 是一个全双工的流式协议, 服务端也可以主动 ping 客户端, 且服务端还会有一些检测连接可用性和控制客户端 ping 包频率的配置。gRPC 就是采用 HTTP2 来作为其基础通信模式的，所以默认的 gRPC 客户端都是长连接 2 长连接的优势（keepalive） 相比于短连接，长连接具有：较低的延时。由于跳过了三次握手的过程，长连接比短连接有更低的延迟。较低的带宽占用。由于不用为每个请求建立和关闭连接，长连接交换效率更高，网络带宽占用更少。较少的系统资源占用。server 为了维持连接，会为每个连接创建 socket，分配文件句柄， 在内存中分配读写 buffer，设置定时器进行 keepalive。因此更少的连接数也意味着更少的资源占用。 另外， gRPC 使用 HTTP/2.0 作为传输协议， 从该协议的设计来讲， 长连接也是更推荐的使用方式。","categories":[{"name":"gRPC","slug":"gRPC","permalink":"https://hqd8080.github.io/categories/gRPC/"}],"tags":[{"name":"golang","slug":"golang","permalink":"https://hqd8080.github.io/tags/golang/"},{"name":"gRPC","slug":"gRPC","permalink":"https://hqd8080.github.io/tags/gRPC/"}]},{"title":"Go语言结构体转字典实例","slug":"golang/go-struct-to-map","date":"2020-05-14T12:59:30.000Z","updated":"2023-10-24T06:02:00.167Z","comments":true,"path":"2020/05/14/golang/go-struct-to-map/","link":"","permalink":"https://hqd8080.github.io/2020/05/14/golang/go-struct-to-map/","excerpt":"","text":"结构体转字典实例1column := c.GetStrings(&quot;column&quot;) 1234567891011121314list, count, err := services.NewGcase(services.Slave()).CaseList(NewContext(), params, pageSize, pageNum)if err != nil &#123; c.ErrorCode(ErrCodeRet, http.StatusInternalServerError, &quot;get case list failed&quot;)&#125;res := make([]map[string]interface&#123;&#125;, 0)for _, item := range list &#123; res = append(res, structConvertMapByTag(item, &quot;json&quot;, column))&#125;ret := make(map[string]interface&#123;&#125;, 0)ret[&quot;data&quot;] = resret[&quot;count&quot;] = countc.Correct(ret) 123456789101112131415161718192021222324252627func structConvertMapByTag(obj interface&#123;&#125;, tagName string, col []string) map[string]interface&#123;&#125; &#123; t := reflect.TypeOf(obj) v := reflect.ValueOf(obj) var data = make(map[string]interface&#123;&#125;) for i := 0; i &lt; t.NumField(); i++ &#123; if len(col) &gt; 0 &#123; for _, item := range col &#123; tagName := t.Field(i).Tag.Get(tagName) if tagName == item &#123; fmt.Println(tagName) if tagName != &quot;&quot; &amp;&amp; tagName != &quot;-&quot; &#123; data[tagName] = v.Field(i).Interface() &#125; &#125; &#125; &#125; else &#123; // 不设置列的时候显示所有字段 tagName := t.Field(i).Tag.Get(tagName) if tagName != &quot;&quot; &amp;&amp; tagName != &quot;-&quot; &#123; data[tagName] = v.Field(i).Interface() &#125; &#125; &#125; return data&#125;","categories":[{"name":"Go语言","slug":"Go语言","permalink":"https://hqd8080.github.io/categories/Go%E8%AF%AD%E8%A8%80/"}],"tags":[{"name":"golang","slug":"golang","permalink":"https://hqd8080.github.io/tags/golang/"}]},{"title":"Go语言计算字符串长度（包含汉字）","slug":"golang/go-runecountInstring","date":"2020-05-14T12:56:28.000Z","updated":"2023-10-07T11:35:46.213Z","comments":true,"path":"2020/05/14/golang/go-runecountInstring/","link":"","permalink":"https://hqd8080.github.io/2020/05/14/golang/go-runecountInstring/","excerpt":"","text":"Go语言计算字符串长度（包含汉字）中英文混合1234567891011package mainimport ( &quot;fmt&quot; &quot;unicode/utf8&quot;)func main() &#123; count := utf8.RuneCountInString(&quot;Go语言计算字符串长度,中英文&quot;) fmt.Print(count) &#125;","categories":[{"name":"Go语言","slug":"Go语言","permalink":"https://hqd8080.github.io/categories/Go%E8%AF%AD%E8%A8%80/"}],"tags":[{"name":"golang","slug":"golang","permalink":"https://hqd8080.github.io/tags/golang/"}]},{"title":"Go的GC垃圾回收","slug":"golang/go-gc","date":"2020-05-14T12:49:40.000Z","updated":"2023-10-07T11:33:39.884Z","comments":true,"path":"2020/05/14/golang/go-gc/","link":"","permalink":"https://hqd8080.github.io/2020/05/14/golang/go-gc/","excerpt":"","text":"Go语言的GC垃圾回收GC垃圾回收GC是一种自动管理内存的机制，垃圾回收器会尝试回收程序不再使用的对象和占用的内存在程序中设置GC的触发频率debug.SetGCPercent 垃圾回收算法： 1.引用计数 2.标记-清除 Go采用三色标记法 3.分代收集 引用计数：对每个对象维护一个引用计数，当引用该对象的对象被销毁时，引用计数减1，当引用计数器为0时回收该对象优点：对象可以很快被回收缺点：不能很好的处理循环引用，而且实时的维护引用计数也有一定的代价代表语言：php，python 标记-清除：从根变量开始遍历所有引用的对象，引用的对象标记为”被引用”，没有被标记的变量被回收优点：解决引用计数的缺点，不能很好的处理循环引用，而且实时的维护引用计数也有一定的代价的缺点缺点：暂停程序的执行代表语言：Go （三色标记法） 分代收集按照对象生命周期的长短划分不同的代空间，生命周期长的放入老年代，而短的放入新生代，不同代有不同的回收算法和回收频率优点：收回性能好缺点：算法复杂代表语言:java Go的垃圾回收Go垃圾回收的原理是，标记出哪些内存还在使用中，（即被引用到），哪些内存不在使用了（即未被引用），把未被引用的内存回收，以供后续内存分配时再使用缺点就是，不是实时的回收内存，而是暂停程序的执行去处理内存回收 三色标记法这里的三色是对应了垃圾回收过程中对象的三种状态1.灰色：对象还在标记队列中等待2.黑色：对象已经被标记(该对象不会在本次GC中被清理)3.白色：对象未被标记(该对象会在本次GC中被清理) Go的STWGo中的STW（Stop The World）就是停止所有的goroutine，专心做垃圾回收，待垃圾回收结束后，再恢复goroutine,STW的长短直接影响了程序的性能 垃圾回收优化1.写屏障就是让goroutine与GC同时运行的手段，GC过程中新分配的内存会被立即标记，即本轮不回收，下次GC时再确定 2.补助GC使用goroutine参与一部分的GC工作来提高性能 垃圾回收的触发时机1.内存分配量达到阈值触发GC每次内存分配时都会检查当前内存分配量是否已达到阈值，如果达到阈值则立即触发GC阈值 = 上次GC内存分配量 X 内存增长率内存增长率由环境变量GOGC控制，默认为100，即每当内存扩大一倍时启动GC 2.定期触发GC默认情况下，最长两分钟触发一次GC 3.手动触发使用 runtime.GC() 来手动触发GC主要用于GC的性能测试和统计 逃逸分析是指由编译器决定内存分配的位置，不需要程序员指定 在函数中申请一个新的对象：如果分配在栈中，则函数执行结束后，可自动将内存回收如果分配在堆中，则函数执行结束后可交给GC（垃圾回收）处理 1.逃逸策略在函数中申请新的对象时，编辑器会根据该对象是否被函数外部引用来决定是否逃逸：如果函数外部没有引用，则优先放在栈中如果函数外部存在引用，则必定存放在堆中 注意：对于仅在函数内部使用的变量，也有可能存放在堆中，比如内存过大，超过栈的存储能力 使用interface类型存在逃逸的可能（动态类型逃逸）闭包引用对象逃逸","categories":[{"name":"Go语言","slug":"Go语言","permalink":"https://hqd8080.github.io/categories/Go%E8%AF%AD%E8%A8%80/"}],"tags":[{"name":"golang","slug":"golang","permalink":"https://hqd8080.github.io/tags/golang/"}]},{"title":"Go的交叉编译","slug":"golang/go-gobuild","date":"2020-05-14T12:49:40.000Z","updated":"2023-10-24T06:00:09.559Z","comments":true,"path":"2020/05/14/golang/go-gobuild/","link":"","permalink":"https://hqd8080.github.io/2020/05/14/golang/go-gobuild/","excerpt":"","text":"Go语言的交叉编译在不同的系统打包编译的命令 12#-o：指定编译后的二进制包名称GOOS=linux GOARCH=amd64 go build -o app main.go 12#编译windows的exe文件CGO_ENABLED=0 GOOS=windows GOARCH=amd64 go build -o test.exe main.go","categories":[{"name":"Go语言","slug":"Go语言","permalink":"https://hqd8080.github.io/categories/Go%E8%AF%AD%E8%A8%80/"}],"tags":[{"name":"golang","slug":"golang","permalink":"https://hqd8080.github.io/tags/golang/"}]},{"title":"Go语言生产者和消费者模式","slug":"golang/go-producer-consumer","date":"2020-01-02T03:17:10.000Z","updated":"2023-10-24T05:59:09.926Z","comments":true,"path":"2020/01/02/golang/go-producer-consumer/","link":"","permalink":"https://hqd8080.github.io/2020/01/02/golang/go-producer-consumer/","excerpt":"","text":"Go语言使用chan实现生产者和消费者代码12345678910111213141516171819202122232425262728293031package mainimport &quot;fmt&quot;// 消费者func consumer(data chan int, done chan bool) &#123; // 接收数据，直到通道被关闭 for v := range data &#123; fmt.Println(&quot;recv:&quot;, v) &#125; // 通知main消费结束 done &lt;- true&#125;// 生产者func producer(data chan int) &#123; for i := 0; i &lt; 4; i++ &#123; // 发送数据 data &lt;- i &#125; // 生产结束，关闭通道 close(data)&#125;func main() &#123; done := make(chan bool) // 用于接收消费者结束信号 data := make(chan int) // 数据管道 go consumer(data, done) // 启动消费者 go producer(data) // 启动生产者 &lt;-done // 阻塞，直到消费者发回结束信号&#125; 1234recv: 0recv: 1recv: 2recv: 3","categories":[{"name":"Go语言","slug":"Go语言","permalink":"https://hqd8080.github.io/categories/Go%E8%AF%AD%E8%A8%80/"}],"tags":[{"name":"golang","slug":"golang","permalink":"https://hqd8080.github.io/tags/golang/"}]}],"categories":[{"name":"Go语言","slug":"Go语言","permalink":"https://hqd8080.github.io/categories/Go%E8%AF%AD%E8%A8%80/"},{"name":"Kafka","slug":"Kafka","permalink":"https://hqd8080.github.io/categories/Kafka/"},{"name":"区块链","slug":"区块链","permalink":"https://hqd8080.github.io/categories/%E5%8C%BA%E5%9D%97%E9%93%BE/"},{"name":"Kubernetes","slug":"Kubernetes","permalink":"https://hqd8080.github.io/categories/Kubernetes/"},{"name":"Docker","slug":"Docker","permalink":"https://hqd8080.github.io/categories/Docker/"},{"name":"Nginx","slug":"Nginx","permalink":"https://hqd8080.github.io/categories/Nginx/"},{"name":"Linux","slug":"Linux","permalink":"https://hqd8080.github.io/categories/Linux/"},{"name":"gRPC","slug":"gRPC","permalink":"https://hqd8080.github.io/categories/gRPC/"},{"name":"go-zero","slug":"go-zero","permalink":"https://hqd8080.github.io/categories/go-zero/"},{"name":"MySQL","slug":"MySQL","permalink":"https://hqd8080.github.io/categories/MySQL/"},{"name":"Git","slug":"Git","permalink":"https://hqd8080.github.io/categories/Git/"},{"name":"微服务架构","slug":"微服务架构","permalink":"https://hqd8080.github.io/categories/%E5%BE%AE%E6%9C%8D%E5%8A%A1%E6%9E%B6%E6%9E%84/"},{"name":"Redis","slug":"Redis","permalink":"https://hqd8080.github.io/categories/Redis/"}],"tags":[{"name":"golang","slug":"golang","permalink":"https://hqd8080.github.io/tags/golang/"},{"name":"WebSocket","slug":"WebSocket","permalink":"https://hqd8080.github.io/tags/WebSocket/"},{"name":"kafka","slug":"kafka","permalink":"https://hqd8080.github.io/tags/kafka/"},{"name":"区块链","slug":"区块链","permalink":"https://hqd8080.github.io/tags/%E5%8C%BA%E5%9D%97%E9%93%BE/"},{"name":"Blockchain","slug":"Blockchain","permalink":"https://hqd8080.github.io/tags/Blockchain/"},{"name":"Solidity","slug":"Solidity","permalink":"https://hqd8080.github.io/tags/Solidity/"},{"name":"hardhat","slug":"hardhat","permalink":"https://hqd8080.github.io/tags/hardhat/"},{"name":"kubernetes","slug":"kubernetes","permalink":"https://hqd8080.github.io/tags/kubernetes/"},{"name":"k8s","slug":"k8s","permalink":"https://hqd8080.github.io/tags/k8s/"},{"name":"docker","slug":"docker","permalink":"https://hqd8080.github.io/tags/docker/"},{"name":"gorm","slug":"gorm","permalink":"https://hqd8080.github.io/tags/gorm/"},{"name":"redis","slug":"redis","permalink":"https://hqd8080.github.io/tags/redis/"},{"name":"Nginx","slug":"Nginx","permalink":"https://hqd8080.github.io/tags/Nginx/"},{"name":"linux","slug":"linux","permalink":"https://hqd8080.github.io/tags/linux/"},{"name":"gRPC","slug":"gRPC","permalink":"https://hqd8080.github.io/tags/gRPC/"},{"name":"MySQL","slug":"MySQL","permalink":"https://hqd8080.github.io/tags/MySQL/"},{"name":"Ethereum","slug":"Ethereum","permalink":"https://hqd8080.github.io/tags/Ethereum/"},{"name":"go-zero","slug":"go-zero","permalink":"https://hqd8080.github.io/tags/go-zero/"},{"name":"grafana","slug":"grafana","permalink":"https://hqd8080.github.io/tags/grafana/"},{"name":"prometheus","slug":"prometheus","permalink":"https://hqd8080.github.io/tags/prometheus/"},{"name":"git","slug":"git","permalink":"https://hqd8080.github.io/tags/git/"},{"name":"微服务","slug":"微服务","permalink":"https://hqd8080.github.io/tags/%E5%BE%AE%E6%9C%8D%E5%8A%A1/"},{"name":"microservice","slug":"microservice","permalink":"https://hqd8080.github.io/tags/microservice/"}]}